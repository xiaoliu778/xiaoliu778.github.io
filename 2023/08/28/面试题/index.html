<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="刘小烨">
    
    <title>
        
            面试题 |
        
        小刘博客
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/brands.min.css">
    
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-Hans","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true,"layout":"right"},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.svg","first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"黄色的森林分出两条路 || 我选择人迹更少的那一条，从此决定我一生的道路","hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":true,"preload":false},"code_block":{},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{},"post":{},"website_count":{},"version":"3.7.3"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container border-box">

    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               小刘博客
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">

                

                    <div class="fade-in-down-animation">
    <div class="post-page-container border-box">

        <div class="article-content-container border-box">

            <div class="article-title">
                <span class="title-hover-animation">面试题</span>
            </div>

            
                <div class="article-header border-box">
                    
                        <div class="avatar-box border-box">
                            <img src="/images/avatar.svg">
                        </div>
                    
                    <div class="info-box">
                        <div class="author">
                            <span class="name">刘小烨</span>
                            
                        </div>
                        <div class="meta-info border-box">
                            

<div class="article-meta-info-container border-box post">
    <div class="article-meta-info border-box">
        


        
            <span class="meta-info-item article-create-date">
                <i class="icon fa-solid fa-calendar-check"></i>&nbsp;
                <span class="pc">2023-08-28 22:23:47</span>
                <span class="mobile">2023-08-28 22:23</span>
            </span>

            <span class="meta-info-item article-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="pc">2023-08-29 11:24:45</span>
            </span>
        

        
            <span class="meta-info-item article-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul>
                    
                            <li class="category-item">
                                
                                <a href="/%E6%A0%87%E7%AD%BE/%E8%A7%A3%E6%9E%90/">解析</a>
                            </li>
                        
                    
                </ul>
            </span>
        

        
            <span class="article-tag meta-info-item border-box">
                <i class="icon fas fa-tags"></i>&nbsp;
                <ul>
                    
                </ul>
            </span>
        

        
        
        
        
    </div>

    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="普通函数与箭头函数的区别"><a href="#普通函数与箭头函数的区别" class="headerlink" title="普通函数与箭头函数的区别?"></a>普通函数与箭头函数的区别?</h2><ul>
<li>箭头函数没有原型对象prototype</li>
<li>箭头函数是匿名函数不能作为构造函数不能被new</li>
<li>箭头函数不能当作Generator函数，不能使用yeild关键字。</li>
<li>箭头函数不绑定arguments，取而代之用…rest参数解决</li>
<li>箭头函数不绑定this，会捕获他所在上下文的this值，作为自己的this值</li>
<li>箭头函数的 this永远指向其上下文的this ，任何方法都改变不了其指向，如 call() , bind() , apply()</li>
</ul>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>Generator函数也叫生成器函数是 ES6提供的一种异步编程解决方案<br>Generator函数像一个状态机，保存了许多状态，并将这些状态作为遍历器对象返回<br>为了和传统的函数区别，Generator函数function后面会跟着一个*号，函数内部通常有许多yield后跟着表达式表示状态。<br>Generator函数特性<br>1.传统的函数被调用后会立马执行，且一次执行到return结束，而Generator函数被调用时不会立马执行内部的语句，而是返回了一个遍历器对象，<br>2.由遍历器对象的next()方法启动，遇到yield后又会暂停，直到下一个next()才会继续启动。<br>Generator函数和构造函数的区别<br>1.Generator 函数返回的遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>)<br>	&#123;<br>		<span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>); <span class="hljs-comment">// undefined</span><br>		<span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>	&#125;<br>	<span class="hljs-keyword">let</span> ge=<span class="hljs-title function_">gen</span>() <span class="hljs-comment">//返回一个遍历器对象</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123;value: 1, done: false&#125;</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">//  &#123;value: 3, done: false&#125;</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">//  &#123;value: 4, done: true&#125;</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123;value: undefined , done: true&#125;</span><br><br></code></pre></td></tr></table></figure>

<h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise?"></a>什么是Promise?</h2><p>promise是解决异步的方法。</p>
<ul>
<li>Promise对象有两个特点：<ul>
<li>1）对象的状态不受外界的影响。</li>
<li>2）状态一旦改变，便不会再次改变。而且它的状态改变只会由（pending-&gt;fulfilled、pending-&gt;rejected）并且这两种情况只要发生其中一个，状态便固定了。</li>
</ul>
</li>
<li>Promise的优点：<ul>
<li>支持链式调用（可以将异步操作以同步的方式显示出来）避免回调地狱</li>
</ul>
</li>
</ul>
<h2 id="promise的使用场景"><a href="#promise的使用场景" class="headerlink" title="promise的使用场景?"></a>promise的使用场景?</h2><p>1.获取文件信息<br>2.配合Ajax获取信息<br>3.解决回调地狱，实现单行任务队列<br>4.node中进行本地操作的异步过程</p>
<h2 id="什么是回调地狱？"><a href="#什么是回调地狱？" class="headerlink" title="什么是回调地狱？"></a>什么是回调地狱？</h2><p>多层回调函数的相互嵌套 就形成了回调地狱<br>缺点：<br>    代码耦合性太强 牵一发而动全身 难以维护<br>    大量冗余的代码相互嵌套 代码的可读性变差</p>
<h2 id="对this的理解？"><a href="#对this的理解？" class="headerlink" title="对this的理解？"></a>对this的理解？</h2><p>1.任何情况下直接在script中写入的this都指向window<br>2.函数中的this在非严格模式下指向的是window，严格模式下是指向undefined<br>3.箭头函数中的this都指向函数外上下文环境的this指向<br>4.对象中的this指向对象外上下文环境的this<br>5.回调中的this指向：<br>①setTimeout，setInterval回调函数不管是不是严格模式都指向window<br>②通过函数内执行当前回调函数和递归中的this，在非严格模式下指向的是window，严格模式下指向的是undefined<br>③使用arguments执行函数时，this指向arguments<br>④事件中的回调函数，this指向事件监听的对象<br>6.call，apply，bind方法执行时，如果第一个参数传入的不是null或者是undefined，那么传入什么this指向什么；如果第一个参数传入的是null或undefined，非严格模式下this指向window<br>7.ES6的类中 this的指向<br>①构造函数中的this指向当前实例类所产生的实例对象<br>②类中实例化方法中this指向 谁执行该方法，this指向谁<br>③类中静态方法中this指向该类或者该类的构造函数<br>④类中实例化箭头方法，this仍然指向当前类实例化的实例对象<br>8.ES5的原形对象中的this指向<br>在原型的方法中，this指向实例化当前构造函数的实例化对象，就是谁执行该方法，this就指向谁</p>
<h2 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环"></a>什么是事件循环</h2><p>事件循环机制就是一种同步编程模型，用于异步处理操作，当代码中遇到需要等待操作结果的语句时 js引擎不会一直等待，而是将该语句放入事件的队列中，并执行下一步语句，异步操作完成的时候，就会将其对应的事件加入到事件队列中</p>
<h2 id="事件循环机制的组成"><a href="#事件循环机制的组成" class="headerlink" title="事件循环机制的组成"></a>事件循环机制的组成</h2><ul>
<li>事件队列：<br>  用来存储事件的队列，包括鼠标点击、键盘输入、定时器等等</li>
<li>执行栈：<br>  用来存储正在执行的代码</li>
<li>宏任务：<br>  指的是需要被放入事件队列中的任务，例如setTimeout&#x2F;setInterval等</li>
<li>微任务：<br>  指的是需要当前任务执行完成后立即执行的任务，例如Promise的then&#x2F;catch&#x2F;finally方法</li>
</ul>
<h2 id="事件轮询的机制-也叫事件循环的机制（eventLoop）"><a href="#事件轮询的机制-也叫事件循环的机制（eventLoop）" class="headerlink" title="事件轮询的机制 也叫事件循环的机制（eventLoop）"></a>事件轮询的机制 也叫事件循环的机制（eventLoop）</h2><p>一个用来等待和发送消息和事件的程序结构。<br>1、所有任务都在主线程上执行，形成一个执行栈。<br>2、主线程发现有异步任务，如果是微任务就把他放到微任务的消息队列里，如果是宏任务就把他放到宏任务的消息队列里。<br>3、执行栈所有同步任务执行完毕。<br>4、执行微任务队列，之后再执行宏任务队列。<br>5、以上步骤重复执行就是事件轮询</p>
<ul>
<li>宏任务：setInterVal setTimeout ajax</li>
<li>微任务：promise async await .then<ul>
<li>promise优先于setTimeout，setTimeout回调函数最后执行，promise一旦被定义就会立即执行</li>
</ul>
</li>
</ul>
<h2 id="for-in和for-of区别？"><a href="#for-in和for-of区别？" class="headerlink" title="for in和for of区别？"></a>for in和for of区别？</h2><ul>
<li>for  in 用于遍历对象的键，会遍历自身和原型链上的枚举属性 如果是数组将会把数组索引当做对象来遍历</li>
<li>枚举属性是由enumerable值决定的，true为可枚举，false为不可枚举</li>
<li>可枚举可以理解为是否可以被遍历</li>
<li>JS中预定义的原型属性一般是不可枚举的，而自己定义的属性一般可枚举</li>
<li>可以通过propertyIsEnumerable方法判断该属性是否可枚举</li>
<li><code>for of</code>和<code>forEach</code>一样,是直接得到值</li>
<li><code>for of</code>不能用于对象</li>
</ul>
<h2 id="new一个对象的过程？"><a href="#new一个对象的过程？" class="headerlink" title="new一个对象的过程？"></a>new一个对象的过程？</h2><ul>
<li>在堆内存中申请了一块空间 创建一个新对象</li>
<li>将新对象的__proto__指向构造函数中的原型对象prototype</li>
<li>新对象会绑定到函数调用的this(比如：实例对象捕获构造函数的this当做自己的this)</li>
<li>执行构造函数中的代码（为这个新对象添加属性）</li>
<li>返回新对象。| 将初始化完毕的新对象地址，保存到等号左边的变量中</li>
</ul>
<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>能够读取外层函数内部变量的函数</p>
<ul>
<li>当内层函数调用外层函数的变量或参数时产生闭包<br>1.访问作用域<br>2.函数嵌套<br>3.在作用域外被调用</li>
<li>闭包的优点：只有函数内部的子函数才能读取局部变量,可以避免全局污染(避免全局污染)</li>
<li>闭包的缺点：变量常驻内存，得不到释放会使内存持续增压，导致内存泄漏<br>使用场景<br>1.setTimeout<br>2.回调<br>3.函数防抖</li>
</ul>
<h2 id="什么是堆内存和栈内存？"><a href="#什么是堆内存和栈内存？" class="headerlink" title="什么是堆内存和栈内存？"></a>什么是堆内存和栈内存？</h2><p>堆内存是一种非连续的树形存储数据结构，每个节点有一个值<br>栈内存是一种连续存储数据结构，具有先进后出的性质</p>
<ul>
<li><p>堆主要用于存放复杂类型的变量</p>
<ul>
<li>堆是先进先出</li>
<li>空间较大</li>
<li>堆的申请和释放是由程序员控制的，容易产生内存泄漏</li>
</ul>
</li>
<li><p>栈主要是存储基本类型的变量</p>
<ul>
<li>栈是先进后出</li>
<li>空间较小</li>
<li>栈是由系统自动分配释放</li>
<li>栈的效率高</li>
</ul>
</li>
</ul>
<h2 id="节流和防抖？"><a href="#节流和防抖？" class="headerlink" title="节流和防抖？"></a>节流和防抖？</h2><p>防抖是连续触发的事件，只会执行最后一个<br>节流是每隔一段时间触发一次<br>实现防抖通过定时器<br>实现节流通过时间戳</p>
<ul>
<li>使用场景<br>  防抖：<br>  search搜索时，用户在不断输入值时，用防抖来节约请求资源。<br>  登陆，发短信（倒计时），防止用户点击过快，以至于发送多次请求<br>  节流：<br>  鼠标不断触发某事件时,如点击,只在单位事件内触发一次.<br>  懒加载时要监听计算滚动条的位置,但不必要每次滑动都触发,可以降低计算频率,而不必要浪费CPU资源.</li>
</ul>
<h2 id="哪些数组方法可以改变原数组？"><a href="#哪些数组方法可以改变原数组？" class="headerlink" title="哪些数组方法可以改变原数组？"></a>哪些数组方法可以改变原数组？</h2><p>shift()  unshift()  pop()  reverse()  sort()  splice()  push()</p>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>本质上就是一个JS对象，当数据发生变化时，我们不直接操作真实DOM，因为很昂贵，我们去操作这个JS对象，就不会触发大量回流重绘操作，再加上diff算法，可以找到两次虚拟DOM之间改变的部分，从而去一次性更新真实DOM 性能得到了大大的提升</p>
<h2 id="谈一谈垃圾回收机制"><a href="#谈一谈垃圾回收机制" class="headerlink" title="谈一谈垃圾回收机制?"></a>谈一谈垃圾回收机制?</h2><p>js它具有自动回收机制 就是对那些不再用的变量对象进行回收 进行空间的释放</p>
<ul>
<li>回收的两种机制<br>  1.标记清除 当它进入执行环境的时候 它会被打上进入环境 离开的时候再被打上离开环境 被打上离开环境标记的都会被清除掉<br>  2.引用计数</li>
<li>原理就是 垃圾收集器会定时找出那些不继续使用的变量 然后释放其内存 因为如果内存开销比较打 他的GC会停止响应其他操作 他会阻塞其他应用程序的执行<br>垃圾回收是按照固定时间 周期性的去执行的</li>
</ul>
<h2 id="less-和-sass-的区别"><a href="#less-和-sass-的区别" class="headerlink" title="less 和 sass 的区别 ?"></a>less 和 sass 的区别 ?</h2><p>相同点：<br>Sass和Less都是一种CSS预处理器<br>区别：</p>
<ul>
<li>Less在JS上运行，Sass在Ruby上使用；</li>
<li>两者编写变量的方式不同；<br>  变量定义符不一样，less用的是@，而sass用$。</li>
<li>在Less中仅允许循环数值，而在Sass中可以遍历任何类型的数据；</li>
<li>Sass有Compass，Less有Preboot。</li>
</ul>
<h2 id="CSS预处理器是什么？"><a href="#CSS预处理器是什么？" class="headerlink" title="CSS预处理器是什么？"></a>CSS预处理器是什么？</h2><p>CSS预处理器是一种脚本语言，用一种专门的编程语言来进行Web页面的样式设计，然后再转换为正常的CSS样式，进而实现构建动态CSS样式。<br>CSS 预处理器为 CSS 增加了一些编程的特性，无需考虑浏览器的兼容性问题。</p>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>就是一个函数的返回结果只依赖于它的参数，并且在执行过程中没有副作用，我们就把这个函数叫做纯函数。<br>（redux中的reducer就是纯函数）<br>优点：</p>
<ul>
<li>可复用性 纯函数仅依赖于传入的参数，这意味着你可以随意将这个函数移植到别的代码中，只需要提供他需要的参数即可</li>
<li>可测试性 纯函数非常容易进行单元测试，因为不需要考虑上下文环境，只需要考虑输入和输出。</li>
<li>并行代码 纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行。<!--
// 不是纯函数，依赖了外部变量a
var a = 1
function add(b) { return a+b }
add(1) // 2
// 是纯函数
function add(a, b) { return a+b }
add(1, 2) // 3
-->
<!-- 
// 不是纯函数，有副作用，改变obj里面的a
var obj = {a: 1}
function mul(obj) {
  return obj.a *= 2
}
mul(obj) //2
obj.a //2
// 是纯函数
var obj = {a: 1}
function mul(a) {
  return a *= 2
}
mul(obj.a) //2
obj.a //1 --></li>
</ul>
<h2 id="浏览器的同源策略机制"><a href="#浏览器的同源策略机制" class="headerlink" title="浏览器的同源策略机制?"></a>浏览器的同源策略机制?</h2><p>同源策略，指的是浏览器限制当前网页只能访问同源的接口资源。<br>所谓同源 两方必须是同协议、且同域名、且同端口。只要有一个不相同，则会受到浏览器的约束，不允许请求。</p>
<h2 id="token一般存放在哪里-为什么不存放在cookie内"><a href="#token一般存放在哪里-为什么不存放在cookie内" class="headerlink" title="token一般存放在哪里?为什么不存放在cookie内?"></a>token一般存放在哪里?为什么不存放在cookie内?</h2><p>首先有两个存放位置<br>一个是本地存储 另一种是cookie<br>但是两种都有缺点<br>存在本地存储中 这意味着任何在你的网站上的运行的JavaScript都可以访问，所以容易受到XSS攻击<br>如果存在cookie内的话，浏览器的请求默认会在请求头中携带cookie，所以容易受到csrf攻击<br>我的意见是 放到本地存储中<br>撇开localStorage的各种优点不谈，如果做好适当的XSS防护，收益是远大于风险的。<br>因为localStorage具有更灵活，更大空间，天然免疫 CSRF的特征。Cookie空间有限，而JWT一半都占用较多字节，而且有时你不止需要存储一个JWT。</p>
<ul>
<li>CSRF攻击<br>简单的说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如：发邮件、发信息、甚至财产操作如转账和购买商品）</li>
<li>XSS攻击<br>是一种代码注入攻击。攻击者通过在目标网站注入恶意脚本，在用户的浏览器上运行。利用这些恶意脚本，攻击者可以获取用户的敏感信息如Cookie、SessionID等，进而危害数据安全。</li>
</ul>
<h2 id="token是什么"><a href="#token是什么" class="headerlink" title="token是什么"></a>token是什么</h2><p>token其实就是访问资源凭证 一般在用户成功登陆后 服务器将登陆凭证做数字签名 加密后的字符串作为token</p>
<h2 id="如何实现一条0-5像素的线"><a href="#如何实现一条0-5像素的线" class="headerlink" title="如何实现一条0.5像素的线"></a>如何实现一条0.5像素的线</h2><p>方法一： 定位+缩放<br>利用的是 transform 缩放功能，将 1px 缩放一半，同时利用定位，将伪元素覆盖整个 div 元素，从而达到伪元素与本身元素的合并效果。</p>
<p>方法二： box-shadow<br>利用的是 box-shadow 的扩散半径可以设置为 0.5px 原理<br>方法三： 直接使用border属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">border</span>: <span class="hljs-number">0.</span>5px solid #f00;<br></code></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>用new关键字来调用定义的函数，称为构造函数。默认返回的是一个新对象，这个新对象具有构造函数定义的变量和函数以及方法</li>
</ul>
<h2 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><p>async&#x2F;await 是ES7提出的基于Promise的解决异步的最终方案。<br>async、await使用 async&#x2F;await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性 async用于申明一个function是异步的 而await用于等待一个异步方法执行完成</p>
<h2 id="transform的属性"><a href="#transform的属性" class="headerlink" title="transform的属性"></a>transform的属性</h2><p>none：不转换。<br>matrix(mei chui ke si)(n,n,n,n,n,n)：定义2D转换，使用六个值的矩阵。<br>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义3D转换，使用 16 个值的 4x4 矩阵。<br>translate(x,y)：定义2D转换。<br>translate3d(x,y,z)：定义3D转换。<br>translateX(x)：X轴转换<br>translateY(y)：Y轴转换<br>translateZ(z)：Z轴3D转换<br>scale(si gei o)(x,y)：定义2D缩放<br>scale3d(x,y,z)：定义3D缩放<br>scaleX(x)：X轴缩放<br>scaleY(y)：Y轴缩放<br>scaleZ(z)：Z轴3D缩放<br>rotate(angle)：定义2D旋转<br>rotate3d(x,y,z,angle)：定义3D旋转。<br>rotateX(angle)：X轴的3D旋转<br>rotateY(angle)：Y轴的3D旋转<br>rotateZ(angle)：Z轴的3D旋转<br>skew(x-angle,y-angle)：定义2D倾斜<br>skewX(angle)：X轴的2D倾斜<br>skewY(angle)：Y轴的2D倾斜</p>
<h2 id="IE盒模型和标准盒模型"><a href="#IE盒模型和标准盒模型" class="headerlink" title="IE盒模型和标准盒模型"></a>IE盒模型和标准盒模型</h2><ul>
<li>IE怪异盒子模型(怪异盒)的元素宽度width&#x3D;content+padding+border</li>
<li>标准盒模型(普通盒模型)的元素宽度width&#x3D;content+padding+border+margin</li>
</ul>
<h2 id="css实现三角形"><a href="#css实现三角形" class="headerlink" title="css实现三角形"></a>css实现三角形</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br><span class="hljs-attribute">border-left</span>:<span class="hljs-number">100px</span> solid red;<br><span class="hljs-attribute">border-right</span>:<span class="hljs-number">100px</span> solid transparent;<br><span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">100px</span> solid transparent;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>Axios是一个基于promise封装的http请求库<br>特点:<br>1、可以转换请求数据和响应数据，会把响应回来的数据转成 JSON类型的数据；<br>2、拦截请求和响应（相当于给请求加条件）；<br>3、axios.all(promises): 批量发送多个（异步）请求；<br>4、axios在浏览器端&#x2F;node 端都可以使用<br>5、安全性更高</p>
<h2 id="JQ中-符"><a href="#JQ中-符" class="headerlink" title="JQ中$()符"></a>JQ中$()符</h2><p>叫做jQuery的构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$()就是jQuery()，在里面可以传参数，作用就是获取元素。<br></code></pre></td></tr></table></figure>

<h2 id="普通函数和构造函数的区别"><a href="#普通函数和构造函数的区别" class="headerlink" title="普通函数和构造函数的区别"></a>普通函数和构造函数的区别</h2><p>构造函数：</p>
<ol>
<li>调用方式不一样 new Fn()</li>
<li>构造函数内部会创建一个新的对象，构造函数new出来的实例</li>
<li>函数内部的this指向 构造函数new出来的实例</li>
<li>默认的返回值是构造函数new出来的实例，return 返回基本类型无效,引用类型有效<br>普通函数：</li>
<li>fn()</li>
<li>在函数的内部不会创建新的对象</li>
<li>函数内部的this指向调用函数的对象（如果没有对象调用，默认是window）</li>
<li>返回值由return语句决定</li>
</ol>
<h2 id="浮动与定位"><a href="#浮动与定位" class="headerlink" title="浮动与定位"></a>浮动与定位</h2><p>float只是行内的 左右的改变，如果后面的元素不清除浮动(clear:both)的话 会影响后面元素的位置，<br>而positon定位的影响比较广，既能定义一个容器的定位也能定义一个容器里面的任意定位</p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>递归就是一个函数在它的函数体内调用它自身。执行递归函数将反复调用，每调用一次就进入新的一层。递归函数必须有结束条件。<br>优点：<br>代码简洁。<br>缺点：<br>1、时间和空间的消耗比较大<br>2、重复计算<br>3、栈溢出</p>
<h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h2><p><label> 标签为input元素定义标注 当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。</p>
<h2 id="ajax执行步骤"><a href="#ajax执行步骤" class="headerlink" title="ajax执行步骤"></a>ajax执行步骤</h2><p>1.首先创建一个XMLHttpRequest异步对象<br>2.然后使用open设置请求方式和请求地址<br>3.用send发送请求<br>4.监听状态变化<br>5.接收返回的数据</p>
<h2 id="最后一个元素选中css"><a href="#最后一个元素选中css" class="headerlink" title="最后一个元素选中css"></a>最后一个元素选中css</h2><p>:last-child</p>
<h2 id="统计字符串中出现最多的字母"><a href="#统计字符串中出现最多的字母" class="headerlink" title="统计字符串中出现最多的字母"></a>统计字符串中出现最多的字母</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;aabbbccdd&#x27;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getChar</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> str !== <span class="hljs-string">&#x27;string&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// 判断参数是否为字符串</span><br>    <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() <span class="hljs-comment">// 键为字母，值为次数</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i ++) &#123; <span class="hljs-comment">// 遍历字符串每一个字母</span><br>		<span class="hljs-keyword">let</span> char = str.<span class="hljs-title function_">charAt</span>(i) <span class="hljs-comment">// 当前字母</span><br>		obj[char] = obj[char] || <span class="hljs-number">0</span> <span class="hljs-comment">// 保证初始值为0</span><br>		obj[char] ++ <span class="hljs-comment">// 次数加1</span><br>	&#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<br>	<span class="hljs-keyword">let</span> maxChar <span class="hljs-comment">// 存储字母</span><br>	<span class="hljs-keyword">let</span> maxNum = <span class="hljs-number">0</span> <span class="hljs-comment">// maxChar字母对应的次数</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123; <span class="hljs-comment">// 遍历obj</span><br>		<span class="hljs-keyword">if</span> (obj[key] &gt; maxNum) &#123;<br>            maxChar = key <span class="hljs-comment">// 比较后存储次数多的字母</span><br>            maxNum = obj[key] <span class="hljs-comment">// 以及它对应的次数</span><br>        &#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> maxChar <span class="hljs-comment">// 返回结果</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;出现次数最多的字母为：&#x27;</span> + <span class="hljs-title function_">getChar</span>(str))<br></code></pre></td></tr></table></figure>

<h2 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h2><ul>
<li>属于匿名函数,直接调用;</li>
<li>在初次加载的时候，会执行一次(自执行函数只能执行一次)</li>
<li>自执行函数会形成一个独立的作用域<br>优点:将全局变量写在立即执行函数里，作为局部变量，防止变量污染全局(避免多次声明造成变量覆盖)<br>缺点:不能重复调用</li>
</ul>
<h2 id="数组-对象区别"><a href="#数组-对象区别" class="headerlink" title="数组 对象区别"></a>数组 对象区别</h2><p>创建方式不同：数组表示有序数据的集合，而对象表示无序数据的集合<br>调用方法不同<br>对象键值唯一，数组可以重复<br>对象没有长度，不能用for循环</p>
<h2 id="元素绑定事件"><a href="#元素绑定事件" class="headerlink" title="元素绑定事件"></a>元素绑定事件</h2><p>1、在HTML上绑定点击事件<br>2、使用js获取元素并添加绑定事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;click me&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>3、事件侦听注册事件 addEventListener</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>方法监听注册事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);</span><br><span class="language-javascript">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-number">22</span>);</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>4、jQuery 绑定事件<br>使用click 要引入jquery.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);<br></code></pre></td></tr></table></figure>


<h2 id="数组拉平"><a href="#数组拉平" class="headerlink" title="数组拉平"></a>数组拉平</h2><ul>
<li>递归</li>
<li>原始数组.flat();</li>
</ul>
<h2 id="postion属性的值有哪些"><a href="#postion属性的值有哪些" class="headerlink" title="postion属性的值有哪些"></a>postion属性的值有哪些</h2><p>static(si da tei ke)：默认值，元素没有开启定位<br>relative:元素的相对定位,以自身为参照物<br>absolute:元素的绝对定位，以开启了定位的祖先元素为参照物<br>fixed(fei ke si te):元素的固定定位</p>
<h2 id="静态方法-实例方法和原型方法"><a href="#静态方法-实例方法和原型方法" class="headerlink" title="静态方法 实例方法和原型方法"></a>静态方法 实例方法和原型方法</h2><ul>
<li>静态方法<ul>
<li>定义在构造函数上的方法</li>
<li>只能被构造函数访问</li>
</ul>
</li>
<li>实例方法<ul>
<li>构造函数中this上添加的属性都属于实例属性</li>
<li>只能被实例对象访问</li>
</ul>
</li>
<li>原型方法 是共享的方法<ul>
<li>通过构造函数的prototype定义的方法</li>
<li>能被实例直接访问，构造函数需通过prototype才可访问</li>
</ul>
</li>
</ul>
<h2 id="documentFragment"><a href="#documentFragment" class="headerlink" title="documentFragment"></a>documentFragment</h2><p>documentFragment是一个保存多个element的容器对象（保存在内存）当更新其中的一个或者多个element时，页面不会更新。只有当documentFragment容器中保存的所有element更新后再将其插入到页面中才能更新页面。<br>documentFragment用来批量更新</p>
<h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js">- 利用字面量创建对象<br>    优点：简单方便<br>	缺点：无法量产<br>    <span class="hljs-keyword">var</span> obj = &#123;<br>        <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;张三疯&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>        <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span>,<br>        <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi~&#x27;</span>);<br>        &#125;<br>    &#125;<br>	- 使用对象。<br>		调用对象的属性，我们采取对象名.属性名<br>			<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">uname</span>);<br>		调用属性另一种方法 对象名[<span class="hljs-string">&#x27;属性名&#x27;</span>]<br>			<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[<span class="hljs-string">&#x27;uname&#x27;</span>]);<br>		调用对象的方法对象名.方法名( )<br>			obj.<span class="hljs-title function_">sayHi</span>();<span class="hljs-comment">//千万别忘记加上函数的小括号</span><br><br>- 利用<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>创建对象<br>    通过这种方式，我们可以调用任意的构造函数(无参的和带参数的)<br>    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//O要大写</span><br>        obj.<span class="hljs-property">uname</span> = <span class="hljs-string">&#x27;张三疯&#x27;</span>;<br>        obj.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<br>        obj.<span class="hljs-property">sex</span> = <span class="hljs-string">&#x27;男&#x27;</span>;<br>        obj.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi~&#x27;</span>);<br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">uname</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[<span class="hljs-string">&#x27;sex&#x27;</span>]);<br>        obj.<span class="hljs-title function_">sayHi</span>();<br>        利用等号赋值的方法添加对象的属性和方法<br>        每个属性和方法之间用分号结束<br>- 利用构造函数创建对象<br>	构造函数的语法格式<br>    <span class="hljs-comment">//创建</span><br>        <span class="hljs-keyword">function</span> 构造函数名() &#123;<br>            <span class="hljs-variable language_">this</span>.属性 = 值;<br>            <span class="hljs-variable language_">this</span>.方法 = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//调用</span><br>        <span class="hljs-keyword">new</span> 构造函数名();<br>        <span class="hljs-comment">// 使用</span><br>		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> 构造函数名().属性)<br><br>- 使用<span class="hljs-title class_">Class</span>类的newInstance方法<br>    这个方法调用无参的构造函数创建对象。<br>- 使用<span class="hljs-title class_">Constructor</span>类的newInstance方法<br>    这个方法调用有参数的和私有的构造函数。<br>- 使用clone方法<br>    当我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。<br>- 使用反序列化<br>    当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。<br></code></pre></td></tr></table></figure>

<h2 id="本地对象-内置对象-宿主对象"><a href="#本地对象-内置对象-宿主对象" class="headerlink" title="本地对象 内置对象 宿主对象"></a>本地对象 内置对象 宿主对象</h2><ul>
<li>本地对象<br>与宿主无关，无论在浏览器还是服务器中都有的对象，就是ECMAScript标准中定义的类(构造函数)<br>在使用过程中需要我们手动new创建<br>  Object、Function、Array、String、Boolean、Number、Date</li>
<li>内置对象<br>与宿主无关，无论在浏览器还是服务器中都有的对象 ECMAScript已经帮我们创建好的对象 在使用过程中无需我们动手new创建<br>  Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）</li>
<li>宿主对象<br>浏览器提供的对象。所有的BOM和DOM都是宿主对象<br>什么是宿主？<br>宿主就是指JavaScript运行环境，js可以在浏览器中运行，也可以在服务器上运行(nodejs)<br>对于嵌入到网页中的js来说，其宿主对象就是浏览器，所以宿主对象就是浏览器提供的对象<br>所有的BOM和DOM都是宿主对象</li>
</ul>
<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>​ SPA（Single Page Application）单页面应用程序，页面内容的变化通过ajax局部更新实现，同时支持浏览器地址栏的前进与后退操作，又称单页面多视图。其实现原理是基于url地址的hash变化，hash改变会导致浏览器访问记录的改变，但不会触发新的url请求。SPA最核心的技术点就是前端路由。<br>优点：</p>
<ul>
<li>良好的交互体验 内容的改变不会重新加载页面 页面数据通过ajax异步获取 没有页面之间的跳转 不会出现跳转白屏的现象</li>
<li>良好的前后端分离工作模式 前端只需要专注于页面的渲染 更利于前端工程化的发展 后端只需要专注于API接口的提供 更易实现API接口的复用</li>
<li>减轻服务器的压力 服务器只提供数据不负责页面的合成和逻辑的处理 吞吐能力提高几倍<br>缺点：</li>
<li>首屏加载慢 解决方案 路由懒加载 CDN加速 代码压缩 网络传输压缩</li>
<li>不利于SEO(搜索引擎优化) 解决方案：SSR服务器端渲染</li>
</ul>
<h2 id="JQ链式调用"><a href="#JQ链式调用" class="headerlink" title="JQ链式调用"></a>JQ链式调用</h2><p>.:用于链式调用  jq方法的返回值,除了获取,几乎均返回jq对象<br>链式调用是通过return this的形式来实现的；通过对象上的方法，最后加上return this，把对象再返回来，对象就可以再继续调用方法，实现链式操作了；</p>
<ul>
<li>jq中链式结构断开怎么办？用end()<br>  end() 方法结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态。</li>
</ul>
<p>链式调用的好处：节省代码量，代码看起来更优雅<br>链式调用的问题：所有对象的方法返回的都是对象本身，也就是说没有返回值，所以这种方法不一定在任何环境下都适合。</p>
<h2 id="网页渲染过程"><a href="#网页渲染过程" class="headerlink" title="网页渲染过程"></a>网页渲染过程</h2><p>1.解析HTML文件，构建 DOM Tree(dom树)<br>2.解析CSS，构建 CSSOM Tree(CSS规则树)<br>3.将 DOM Tree 和 CSSOM Tree合并，构建Render tree(渲染树)<br>4.reflow(重排)：根据Render tree计算节点信息（Layout）<br>5.repaint(重绘)：根据计算好的信息绘制整个页面（Painting）</p>
<h2 id="获取元素属性"><a href="#获取元素属性" class="headerlink" title="获取元素属性"></a>获取元素属性</h2><p>innerHTML、outerHTML、innerText 、outerText、value 属于原生javascript的方法。<br>  text()、html()，val()属于jQuery中的方法。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>函数当作参数传递<br>函数当作返回值返回<br>回调函数就是一个通过函数指针调用的函数</p>
<h2 id="css权重"><a href="#css权重" class="headerlink" title="css权重"></a>css权重</h2><p>Css的权重是指样式的优先级<br>内联样式，权重值为1000<br>ID选择器，权重值为100<br>类、伪类，权重值为10<br>标签选择器，权重为1</p>
<h2 id="delete与vue-delete"><a href="#delete与vue-delete" class="headerlink" title="delete与vue.delete"></a>delete与vue.delete</h2><p>delete只是将删除的元素变成了undefined 其他的元素的键值还是不变。数组长度也不变。<br>Vue.delete是直接删除该元素，也改变了数组的键值，长度发生变化。</p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>包括：外边距,边框,内边距,和实际内容。<br>Margin（外边距）<br>Border（边框）<br>Padding（内边距）<br>Content（内容）</p>
<h2 id="javaScript的组成"><a href="#javaScript的组成" class="headerlink" title="javaScript的组成"></a>javaScript的组成</h2><p>ECMAScript：描述了JS的语法和基本对象。<br>DOM：处理网页内容的方法和接口<br>BOM：与浏览器交互的方法和接口</p>
<h2 id="JSON方法"><a href="#JSON方法" class="headerlink" title="JSON方法"></a>JSON方法</h2><p>JSON 指的是 JavaScript 对象表示法<br>JSON 是轻量级的文本数据交换格式<br>JSON 具有自我描述性，更易理解<br>JSON.stringify() 我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。<br>JSON.parse() 我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。</p>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>1、200 ：请求成功<br>2、204： 服务器成功处理了请求，但没有返回任何内容。<br>3、301： 请求的网页已永久移动到新位置。。<br>4、302： 请求的网页临时移动到新位置。<br>5、400： 服务器不理解请求的语法。<br>6、403： 服务器拒绝请求。<br>7、404： 服务器找不到请求的网页。<br>8、410 ：请求的资源永久删除<br>9、500 ：服务器遇到错误<br>10、503： 服务器目前无法使用</p>
<h2 id="最后一个圆角"><a href="#最后一个圆角" class="headerlink" title="最后一个圆角"></a>最后一个圆角</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span>/<span class="hljs-selector-pseudo">:nth-last-child</span>(<span class="hljs-number">1</span>)||(正数)<span class="hljs-selector-pseudo">:first</span>-child/:<span class="hljs-built_in">nth-first-child</span>(<span class="hljs-number">1</span>)&#123;<br>	<span class="hljs-attribute">border-radius</span>:<span class="hljs-number">50%</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="document-reday与window-onload的区别"><a href="#document-reday与window-onload的区别" class="headerlink" title="document.reday与window.onload的区别"></a>document.reday与window.onload的区别</h2><p>document.reday表示文档结构已经加载完成 不包含图片等非文字媒体文件<br>window.onload表示包含图片等文件的所有元素都加载完成。</p>
<h2 id="if有作用域吗"><a href="#if有作用域吗" class="headerlink" title="if有作用域吗"></a>if有作用域吗</h2><ul>
<li>只有函数有作用域，if是没有作用域的。<ul>
<li>但是有一种情况会让if看上去有作用域，就是在if {}语句中，使用const、let，他们会有块级作用域。(因为const、let才拥有块级作用域 )</li>
</ul>
</li>
</ul>
<h2 id="ajax生命周期-x2F-状态"><a href="#ajax生命周期-x2F-状态" class="headerlink" title="ajax生命周期&#x2F;状态"></a>ajax生命周期&#x2F;状态</h2><p>0 初始化xhr 请求对象<br>1 与服务器建立链接并开始向服务器发送请求<br>2 服务器已经接受请求<br>3 处理请求<br>4 请求已处理完成,响应就绪,js可以在此阶段获取数据</p>
<h2 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h2><p>同步，执行完函数或方法后，需要等待系统返回值或消息，这时程序是阻塞的，必须接收到返回的值或消息后才往下执行其他的命令。<br>异步，执行完函数或方法后，不必等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</p>
<h2 id="会话cookie和持久cookie"><a href="#会话cookie和持久cookie" class="headerlink" title="会话cookie和持久cookie"></a>会话cookie和持久cookie</h2><p>如果 cookie 不包含到期日期，则可视为会话 cookie。 会话 cookie 存储在内存中，决不会写入磁盘。 当浏览器关闭时，cookie 将从此永久丢失。<br>如果 cookie 包含到期日期，则可视为持久性 cookie。 在指定的到期日期，cookie 将从磁盘中删除。</p>
<ul>
<li>cookie过期时间设置方式：<br> -  cookie.setMaxAge(0);&#x2F;&#x2F;不记录cookie<br> -  cookie.setMaxAge(-1);&#x2F;&#x2F;会话级cookie，关闭浏览器失效  –会话cookie<br> -  cookie.setMaxAge(60*60);&#x2F;&#x2F;过期时间为1小时 –持久cookie</li>
</ul>
<h2 id="typeof返回值"><a href="#typeof返回值" class="headerlink" title="typeof返回值"></a>typeof返回值</h2><p>是以字符串的形式返回你查看的这个值是什么类型的<br>typeof可以判断类型也有六种，分别是：<br>    number<br>    string<br>    Boolean<br>    object<br>    undefined<br>    function<br>检测array返回object<br>检测null返回object<br>检测NaN返回number</p>
<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><p>1、获取当前的日期和时间<br>方法：new Date()<br>2、获取当前日期<br>new Date().toLocaleDateString()<br>3、返回当前时间<br>new Date().toLocaleTimeString()<br>4、从Date()对象返回当前 年份<br>new Date().getFullYear()<br>5、从Date()对象返回当前 月份<br>new Date().getMonth()+1<br>6、从Date()对象返回月份的当前 日<br>new Date().getDate()<br>7、从Date()对象返回星期几<br>new Date().getDay()<br>8、从Date()对象的 当前 小时<br>new Date().getHours()</p>
<h2 id="url请求过程"><a href="#url请求过程" class="headerlink" title="url请求过程"></a>url请求过程</h2><p>十步版  请求报文   响应报文<br>1.在浏览器地址栏中输入网址。<br>2.浏览器通过用户输入的URL构建HTTP请求报文。<br>3.浏览器发起DNS（寻址）解析，将域名转换为IP地址。<br>4.浏览器将请求报文发送给服务器。<br>5.服务器接收请求报文（request），并解析。<br>6.服务器处理用户请求，并将处理结果封装成HTTP响应报文（response）。<br>7.服务器将HTTP响应报文发送给浏览器。<br>8.浏览器接收服务器响应的HTTP响应报文，并解析。<br>9.浏览器解析 HTML 页面并展示<br>10.最终浏览器展示出了页面。<br>完整版：<br>    1.DNS 解析：将域名地址解析成 IP 地址<br>    按照以下顺序进行 DNS 解析：<br>        Browser DNS cache（浏览器 DNS 缓存）<br>        OS DNS cache（系统 DNS 缓存）<br>        Router DNS cache（路由器 DNS 缓存）<br>        ISP DNS cache（网络运营商 DNS 缓存）<br>        Recursive search（递归搜索）（若以上 4 种都未找到，则会进行 Recursive search）<br>    2. TCP 连接：TCP 三次握手<br>        第一次握手：由浏览器发起，告诉服务器我要请求数据<br>        第二次握手：由服务器发出，告诉浏览器我准备好接受数据了，你可以发送请求了<br>        第三次握手：由浏览器发出，告诉服务器我马上就发，你准备接受<br>    3. 发送 HTTP 请求&#x2F;处理请求：请求报文<br>    4.  接受响应：响应报文<br>    5.  浏览器解析、渲染页面<br>    6.  断开连接：TCP 四次挥手<br>        第一次挥手：由浏览器发器，发送给服务器，我东西发完了（请求报文），你准备关闭吧<br>        第二次挥手：由服务器发器，告诉浏览器，我东西接受完了（请求报文），我准备关闭了，你也准备好<br>        第三次挥手：由服务器发器，告诉浏览器，我东西发送完了（响应报文），你准备关吧<br>        第四次挥手：由浏览器发器，告诉服务器，我东西接受完了，我准备关了，你也准备好吧</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型-&gt;string、number、Boolean、null、undefined、symbol<br>引用数据类型-&gt;array、object、function<br>基本数据类型是保存在栈内存中，操作的是值，改变源数据不会影响新的变量<br>引用数据类型保存在堆内存中，操作的是地址，改变其中一个会影响另一个</p>
<h2 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h2><p>改变某个元素的结构之后，会重新绘制元素的样式(重绘)，此时会引起浏览器重绘</p>
<ul>
<li>改变页面布局之后，会发生回流布局重新排列，(回流会引起重绘，但是重绘不会引起回流)</li>
</ul>
<h2 id="如何减少回流和重绘"><a href="#如何减少回流和重绘" class="headerlink" title="如何减少回流和重绘"></a>如何减少回流和重绘</h2><ul>
<li><p>1.浏览器中的优化机制<br>浏览器会维护一个队列，队列中存放的是会触发回流和重绘的操作，当队列中的操作达到一定阀值或者到了一定的时间间隔时，浏览器就会清空队列，进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
</li>
<li><p>2.自己进行优化<br>使用className。集中修改样式<br>使用定位让元素脱离文档流。<br>在设置display:none;的元素上操作，最后显示出来<br>使用文档片段(document fragment)，在当前DOM外构建一个子树，在它上面操作所有DOM，再把它拷贝回文档。</p>
</li>
</ul>
<h2 id="GET-和-POST"><a href="#GET-和-POST" class="headerlink" title="GET 和 POST"></a>GET 和 POST</h2><p>GET把参数包含在URL中，POST通过request body传递参数。<br>GET在浏览器回退时是无害的，而POST会再次提交请求。<br>GET请求只能进行url编码，而POST支持多种编码方式。<br>GET请求参数会被保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的，而POST没有。<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>1）意外的全局变量引起的内存泄漏<br>原因：<br>解决：可以使用严格模式避免全局变量，不会被回收</p>
<p>2）闭包引起的内存泄漏<br>原因：闭包可以维持函数内局部变量，使其得不到释放<br>解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对dom的引用</p>
<p>3）没有清理的DOM元素引用<br>原因：对象中还存在对dom的引用<br>解决：手动删除即可</p>
<p>4） 忘记的定时器或者回调<br>原因：定时器中有dom的引用，即使dom删除了，但是定时器还在<br>解决：手动清除定时器和dom</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ul>
<li>深拷贝拷贝的是键和值<br>深拷贝会开辟一个新的栈，新对象跟原对象不共享内存，修改新对象不影响原对象<br>深拷贝实现方式：<br>JSON.parse(JSON.stringify())、手写递归、jquery的$.extend</li>
</ul>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>拷贝出来的目标对象的指针和源对象的指针指向的是同一块内存空间，<br>Object.assign(目标对象，源对象)</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>原型链继承(通过改变原型的指向实现继承)<br>    - 缺点：<br>        1、不能传递参数，<br>        2、如果父类的属性是引用类型，子类实列修改了该属性，其他的子类实列会共享该属性。<br>借用父级构造函数实现继承(通过call修改this指向)(不会继承prototype)<br>    - 缺点：<br>        1、子类无法继承父类在原型链上的属性和方法。<br>        2，每个实例都拷贝一份，占用内存大，尤其是方法过多的时候 (函数复用又无从谈起了，本来我们用prototype就是解决复用问题的)<br>    - 优点：<br>    1、解决了子类实列修改了父类属性，其他的子类实列会共享该属性的问题<br>组合继承(原型链继承+借用构造函数继承)<br>    组合继承是js最常用的继承模式，<br>    - 缺点：<br>        1、组合继承最大的问题就是无论在什么情况下，都会调用两次构造函数：一次是在创建子类型原型时，另一次是在子类构造函数内部。<br>寄生组合继承(常用)<br>    - 寄生组合继承就是避免两次调用父类构造函数，通过赋值直接继承父类的原型</p>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>事件冒泡：当某个元素的某类型事件被触发时（如 onclick），它父级的同类型事件也会被触发，它的父级的父级同类型事件也会被触发，以此类推，一直触发到根元素。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。</p>
<h2 id="H5新标签"><a href="#H5新标签" class="headerlink" title="H5新标签"></a>H5新标签</h2><p>新增的语义化布局标签</p>
<ol>
<li>header和footer(fu te)标签：页面中一个内容区块的头部和尾部布局；</li>
<li>nav：导航区域；</li>
<li>article(a ti ke)标签：页面中独立的内容部分布局；</li>
<li>aside(e sai de)标签：在独立内容之外，但是又与article有关联的部分布局；<br>新增媒体标签</li>
<li>audio(o diu)（音频）；</li>
<li>video(v diu)（视频）；<br>新增canvas和svg绘画元素</li>
<li>canvas表示位图区域；</li>
<li>svg定义矢量图；<br>新增表单增强元素<br>表单元素 input 的 type 属性扩充：(下面都属于type的类型)<br>date（输入日期）；<br>email（输入邮件）；<br>url（输入url地址）；<br>search（呈现搜索常规的文本域）；<br>range（输入一定范围内的数值）；<br>month（输入月份）；<br>color（颜色）；<br>number（输入数值）；<br>以及表单元素 input 通过属性进行表单验证：required（必填项）、pattern（验证表单输入）。</li>
</ol>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>浏览器内核又可以分成两部分：渲染引擎和JS引擎<br>渲染引擎：负责获取网页的内容并显示<br>JS引擎：负责解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果</p>
<ul>
<li>常用内核(内核种类很多) (怎么分析内核)<br>  常见浏览器内核可以分这四种：Trident(拆呢te(IE内核))、Gecko(带构(火狐))、Blink(be(四声)琳ke(谷歌))、Webkit(web凯te(谷歌))<br>1、IE浏览器内核：               Trident内核，也是俗称的IE内核；<br>2、Chrome浏览器内核：           是Blink内核；<br>3、苹果Safari浏览器内核：       Webkit内核，<br>5、搜狗、QQ浏览器内核：         Trident（兼容模式）+Webkit（高速模式）；<br>6、百度浏览器：                 IE内核</li>
</ul>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>为什么有跨域，因为有同源策略<br>      同源策略：同源策略是一种约定，它是浏览器最核心也最基本的安全功能<br>当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域</p>
<h2 id="异步加载js"><a href="#异步加载js" class="headerlink" title="异步加载js"></a>异步加载js</h2><p>defer(script标签中增加defer属性，异步加载)：<br>    但要等dom文档全部解析完（dom树生成）才会被执行。<br>    只有IE能用；<br>async(script标签中增加async属性，异步加载):<br>    加载完就执行;async只能加载外部脚本<br>    不能把js写在script标签里。<br>    .w3c标准，IE9以下不支持<br>封装一个函数兼容性的异步加载js文件并且可以按需执行该文件里面的函数（按需加载）</p>
<h2 id="px，em和rem的区别"><a href="#px，em和rem的区别" class="headerlink" title="px，em和rem的区别"></a>px，em和rem的区别</h2><p>1、px代表像素，呈现的大小和屏幕分辨率有关系，分辨率越高元素尺寸越小，分辨率越低尺寸约大；<br>2、em是相对于父元素大小的相对尺寸；<br>3、rem是元素相对于根元素html的相对尺寸；<br>4、所有浏览器默认的字体大小是16px；</p>
<h2 id="link和-import的区别"><a href="#link和-import的区别" class="headerlink" title="link和@import的区别"></a>link和@import的区别</h2><p>1、link属于XHTML标签，而@import完全是CSS提供的一种方式。<br>2、加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。<br>3、兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>1.1.1 雪碧图<br>雪碧图是根据css sprite(si bai te)音译过来的，就是将很多小图标放在一张图片上就称之为雪碧图，可以减少网站http请求数量，不过随着字体图片、svg图片的流行该技术慢慢退出了舞台</p>
<p>1.1.2 Base64<br>将图片的内容以Base64格式内嵌到HTML中，可以减少http请求数量，但是编码之后的大小比图片大了</p>
<p>1.1.3 使用字体图标来代替图片<br>1.2 减少重定向<br>尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验<br>如果一定要使用重定向的话，如http重定向到https，要使用301永久重定向，而不是302临时重定向，因为如果使用302则每一次访问http都会重定向到https页面，而永久重定向在第一次从http重定向到https之后，每次访问http，会直接返回https的页面</p>
<p>1.3 使用缓存<br>使用cache-control或expires这类强缓存的时候，缓存不过期的情况下不会向服务器发起请求。强缓存过期的时候，会使用last-modified或etag这类协商缓存向服务器发起请求，如果资源没有变化，则服务器返回304响应，浏览器继续从本地缓存加载资源，如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回200</p>
<p>1.4 不使用css@import<br>使用css@import会造成额外的请求</p>
<p>1.5 避免使用空的src和href<br>a标签设置空的href，会重定向到当前页面的地址<br>form设置空的method，会提交表单到当前页面的地址</p>
<p>2.1 html压缩<br>html代码压缩就是压缩在文本文件中有意义，但是在html中不显示的字符，包括空格，制表符</p>
<p>2.2 css压缩<br>css压缩包括无效代码删除与css语义合并</p>
<p>2.3 js压缩与混乱<br>js压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码的可读性、实现代码的保护</p>
<p>2.4 图片压缩</p>
<p>3.1 使用CDN<br>CDN是内容分发网络，它能够实时地根据网络流量和各个节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，其目的是使用户可以就近的取得所需内容，解决网络拥挤的状况，提高网站的响应速度</p>
<p>3.2 使用DNS预解析<br>当浏览器访问一个域名的时候，需要解析一次DNS,获得对应域名的ip地址，在解析过程中，按照浏览器缓存、系统缓存、路由器换算、DNS缓存、域名服务器的顺序，逐步读取缓存，直到拿到ip地址</p>
<p>3.3 持久连接<br>使用keep-alive或者persistent来建立持久连接，降低了延时和连接建立的开销</p>
<p>4、优化资源加载<br>4.1 资源加载位置<br>通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使用功能可用<br>1、css文件放在head中，先外链，后本页<br>2、js文件放在body底部，先外连，后本页<br>3、处理页面、处理页面布局的js文件放在head中，如babel-polyfill.js文件、flexible.js文件<br>4、body中尽量不写style标签和script标签</p>
<p>4.2 资源加载时机<br>1、异步script标签<br>defer：异步加载，在html解析完成后执行。defer的实际效果与将代码放在body底部类似<br>async：异步加载，加载完成后立即执行<br>2、模块按需加载<br>在SPA等业务比较复杂的系统中，需要根据路由来加载当前页面所需要的业务模块<br>按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积</p>
<p>webpack提供了两类技术，优先选择的方式是使用符合ECMAScript提案的import语法，第二种就是使用webpack特定的require.ensure</p>
<p>3、使用资源预加载preload和资源预读取prefetch<br>preload让浏览器提前加载指定资源，需要执行时候再执行，可以加快当前页面的加载速度<br>prefetch告诉浏览器加载下一个页面可能会用到的资源，可以加速下一个页面的加载速度<br>4、资源懒加载与资源预加载<br>资源延迟加载也称为资源懒加载，延迟加载资源或符合某些条件的时候才加载某些资源<br>资源预加载是提前加载用户所需的资源，保证良好的用户体验<br>资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不能操作，浏览器空闲的时候再加载资源，优化了网络性能</p>
<h2 id="img-中-title和alt区别"><a href="#img-中-title和alt区别" class="headerlink" title="img 中 title和alt区别"></a>img 中 title和alt区别</h2><p>图片中的 alt属性是在图片不能显示时出现的文本提示。alt有利于SEO优化<br>图片中的 title属性是在鼠标在移动到图片上的文本提示。</p>
<h2 id="DOM与BOM分别是什么？"><a href="#DOM与BOM分别是什么？" class="headerlink" title="DOM与BOM分别是什么？"></a>DOM与BOM分别是什么？</h2><p>DOM是文档对象模型<br>    它指的是把文档当作一个对象来对待，提供访问和操作网页内容的方法和接口<br>    - 方法：<br>    document.head  获取一个html的head部分<br>    document.body  获取一个html的body部分<br>    document.innerHTML 获取标签<br>    document.innerText 获取文本<br>    document.querySelector 获取元素<br>    document.getElementById 根据id获取元素<br>    onclick 点击事件<br>    addEventListener 点击事件<br>BOM是浏览器对象模型<br>    它指的是将浏览器当作一个对象来对待，提供与浏览器交互的方法和接口<br>    - 方法<br>    prompt  显示可提示用户输入的对话框<br>    alert  显示带有一个提示信息和一个确定按钮的警示框<br>    confirm  显示一个带有提示信息、确定和取消按钮的对话框<br>    close  关闭浏览器窗口<br>    open  根据给定的url打开一个新的浏览器窗口<br>    setTimeout  在指定的毫秒数后调用函数或计算表达式<br>    setInterval  按照指定的周期（以毫秒计）来调用函数或表达式</p>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>一、利用ES6 Set去重（ES6中最常用）<br>二、利用for嵌套for，然后splice去重（ES5中最常用）<br>三、利用filter配合indexOf去重<br>四、利用sort()<br>五、利用includes<br>六、利用递归去重</p>
<h2 id="区分数组对象"><a href="#区分数组对象" class="headerlink" title="区分数组对象"></a>区分数组对象</h2><p>1.通过constructor<br>2.通过Object.prototype.toString.call()<br>3.通过instanceof<br>4.ES5特地新增isArray()检测变量是否是数组</p>
<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>第一种：<br>字符串转数组，反转数组，数组转字符串。<br>split(“”)：根据空字符串拆分数组<br>reverse()：数组反转元素位置<br>join(“”)：数组转回字符串,且不带分隔符</p>
<p>第二种：<br>定义新的空字符串，遍历str，通过charAt()是取字符串的最后一个字符，再取倒数第二个…以此类推。都放到新的字符串前面。这样就是倒序的了</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托，又称事件代理，不是直接给标签添加事件 是给标签的父级添加事件 通过事件对象判断触发事件的标签是谁 执行不同的事件处理函数</p>
<h2 id="原型对象和对象的原型"><a href="#原型对象和对象的原型" class="headerlink" title="原型对象和对象的原型"></a>原型对象和对象的原型</h2><p>原型对象prototype 是创建函数 js引擎自动创建的对象<br>对象的原型__proto__ 是实例化对象的原型 会自动继承原型对象中的属性</p>
<h2 id="形参和实参是什么？"><a href="#形参和实参是什么？" class="headerlink" title="形参和实参是什么？"></a>形参和实参是什么？</h2><p>实参可以是常量、变量、表达式、函数等，在进行函数调用时，它们都必须有确定的值。<br>通常将函数处理的数据，影响函数功能的因素或者函数处理的结果作为形参。<br>实参是用来填充形参的<br>funcation a(b){<br>var x&#x3D;b;<br>}<br>a(‘zs’)<br>b是形参，’zs’为实参</p>
<h2 id="arguments是什么？"><a href="#arguments是什么？" class="headerlink" title="arguments是什么？"></a>arguments是什么？</h2><p>arguments是一个对应于传递给函数的参数的类数组对象。<br>类数组：是数组的形式，有length，但不具有数组的一切方法。<br>作用：<br>可以用arguments 对象判断传递给函数的参数个数并获取参数</p>
<!-- 比如，你给函数传了一个叫a的参数，并且只有这一个参数，那么a与arguments[0]都是对这个参数值的引用 -->

<h2 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h2><p>第一种方法<br>    在后端服务器设置 请求头 res.setHeader(“Access-Control-Allow-Origin”,”*”)<br>第二种方法<br>    允许指定源访问<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-keyword">let</span> arr=[<span class="hljs-string">&quot;浏览器请求路径&quot;</span>]<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-title function_">includes</span>(req.<span class="hljs-property">headers</span>.<span class="hljs-property">origin</span>))&#123;<br>        res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,req.<span class="hljs-property">headers</span>.<span class="hljs-property">origin</span>)<br>    &#125;<br>注意:谷歌浏览器不允许本地file文件load 右键谷歌浏览器--设置--目标：加上<span class="hljs-string">&quot;--allow-file-access-from-files&quot;</span>注意前面有空格<br></code></pre></td></tr></table></figure><br>第三种方法<br>    后端中下载插件 npm i cors<br>    然后引入<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cors=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cors&quot;</span>)<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>())<br></code></pre></td></tr></table></figure><br>第四种方法<br>    在前端通过script标签解决跨域问题<br>    Script src link 都不受同源策略的影响<br>    可以直接<sceript src="服务器路径"><br>    缺点：<br>    1、不能接收JSON数据 只能接收js代码 前端通过变量或者是函数名来接收<br>    2、无法携带拼接的参数 只能携带固定字符串 不能携带拼接在?后面的内容<br>    3、script标签是同步操作 第一个script执行完才能执行第二个script<br>第五种方法<br>    通过jsonp动态创建script<br>        jsonp的本质<br>        前端发起请求 发起请求前声明一个函数 function fn(data){console.log(data)}<br>        后端返回一个函数调用 res.send(fn(333))后端返回的函数名和前端声明的函数名要一致<br>        前端的函数中的参数也就是data接受的就是后端返回的数据 333<br>        动态scipt标签是可以传递拼接在?后边的参数的</p>
<pre><code>    动态创建script标签的三个步骤
    创建一个空标签 let s=docoument.createElement(&quot;script&quot;)
    给标签添加属性 s.src=&quot;http://localhost:3000/getData&quot;
    将创建好的标签追加到尾部 document.documentElement.appendChild(s)
</code></pre>
<p>第六种方法<br>    nginx(代理)<br>      总的结论：<br>          正向代理隐藏用户<br>          反向代理隐藏服务器<br>          正向代理：<br>              1.用户发送请求到自己的代理服务器<br>              2.自己的代理服务器发送请求到服务器<br>              3.服务器将数据返回到自己的代理服务器<br>              4.自己的代理服务器再将数据返回给用户<br>          反向代理：<br>              1.用户发送请求到反向代理服务器(访问的其实是反向代理服务器，但用户不知道)<br>              2.反向代理服务器发送请求到真正的服务器<br>              3.真正的服务器将数据返回给反向代理服务器<br>              4.反向代理服务器将数据返回给用户</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>在js中对象是一个无序的数据集合或者也可以说是属性和方法的集合，可以动态的添加属性和方法</li>
<li>面向对象是一种软件开发的思想和面向过程是相对应的，就是把程序看做一个对象，将属性和方法封装其中，以提高代码的灵活性、复用性、可扩展性</li>
<li>面向过程是按需求一步一步的用代码从上往下实现，这样做代码不易维护、复用、扩展</li>
<li>所以大型项目中我们需要以面向对象的方式去开发这样就体现了用面向对象的方法写出来的代码易维护、易复用、易扩展。</li>
</ul>
<h6 id="面向对象的特征：封装、继承、多态、抽象。"><a href="#面向对象的特征：封装、继承、多态、抽象。" class="headerlink" title="面向对象的特征：封装、继承、多态、抽象。"></a>面向对象的特征：封装、继承、多态、抽象。</h6><ul>
<li>封装<br>  我对封装的理解就是把属性和方法封装其中，将不需要对外公开的内容隐藏起来提供接口让用户访问属性和方法。</li>
<li>继承<br>  继承就好比我继承了我爸部分的相貌特征但我和我爸又不完全长一个样子，而且我自己没有钱但我爸有钱，我爸的钱可以给我花。<br>  就是指子类构造函数继承父类构造函数的一些属性和方法，但其本身也有一些自己的方法和属性</li>
<li>多态<br>  多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果<br>  比如一个我养了条狗和一个猫，我对它们发出“叫”的指令时它们一个是“汪汪汪”的叫一个是“喵喵喵”的叫，我给的指令是一样的它们发出来的声音却不一样。</li>
<li>抽象<br>  先不去考虑细节的东西，从大的方向开始。比如学生就是一个抽象实体，他的属性并不足以描述出一个人，需要更多的细节才能描述一个人的方方面面。使用抽象可以尽可能避免过早考虑一些细节</li>
</ul>
<h2 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型 原型链"></a>原型 原型链</h2><p>原型：<br>    所有的函数默认都有一个“prototype”这样公有且不可枚举的属性，它会指向另一个对象，这个对象就是原型。<br>原型链：<br>    当访问对象的属性或者方法时，首先对象从自身去找，找不到就会往原型中去找，也就是他构造函数的prototype中，如果原型中找不到，即构造函数中也没有该属性，就会往原型后面的原型上去找，这样就形成了链式的结构，称为原型链</p>
<h2 id="this指向的情况有哪些"><a href="#this指向的情况有哪些" class="headerlink" title="this指向的情况有哪些"></a>this指向的情况有哪些</h2><p>事件绑定中的 this<br>普通函数执行中的 this<br>箭头函数执行中的 this<br>构造函数中的 this<br>基于 call&#x2F;apply&#x2F;bind 强制改变中的 this</p>
<h2 id="Null和undefined的区别？"><a href="#Null和undefined的区别？" class="headerlink" title="Null和undefined的区别？"></a>Null和undefined的区别？</h2><p>1、null是JavaScript的关键字，而undefined是JavaScript的一个全局变量，也就是挂载在window对象上的一个变量，并不是关键字。<br>2、在使用typeof运算符进行检测时，Undefined类型的值会返回undefined.而Null类型的值返回为object<br>3、在需要进行字符串类型的转换时，null会转换成字符串null,而undefined会转换字符串undefined.<br>4、在进行数值类型的转换时，undefined会转换为NaN,无法参与计算，而null会转换为0,可以参与计算。<br>undefined +0;&#x2F;&#x2F; NaN<br>null+0 ;&#x2F;&#x2F; 0<br>5、建议：无论在什么情况下都没有必要将一个变量显示的赋值为undefined。如果需要定义某个变量来保存将来要使用的对象，应该将其初始化为null.</p>
<h2 id="Call、apply、bind的区别？"><a href="#Call、apply、bind的区别？" class="headerlink" title="Call、apply、bind的区别？"></a>Call、apply、bind的区别？</h2><p>call是一个方法,是函数的方法<br>call可以调用函数,call可以改变函数中this的指向</p>
<p>call和apply<br>相同点:都会调用函数<br>不同点:传参的方式不同,call传参时一直往后加参数,apply传参数是以数组的形式传参</p>
<p>call和bind<br>相同点:传参的方式一样<br>不同点:call会调用函数,bind不会调用函数,它会作为一个返回值返回一个函数,然后才可以调用</p>
<h2 id="DOCtype-document-type-的作用"><a href="#DOCtype-document-type-的作用" class="headerlink" title="DOCtype(document type)的作用"></a>DOCtype(document type)的作用</h2><ul>
<li>DOCTYPE是document type (文档类型) 的缩写。</li>
<li><strong>用于告诉浏览器该以什么文档标准去解析这个文档</strong></li>
<li>主要作用是告诉浏览器的解析器使用哪种HTML规范或者XHTML规范来解析页面。</li>
</ul>
<h2 id="JS语言主要分哪几部分-三部分"><a href="#JS语言主要分哪几部分-三部分" class="headerlink" title="JS语言主要分哪几部分 三部分"></a>JS语言主要分哪几部分 三部分</h2><ul>
<li>ECMAscript 提供核心语言功能</li>
<li>Dom 文档对象模型，提供访问和操作网页内容的方法和接口</li>
<li>Bom 浏览器对象模型，提供与浏览器交互的方法和接口</li>
</ul>
<h2 id="原型对象、实例对象、构造函数三者之间的关系"><a href="#原型对象、实例对象、构造函数三者之间的关系" class="headerlink" title="原型对象、实例对象、构造函数三者之间的关系"></a>原型对象、实例对象、构造函数三者之间的关系</h2><pre><code>  实例是由new构造函数生成;
  原型是构造函数的prototype,构造函数原型上的constructor属性,是构造函数本身;
实例的_proto_属性,指向构造函数原型
</code></pre>
<h2 id="判断对象自身是否包含此属性"><a href="#判断对象自身是否包含此属性" class="headerlink" title="判断对象自身是否包含此属性"></a>判断对象自身是否包含此属性</h2><ul>
<li>console.log(boj1.hasOwnProperty(‘age’))</li>
</ul>
<h2 id="认识函数"><a href="#认识函数" class="headerlink" title="认识函数"></a>认识函数</h2><ul>
<li>函数内部定义函数：闭包</li>
<li>函数内部调用其他函数：函数调用</li>
<li>函数内部调用参数传过来的函数：回调函数</li>
<li>函数内部调用自己这个函数：递归</li>
</ul>
<h2 id="JavaScript数组常用方法有哪些？"><a href="#JavaScript数组常用方法有哪些？" class="headerlink" title="JavaScript数组常用方法有哪些？"></a>JavaScript数组常用方法有哪些？</h2><p>1、push：在数组末尾添加一个或者多个元素 返回新数组的长度<br>2、pop：移除并返回数组末尾的元素<br>3、unShift：在数组头部添加一个或多个元素 返回新数组的长度<br>4、shift：移除并返回数组头部的元素<br>5、concat：合并两个或者多个数组 并返回合并后的新数组 该方法不会影响原数组<br>6、slice：从数组的指定位置截取元素，返回一个新数组，不会影响原始数组<br>7、splice：从数组指定位置删除或替换元素，可修改原始数组<br>8、indexOf：查找指定元素在数组的索引位置，如果没找到返回-1<br>9、lastIndexOf：从数组尾部查找指定元素的索引位置，如果没找到返回-1<br>10、includes：查找数组中是否有指定元素，返回布尔值<br>11、json：数组转字符串，并用指定分隔符连接它们<br>12、reverse：反转数组，影响原始数组<br>13、sort：数组排序，默认根据字母顺序排列，会修改原始数组<br>14、forEach：对数组每一个元素执行提供的函数<br>15、filter：遍历数组 返回所有符合条件的元素<br>16、map：创建一个新数组，其中包含对数组中的每一个元素操作后的结果<br>17、reduce：将数组中的元素进行累积操作，返回一个单一值<br>18、some：遍历数组 判断数组中是否有符合条件的元素 返回布尔值<br>19、every：遍历数组，判断数组中元素是否都符合条件 返回布尔值<br>20、find：遍历数组，返回第一个符合条件的元素本身</p>
<h2 id="导致JavaScript中this指向混乱的原因是什么"><a href="#导致JavaScript中this指向混乱的原因是什么" class="headerlink" title="导致JavaScript中this指向混乱的原因是什么"></a>导致JavaScript中this指向混乱的原因是什么</h2><p>在js中this的指向是动态的 也就是this指向会根据上下文的环境变化而发生变化 导致他的指向变得混乱或难以预测。常用的导致this指向混乱的原因包括一下几个方面：</p>
<h6 id="1、函数调用方式不同："><a href="#1、函数调用方式不同：" class="headerlink" title="1、函数调用方式不同："></a>1、函数调用方式不同：</h6><ul>
<li>当一个函数被调用时，它的this指向取决于调用方式，如果使用普通函数调用方式（如fn()），则this会指向全局对象window，如果是方法调用（如obj.fn()）则this指向调用该方法的对象</li>
</ul>
<h6 id="2、箭头函数的使用："><a href="#2、箭头函数的使用：" class="headerlink" title="2、箭头函数的使用："></a>2、箭头函数的使用：</h6><ul>
<li>箭头函数不具有自己的this值，他会捕获上下文中的this值，因此，如果在箭头函数中访问this，它会指向外层作用域中的this值</li>
</ul>
<h6 id="3、使用apply、call、bind方法"><a href="#3、使用apply、call、bind方法" class="headerlink" title="3、使用apply、call、bind方法"></a>3、使用apply、call、bind方法</h6><ul>
<li>apply、call、bind方法都可以改变this指向，其中apply、call方法可以立即执行函数并传入参数，而bind方法可以返回一个新函数，该函数的this值被绑定到指定对象上</li>
</ul>
<h6 id="4、对象的嵌套和继承："><a href="#4、对象的嵌套和继承：" class="headerlink" title="4、对象的嵌套和继承："></a>4、对象的嵌套和继承：</h6><ul>
<li>当一个对象被嵌套在另一个对象中或者使用继承时，this的指向可能变得混乱。这是因为this的指向取决于函数被调用时的上下文环境，而不是对象本身，因此，在嵌套对象或继承类中使用this时需要特别注意他的指向</li>
</ul>
<h2 id="怎么实现虚拟列表"><a href="#怎么实现虚拟列表" class="headerlink" title="怎么实现虚拟列表"></a>怎么实现虚拟列表</h2><ul>
<li>虚拟列表是一种优化长列表渲染性能的技术，他只渲染可视化区域内的内容，从而降低了页面渲染的复杂度</li>
<li>具体而言，实现虚拟列表需要以下几个步骤<br>1、计算可视化区域：首先计算出可见区域内的列表数量和位置<br>2、渲染可见区域：只渲染可见区域内的内容，而不是整个列表<br>3、动态调整列表高度：由于只渲染了部分列表项，因此需要动态调整列表容器的高度，确保滚动条可以正确显示并且用户可以滚动整个列表<br>4、延迟加载非可见区域：当用户滚动列表的时，需要根据当前滚动条0位置动态加载，非可见区域的列表项，以便在用户滚动到该区域是能够及时显示.</li>
</ul>
<h2 id="说说对轮询的理解"><a href="#说说对轮询的理解" class="headerlink" title="说说对轮询的理解"></a>说说对轮询的理解</h2><h6 id="什么是轮询"><a href="#什么是轮询" class="headerlink" title="什么是轮询"></a>什么是轮询</h6><ul>
<li>轮询是指在一定时间内，定时向服务器发送请求，获取最新数据的过程</li>
<li>轮询通常用于从服务器获取实时更新的数据</li>
</ul>
<h6 id="轮询和长轮询有什么区别"><a href="#轮询和长轮询有什么区别" class="headerlink" title="轮询和长轮询有什么区别"></a>轮询和长轮询有什么区别</h6><ul>
<li>轮询是在固定的时间间隔内向服务器发送请求，既是服务器没有数据更新，也会继续发送请求，而长轮询则是发送一个请求，服务器如果没有数据更新，则不会返回，而是一直挂着，直到有数据更新再返回结果</li>
</ul>
<h6 id="前端轮询的实现方法有什么"><a href="#前端轮询的实现方法有什么" class="headerlink" title="前端轮询的实现方法有什么"></a>前端轮询的实现方法有什么</h6><p>有两种：基于定时器的轮询和基于递归的轮询。基于定时器的轮询使用setInterval方法来定时发送请求，基于递归的轮询则使用setTimeout方法来控制下一次请求的时间</p>
<h6 id="轮询有什么缺点"><a href="#轮询有什么缺点" class="headerlink" title="轮询有什么缺点"></a>轮询有什么缺点</h6><ul>
<li>轮询会产生大量的无效请求，浪费宽带和服务器资源，并且对服务器压力比较大，同时在短时间内频繁对服务器发起请求，可能会被服务器视为恶意行为，导致IP被封禁等问题</li>
</ul>
<h6 id="如何避免轮询的缺点"><a href="#如何避免轮询的缺点" class="headerlink" title="如何避免轮询的缺点"></a>如何避免轮询的缺点</h6><ul>
<li>可以使用webSocket和SSE等技术来实现实时数据更新<br>  WebSocket是一种双向通信协议，能够实现服务器与客户端之间的实时通信。<br>  而SSE是一种基于HTTP的单向通信协议，可以实现服务器向客户端推送实时数据。</li>
<li>这些技术都能够减少无效请求，提高数据传输效率，并且对服务器资源的消耗也比较小</li>
</ul>
<h2 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li><p>作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合</p>
</li>
<li><p>换句话说：作用域决定了代码区块中变量和其他资源的可见性</p>
</li>
<li><p>我们一般将作用域分为：<br>  全局作用域<br>  局部作用域<br>  块级作用域</p>
</li>
</ul>
<h6 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h6><ul>
<li>不在任何函数中和大括号中的变量 我们都视为全局作用域，全局作用域下的变量可以在任意位置访问到</li>
</ul>
<h6 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h6><p>函数作用域也称局部作用域 如果一个变量在函数内部声明，那么这个变量只能在这个函数体内部才能被访问到，函数外是访问不到的</p>
<h6 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h6><p>ES6中引入let和const关键字，和var关键字不同的是，在大括号中使用let和const声明的变量存在于块级作用域，在大括号外是访问不到的</p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><ul>
<li>又叫静态作用域，变量被创建时就确定好了，JavaScript就是遵循的词法作用域</li>
<li>相同层级的两个函数没有办法访问打彼此作用域中的变量</li>
</ul>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul>
<li>当js中使用一个变量时，首先js引擎会在当前作用域下去查找，如果没找到，则会去它的上层作用域查找，依次类推直到找到该变量或者找到了全局作用域</li>
<li>如果在全局作用域找不到，在非严格模式下回隐式声明该变量，严格模式直接报错</li>
</ul>
<h2 id="ES6有哪些新特性"><a href="#ES6有哪些新特性" class="headerlink" title="ES6有哪些新特性"></a>ES6有哪些新特性</h2><h3 id="1、let、const-块级作用域以及和-var-的区别"><a href="#1、let、const-块级作用域以及和-var-的区别" class="headerlink" title="1、let、const 块级作用域以及和 var 的区别"></a>1、let、const 块级作用域以及和 var 的区别</h3><p>声明方式	变量提升	作用域	初始值	重复定义<br>var			  是	   函数级  不需要	允许<br>let			  否	    块级   不需要  不允许<br>const		  否		块级	必需   不允许</p>
<h3 id="2、解构-快速提取数组-x2F-对象中的元素"><a href="#2、解构-快速提取数组-x2F-对象中的元素" class="headerlink" title="2、解构-快速提取数组&#x2F;对象中的元素"></a>2、解构-快速提取数组&#x2F;对象中的元素</h3><h6 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h6><ul>
<li><p>单独解构-根据数组索引，将数组解构成单独的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">const</span> [a, b, c] = arr<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, c) <span class="hljs-comment">//1,2,3</span><br><span class="hljs-keyword">const</span> [, , d] = arr<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d) <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>默认值，解构时可以给变量设置默认值，数组没有这个元素的话</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">const</span> [, , , defaultVal = <span class="hljs-string">&#x27;4&#x27;</span>] = arr<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;设置默认值&#x27;</span>, defaultVal)<br></code></pre></td></tr></table></figure>
</li>
<li><p>剩余解构用 “…+变量名” 解构剩余参数到新数组，只能用一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">const</span> [e, ...rest] = arr<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest) <span class="hljs-comment">//[2, 3]</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h6 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h6><ul>
<li><p>单个&#x2F;多个解构-跟数组解构差不多</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zzm&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">height</span>: <span class="hljs-literal">undefined</span> &#125;<br><span class="hljs-keyword">const</span> &#123; name, age &#125; = obj<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age) <span class="hljs-comment">// &#x27;zzm&#x27;, 18</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>解构+重命名-给解构出来的变量重命名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zzm&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">height</span>: <span class="hljs-literal">undefined</span> &#125;<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">name</span>: objName &#125; = obj<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objName)<br></code></pre></td></tr></table></figure>
</li>
<li><p>默认值-给解构变量设置默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zzm&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">height</span>: <span class="hljs-literal">undefined</span> &#125;<br><span class="hljs-keyword">const</span> &#123; next = <span class="hljs-string">&#x27;default&#x27;</span> &#125; = obj<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(next)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="3、模板字符串"><a href="#3、模板字符串" class="headerlink" title="3、模板字符串"></a>3、模板字符串</h3><p>用法：使用&#96;&#96;将字符串包裹起来<br>功能：可以换行、插值、使用标签函数进行字符串操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//换行</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">`fdsjak</span><br><span class="hljs-string">    fdsa`</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br><span class="hljs-comment">// 插值</span><br><span class="hljs-keyword">const</span> strs = <span class="hljs-string">`random: <span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.random()&#125;</span>`</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strs)<br></code></pre></td></tr></table></figure>

<h3 id="4、字符串扩展方法"><a href="#4、字符串扩展方法" class="headerlink" title="4、字符串扩展方法"></a>4、字符串扩展方法</h3><ul>
<li>includes-是否包含</li>
<li>startsWith-是否以什么开始</li>
<li>endsWith-是否以什么结束</li>
</ul>
<h3 id="5、参数默认值-amp-剩余参数"><a href="#5、参数默认值-amp-剩余参数" class="headerlink" title="5、参数默认值&amp;剩余参数"></a>5、参数默认值&amp;剩余参数</h3><ul>
<li>给函数形参设置默认值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 带默认参数的形参一般放在后面，减少传参导致的错误几率</span><br><span class="hljs-keyword">const</span> defaultParams = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, age = <span class="hljs-number">0</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> [age, name]<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">defaultParams</span>(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure></li>
<li>使用…rest 形式设置剩余形参，支持无限参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 剩余参数，转化成数组</span><br><span class="hljs-keyword">const</span> restParams = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">//1, 2, 3, 4, 5</span><br>&#125;<br><span class="hljs-title function_">restParams</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="6、展开数组"><a href="#6、展开数组" class="headerlink" title="6、展开数组"></a>6、展开数组</h3><ul>
<li>使用…将数组展开<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...arr)<br><span class="hljs-comment">// 等价于es5中以下写法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">console</span>, arr)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="7、箭头函数"><a href="#7、箭头函数" class="headerlink" title="7、箭头函数"></a>7、箭头函数</h3><h6 id="特性-amp-优势："><a href="#特性-amp-优势：" class="headerlink" title="特性&amp;优势："></a>特性&amp;优势：</h6><ul>
<li>1、简化了函数的写法</li>
<li>2、没有 this 机制，this 继承自上一个函数的上下文，如果上一层没有函数，则指向 window</li>
<li>3、作为异步回调函数时，可解决 this 指向问题</li>
</ul>
<h3 id="8、对象字面量增强"><a href="#8、对象字面量增强" class="headerlink" title="8、对象字面量增强"></a>8、对象字面量增强</h3><ul>
<li>同名属性可以省略 key:value 形式，直接 key，</li>
<li>函数可以省略 key：value 形式</li>
<li>可以直接 func(),</li>
<li>可以使用计算属性，比如：{[Math.random()]: value}</li>
</ul>
<h3 id="9、Object-assign-target1-target2-targetN-复制-x2F-合并对象"><a href="#9、Object-assign-target1-target2-targetN-复制-x2F-合并对象" class="headerlink" title="9、Object.assign(target1, target2, targetN)-复制&#x2F;合并对象"></a>9、Object.assign(target1, target2, targetN)-复制&#x2F;合并对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Object.assign(target1, target2, ...targetn)</span><br><span class="hljs-comment"> * 后面的属性向前面的属性合并</span><br><span class="hljs-comment"> * 如果target1是空对象，可以创建一个全新对象，而不是对象引用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> obj1 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>&#125;<br><span class="hljs-keyword">const</span> obj2 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> obj3 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj1)<br>obj3.<span class="hljs-property">a</span> = <span class="hljs-number">5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj3, obj2, obj1)<br></code></pre></td></tr></table></figure>

<h3 id="10、Object-is-value1-value2"><a href="#10、Object-is-value1-value2" class="headerlink" title="10、Object.is(value1, value2)"></a>10、Object.is(value1, value2)</h3><ul>
<li>作用：比较两个值是否相等</li>
<li>特性：<br>  没有隐式转换<br>  可以比较+0,-0、NaN<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>) <span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>)) <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>)) <span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="11、Proxy-object-handler"><a href="#11、Proxy-object-handler" class="headerlink" title="11、Proxy(object, handler)"></a>11、Proxy(object, handler)</h3><ul>
<li>作用：<br>  代理一个对象的所有，包括读写操作和各种操作的监听</li>
<li>用法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> P = &#123;<br>  <span class="hljs-attr">n</span>: <span class="hljs-string">&#x27;p&#x27;</span>,<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">19</span>,<br>&#125;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(P, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, property)<br>    <span class="hljs-keyword">return</span> property <span class="hljs-keyword">in</span> target ? target[property] : <span class="hljs-literal">null</span><br>  &#125;,<br>  <span class="hljs-title function_">defineProperty</span>(<span class="hljs-params">target, property, attrs</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, property, attrs)<br>    <span class="hljs-comment">//   throw new Error(&#x27;不允许修改&#x27;)</span><br>  &#125;,<br>  <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, property)<br>    <span class="hljs-keyword">delete</span> target[property]<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;<br>    target[property] = value<br>  &#125;,<br>&#125;)<br><br>proxy.<span class="hljs-property">c</span> = <span class="hljs-number">100</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;pp&#x27;</span>, P)<br></code></pre></td></tr></table></figure></li>
<li>与 Object.defineProperty  对比</li>
<li>优势：<br>  拥有很多 defineProperty 没有的属性方法<br>  对数组的监视更方便<br>  以非侵入的访视监管对象的读写</li>
</ul>
<h3 id="12-Reflect"><a href="#12-Reflect" class="headerlink" title="12.Reflect"></a>12.Reflect</h3><ul>
<li>作用：<br>  用于对对象的统一操作，集成 Object 相关的所有方法</li>
</ul>
<h3 id="13-Promise"><a href="#13-Promise" class="headerlink" title="13.Promise"></a>13.Promise</h3><ul>
<li>作用：解决异步编程中回调嵌套过深问题</li>
</ul>
<h3 id="14-class-amp-静态方法-amp-继承"><a href="#14-class-amp-静态方法-amp-继承" class="headerlink" title="14.class&amp;静态方法&amp;继承"></a>14.class&amp;静态方法&amp;继承</h3><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><ul>
<li>使用 class 关键字定义类<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>	<span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    	<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span> = props<br>  	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><ul>
<li>实例方法，需要实例化之后才能调用，this 指向实例</li>
<li>静态方法，用 static 修饰符修饰，可以直接通过类名调用，不需要实例化，this 不指向实例，而是指向当前类<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span> = props<br>  &#125;<br>  <span class="hljs-comment">// 实例方法</span><br>	<span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  <span class="hljs-comment">// 静态方法</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-comment">// 调用静态方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">run</span>()<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;props&#x27;</span>)<br><span class="hljs-comment">// 调用实例方法</span><br>person.<span class="hljs-title function_">eat</span>()<br></code></pre></td></tr></table></figure></li>
</ul>
<h6 id="继承：子类使用-extends-关键字实现继承，可以继承父类所有属性"><a href="#继承：子类使用-extends-关键字实现继承，可以继承父类所有属性" class="headerlink" title="继承：子类使用 extends 关键字实现继承，可以继承父类所有属性"></a>继承：子类使用 extends 关键字实现继承，可以继承父类所有属性</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>  &#125;<br>  <span class="hljs-title function_">printProps</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;student&#x27;</span>)<br>student.<span class="hljs-title function_">printProps</span>()<br></code></pre></td></tr></table></figure>

<h3 id="15-Set"><a href="#15-Set" class="headerlink" title="15.Set"></a>15.Set</h3><h6 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h6><ul>
<li>Set 是一种类似于数组的数据结构</li>
</ul>
<h6 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h6><ul>
<li>元素唯一性，不允许重复元素</li>
<li>使用 add 增加重复元素，将会被忽略</li>
</ul>
<h6 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h6><ul>
<li>数组去重</li>
<li>数据存储<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>) <span class="hljs-comment">//2</span><br><span class="hljs-keyword">const</span> newArr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr) <span class="hljs-comment">//[ 1, 3 ]</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="16-Map"><a href="#16-Map" class="headerlink" title="16.Map"></a>16.Map</h3><h6 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h6><ul>
<li>类似 Object，以 key、value 形式存储数据</li>
</ul>
<h6 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h6><ul>
<li>Map 键不会隐式转换成字符串，而是保持原有类型</li>
</ul>
<h6 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;map&#x27;</span>)<br>map.<span class="hljs-title function_">set</span>(obj, obj)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">//1</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    1 1</span><br><span class="hljs-comment">    name map</span><br><span class="hljs-comment">    &#123; &#x27;1&#x27;: 1, true: true, a: &#x27;a&#x27; &#125; &#123; &#x27;1&#x27;: 1, true: true, a: &#x27;a&#x27; &#125;</span><br><span class="hljs-comment">*/</span><br>map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, key</span>) =&gt;</span> &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, val)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="17-Symbol"><a href="#17-Symbol" class="headerlink" title="17.Symbol"></a>17.Symbol</h3><h6 id="说明：-2"><a href="#说明：-2" class="headerlink" title="说明："></a>说明：</h6><ul>
<li>JavaScript 第六种原始数据类型，用来定义一个唯一的变量</li>
</ul>
<h6 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h6><ul>
<li><p>创建唯一的变量，解决对象键名重复问题</p>
</li>
<li><p>为对象、类、函数等创建私有属性</p>
</li>
<li><p>修改对象的 toString 标签</p>
</li>
<li><p>为对象添加迭代器属性</p>
</li>
<li><p>如何获取对象的 symbol 属性？<br>  Object.getOwnPropertySymbols(object)</p>
</li>
<li><p>实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象属性重名问题；</span><br><span class="hljs-keyword">const</span> objSymbol = &#123;<br>  [<span class="hljs-title class_">Symbol</span>()]: <span class="hljs-number">1</span>,<br>  [<span class="hljs-title class_">Symbol</span>()]: <span class="hljs-number">2</span>,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objSymbol)<br><span class="hljs-comment">// 2、为对象、类、函数等创建私有属性</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-keyword">const</span> obj2 = &#123;<br>  [name]: <span class="hljs-string">&#x27;symbol&#x27;</span>,<br>  <span class="hljs-title function_">testPrivate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>[name])<br>  &#125;,<br>&#125;<br>obj2.<span class="hljs-title function_">testPrivate</span>()<br><span class="hljs-comment">// 定义toString标签；</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-title function_">toString</span>())<br>obj2[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>] = <span class="hljs-string">&#x27;xx&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">//[object xx]</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="18-for…of…"><a href="#18-for…of…" class="headerlink" title="18.for…of…"></a>18.for…of…</h3><h6 id="用途：-1"><a href="#用途：-1" class="headerlink" title="用途："></a>用途：</h6><ul>
<li>已统一的方式，遍历所有引用数据类型</li>
</ul>
<h6 id="特性：-1"><a href="#特性：-1" class="headerlink" title="特性："></a>特性：</h6><ul>
<li>可以随时使用 break 终止遍历，而 forEach 不行</li>
</ul>
<h6 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 基本用法</span><br><span class="hljs-comment">// 遍历数组</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-keyword">if</span> (item &gt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">break</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (item &gt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 遍历set</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;foo&#x27;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> set) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set for of&#x27;</span>, item)<br>&#125;<br><span class="hljs-comment">// 遍历map</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, val] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;for of map&#x27;</span>, key, val)<br>&#125;<br><span class="hljs-comment">//迭代对象</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaohui&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;10&#x27;</span>,<br>  <span class="hljs-attr">store</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  <span class="hljs-comment">// 实现可迭代的接口</span><br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> params = [<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>]<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> ret = &#123;<br>          <span class="hljs-attr">value</span>: params[index],<br>          <span class="hljs-attr">done</span>: index &gt;= params.<span class="hljs-property">length</span>,<br>        &#125;<br>        index++<br>        <span class="hljs-keyword">return</span> ret<br>      &#125;,<br>    &#125;<br>  &#125;,<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> obj) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj for of&#x27;</span>, item)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="19-迭代器模式"><a href="#19-迭代器模式" class="headerlink" title="19. 迭代器模式"></a>19. 迭代器模式</h3><h6 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h6><ul>
<li>通过 Symbol.interator 对外提供统一的接口，获取内部的数据</li>
</ul>
<h6 id="外部可以通过-for…of…去迭代内部的数据"><a href="#外部可以通过-for…of…去迭代内部的数据" class="headerlink" title="外部可以通过 for…of…去迭代内部的数据"></a>外部可以通过 for…of…去迭代内部的数据</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> tods = &#123;<br>  <span class="hljs-attr">life</span>: [<span class="hljs-string">&#x27;eat&#x27;</span>, <span class="hljs-string">&#x27;sleep&#x27;</span>],<br>  <span class="hljs-attr">learn</span>: [<span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;dart&#x27;</span>],<br>  <span class="hljs-comment">// 增加的任务</span><br>  <span class="hljs-attr">work</span>: [<span class="hljs-string">&#x27;sale&#x27;</span>, <span class="hljs-string">&#x27;customer&#x27;</span>],<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> all = []<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>      all.<span class="hljs-title function_">push</span>(...<span class="hljs-variable language_">this</span>[key])<br>    &#125;)<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> ret = &#123;<br>          <span class="hljs-attr">value</span>: all[index],<br>          <span class="hljs-attr">done</span>: index &gt;= all.<span class="hljs-property">length</span>,<br>        &#125;<br>        index++<br>        <span class="hljs-keyword">return</span> ret<br>      &#125;,<br>    &#125;<br>  &#125;,<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> tods) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="20、Generator函数"><a href="#20、Generator函数" class="headerlink" title="20、Generator函数"></a>20、Generator函数</h3><ul>
<li>函数前添加 *，生成一个生成器</li>
<li>一般配合 yield 关键字使用</li>
<li>最大特点，惰性执行，调 next 才会往下执行</li>
<li>主要用来解决异步回调过深的问题<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>)<br>	&#123;<br>		<span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>); <span class="hljs-comment">// undefined</span><br>		<span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>	&#125;<br>	<span class="hljs-keyword">let</span> ge=<span class="hljs-title function_">gen</span>() <span class="hljs-comment">//返回一个遍历器对象</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123;value: 1, done: false&#125;</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">//  &#123;value: 3, done: false&#125;</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">//  &#123;value: 4, done: true&#125;</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ge.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123;value: undefined , done: true&#125;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="21-includes-函数-es2016"><a href="#21-includes-函数-es2016" class="headerlink" title="21.includes 函数-es2016"></a>21.includes 函数-es2016</h3><ul>
<li>判断数组是否包含某个元素，包含 NaN，解决 indexOf 无法查找 NaN 问题<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  includes函数</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-title class_">NaN</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-title class_">NaN</span>)) <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-title class_">NaN</span>)) <span class="hljs-comment">//-1</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="22-运算符-es2016"><a href="#22-运算符-es2016" class="headerlink" title="22. 运算符-es2016"></a>22. 运算符-es2016</h3><ul>
<li>指数运算<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 指数运算符 **</span><br><span class="hljs-comment">// es5中2十次方</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>))<br><span class="hljs-comment">// es6中2十次方</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="23-values-函数-es2017"><a href="#23-values-函数-es2017" class="headerlink" title="23.values 函数-es2017"></a>23.values 函数-es2017</h3><ul>
<li>将对象的值以数组的形式返回<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>	<span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>	<span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>,<br>	<span class="hljs-attr">baz</span>: <span class="hljs-number">3</span>,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(obj)) <span class="hljs-comment">//[ 1, 2, 3 ]</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="24-entries-函数-es2017"><a href="#24-entries-函数-es2017" class="headerlink" title="24.entries 函数-es2017"></a>24.entries 函数-es2017</h3><ul>
<li>将对象以键值对二维数组返回，使之可以使用 for…of…遍历<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>	<span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>	<span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>,<br>	<span class="hljs-attr">baz</span>: <span class="hljs-number">3</span>,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj))<br><span class="hljs-keyword">const</span> entry = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> entry) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="25-Object-getOwnPropertyDescriptors-obj-es2017"><a href="#25-Object-getOwnPropertyDescriptors-obj-es2017" class="headerlink" title="25.Object.getOwnPropertyDescriptors(obj)-es2017"></a>25.Object.getOwnPropertyDescriptors(obj)-es2017</h3><ul>
<li>获取对象的描述信息</li>
<li>可以通过获得的描述信息，配合 Object.defineProperties 来完整复制对象，包含 get，set 方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// getOwnPropertyDescriptors</span><br><span class="hljs-comment">// 普通get方法</span><br><span class="hljs-keyword">const</span> objGet = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">getCount</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span><br>  &#125;,<br>&#125;<br><span class="hljs-comment">// assign方法会把getCount当做普通属性复制，从而getCount为3，修改bar不管用</span><br><span class="hljs-keyword">const</span> objGet1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, objGet)<br>objGet1.<span class="hljs-property">bar</span> = <span class="hljs-number">3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objGet1.<span class="hljs-property">getCount</span>) <span class="hljs-comment">//3</span><br><span class="hljs-comment">// descriptors</span><br><span class="hljs-keyword">const</span> descriptors = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(objGet)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;des&#x27;</span>, descriptors)<br><span class="hljs-comment">// 通过descriptors来复制对象，可以完整复制对象，包含get，set</span><br><span class="hljs-keyword">const</span> objGet2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(&#123;&#125;, descriptors)<br>objGet2.<span class="hljs-property">bar</span> = <span class="hljs-number">3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objGet2.<span class="hljs-property">getCount</span>) <span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="26-padStart-padEnd-函数-es2017"><a href="#26-padStart-padEnd-函数-es2017" class="headerlink" title="26.padStart, padEnd 函数-es2017"></a>26.padStart, padEnd 函数-es2017</h3><ul>
<li>在字符串前，或者后面追加指定字符串</li>
</ul>
<h6 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h6><ul>
<li>targetLenght: 填充后的目标长度</li>
<li>padString:填充的字符串</li>
</ul>
<h6 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h6><p>1、填充的字符串超过目标长度，会在规定长度时被截断<br>2、填充字符串太短会以空格填充<br>3、padString 未传值，以空格填充</p>
<h6 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h6><ul>
<li>一般用来对齐字符串输出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">	foo.................|1</span><br><span class="hljs-comment">	barbar..............|2</span><br><span class="hljs-comment">	bazbazbaz...........|3</span><br><span class="hljs-comment">*/</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key.padEnd(<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;.&#x27;</span>)&#125;</span><span class="hljs-subst">$&#123;value.toString().padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;|&#x27;</span>)&#125;</span>`</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>主要编程范式有三种：命令式编程、声明式编程、函数式编程</p>
<ul>
<li>简单来说，函数式编程就是把过程逻辑写成函数，定义好输入参数，只关心他的输出结果</li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>纯函数  就是一个函数的返回结果只依赖于它的参数，并且在执行过程中没有副作用，我们就把这个函数叫做纯函数。</li>
<li>高阶函数 就是以函数作为输入或者输出的函数被称为高阶函数</li>
<li>柯里化函数 柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程</li>
<li>组合与管道 组合函数，目的是将多个函数组合成一个函数</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>更好的管理状态：因为他的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况</li>
<li>更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用，这样的代码复用时，完全不需要考虑他的内部实现和外部影响</li>
<li>更优雅的组合：往大了说，网页是由各个组件组成的。往小了说，一个函数也可能由多个小函数组成的。更强的复用性，带来更强大的组合</li>
<li>隐性好处。减少代码量，提高维护性</li>
</ul>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为他往往对一个方法过度包装，从而产生上下文切换的性能开销</li>
<li>资源占用：在js中为了实现对象状态不可变，往往会创建新的对象，因此，他对垃圾回收所产生的压力远远超过其他编程方式</li>
<li>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作</li>
</ul>
<h2 id="cookie、localStorage和sessionStorage-三者之间有什么区别"><a href="#cookie、localStorage和sessionStorage-三者之间有什么区别" class="headerlink" title="cookie、localStorage和sessionStorage 三者之间有什么区别"></a>cookie、localStorage和sessionStorage 三者之间有什么区别</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效</li>
<li>localStorage：除非手动删除，否则将会永久保存</li>
<li>sessionStorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除</li>
</ul>
<h3 id="存放数据大小"><a href="#存放数据大小" class="headerlink" title="存放数据大小"></a>存放数据大小</h3><ul>
<li>cookie：4KB左右</li>
<li>localStorage和sessionStorage：可以保存5MB的信息</li>
</ul>
<h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><ul>
<li>cookie：需要程序员自己封装，原生的cookieAPI不友好</li>
<li>localStorage和sessionStorage：原生的API可以接受，亦可再次封装来对object和array有更好的支持</li>
</ul>
<h2 id="浏览器有哪几种缓存，各种缓存的优先级是什么样的？"><a href="#浏览器有哪几种缓存，各种缓存的优先级是什么样的？" class="headerlink" title="浏览器有哪几种缓存，各种缓存的优先级是什么样的？"></a>浏览器有哪几种缓存，各种缓存的优先级是什么样的？</h2><h3 id="强制缓存："><a href="#强制缓存：" class="headerlink" title="强制缓存："></a>强制缓存：</h3><p>1、浏览器发送HTTP请求<br>2、服务器返回HTTP响应（响应头中的缓存标识：cache-Control(http1.1)、Expires(http1.0)）<br>    - Cache-Control：max-age&#x3D;300，响应内容浏览器本地缓存300秒，缓存时间内再次加载资源，就会命中强缓存<br>    - Expires：Wed,26 Jul 2023 15:50:40 GMT，失效具体时间（2023年7月26日星期三15:50:40 GMT）,缓存时间内再次加载资源，就会命中强缓存<br>    - 同时设置Cache-Control和Expires，Cache-Control优先级更高<br>3、浏览器再次发送相同HTTP请求<br>4、不会再进过服务器，直接从浏览器本地缓存拿出进行返回</p>
<h3 id="协商缓存："><a href="#协商缓存：" class="headerlink" title="协商缓存："></a>协商缓存：</h3><p>协商缓存步骤如下：（缓存标识对：Etag&#x2F;If-None-Match(http1.1)、Last-Modified&#x2F;If-Modified-Since(http1.0)）<br>1、浏览器发起HTTP请求<br>2、服务器返回HTTP响应（响应头中的缓存标识：Etag、Last-Modified）<br>    - Etag：”64d452af-70b8”,内容的hash值，只有内容改变了，hash才会变化<br>    - Last-Modified:Thu, 10 Aug 2023 02:59:59 GMT，修改时间，哪怕内容没有变化，重新保存可能都会导致修改时间变化<br>    - 同时设置Etag和Last-Modified，Etag优先级更高<br>3、浏览器再次发送相同的HTTP请求（请求头中的缓存标识If-None-Match(http1.1)、If-Modified-Since(http1.0)）<br>4、服务器会检查Etag &#x3D;&#x3D;&#x3D; If-None-Match或者Last-Modified &#x3D;&#x3D;&#x3D; If-Modified-Since是否相等，相等就命中缓存，服务端返回304，从本地缓存中取即可，否则未命中缓存，返回最新的数据和响应头中的缓存标识</p>
<h3 id="Service-Worker-缓存："><a href="#Service-Worker-缓存：" class="headerlink" title="Service Worker 缓存："></a>Service Worker 缓存：</h3><p>Service Worker 是一种特殊的 JS 脚本，可以拦截网络请求并返回缓存的响应，以实现离线访问和更快的加载速度等功能。</p>
<h3 id="Web-Storage-缓存："><a href="#Web-Storage-缓存：" class="headerlink" title="Web Storage 缓存："></a>Web Storage 缓存：</h3><p>包括 localStorage 和 sessionStorage。localStorage 用于存储用户在网站上的永久性数据，而 sessionStorage 则用于存储用户会话过程中的临时数据。</p>
<h3 id="这些缓存的优先级如下："><a href="#这些缓存的优先级如下：" class="headerlink" title="这些缓存的优先级如下："></a>这些缓存的优先级如下：</h3><p>Service Worker 缓存：由于其可以完全控制网络请求，因此具有最高的优先级，即使是强制缓存也可以被它所覆盖。<br>强制缓存：如果存在强制缓存，并且缓存没有过期，则直接使用缓存，不需要向服务器发送请求。<br>协商缓存：如果强制缓存未命中，但协商缓存可用，则会向服务器发送条件请求，询问资源是否更新。如果服务器返回 304 Not Modified 响应，则直接使用缓存。<br>Web Storage 缓存：Web Storage 缓存的优先级最低，只有在网络不可用或者其他缓存都未命中时才会生效。</p>
<h2 id="项目首屏提速"><a href="#项目首屏提速" class="headerlink" title="项目首屏提速"></a>项目首屏提速</h2><ul>
<li>大致可以分两种</li>
</ul>
<h3 id="用户感知提速"><a href="#用户感知提速" class="headerlink" title="用户感知提速"></a>用户感知提速</h3><ul>
<li>因为用户 在很多情况下对于速度的感知是非常主观的，所以说呢，我们可以通过一些加载动画来拖慢用户的这种感知</li>
</ul>
<h3 id="技术加载提速"><a href="#技术加载提速" class="headerlink" title="技术加载提速"></a>技术加载提速</h3><ul>
<li><p>我们可以在服务端通过prerender进行一个预渲染，然后以SSR的形式，完成首页的一个服务端渲染，然后把我们后续的渲染交给CSR客户端去进行渲染，这样的话我们就组成了一种同构渲染的方式，来完成一个渲染的提速</p>
</li>
<li><p>还有一些静态资源的渲染，比如说图片的加载，比如说数据的加载，我们可以借助intersectionObserver来完成一些懒加载的处理</p>
</li>
</ul>
<h2 id="css元素隐藏"><a href="#css元素隐藏" class="headerlink" title="css元素隐藏"></a>css元素隐藏</h2><ul>
<li>1、display:none 渲染树不会渲染对象</li>
<li>2、visibility(v 死 biu 了 踢):hidden 元素在页面内仍占据空间，但是不会响应绑定的监听事件</li>
<li>3、opacity(哦 怕 死 踢):0 元素在页面中仍占据空间 并且能够响应元素绑定的监听事件</li>
<li>4、position:absolute 通过使用绝对定位将元素移除到可视化区域外，来隐藏元素</li>
<li>5、z-index:-9999 使其他元素覆盖给元素</li>
<li>6、transform:scale(si 给 o)(0,0) 将元素缩放为0 元素仍在页面中占据位置 但是不会响应绑定的监听事件</li>
</ul>
<h2 id="css元素居中"><a href="#css元素居中" class="headerlink" title="css元素居中"></a>css元素居中</h2><ul>
<li><p>flex布局设置居中<br>  给容器设置：<br>  display: flex;写在父元素上这就是定义了一个伸缩容器<br>  justify-content 主轴对齐方式，默认是横轴<br>  align-items 纵轴对齐方式，默认是纵轴</p>
</li>
<li><p>绝对定位设置居中<br>  使用绝对定位的方式实现水平垂直居中。<br>  容器设置position: relative。<br>  子元素设置<br>      position:absolute;<br>      left:50%;<br>      top:50%;<br>      transform:translate(-50%,-50%);</p>
</li>
<li><p>绝对定位设置居中<br>  使用绝对定位的方式实现水平垂直居中。<br>  容器设置position: relative。<br>  子元素设置<br>      position:absolute;<br>      width:300px;<br>      height:300px;<br>      margin-left:-150px &#x2F;&#x2F; 盒子宽的一半<br>      margin-top:-150px &#x2F;&#x2F; 盒子高的一半</p>
</li>
<li><p>还有一种奇葩的方法<br>  这个奇葩方式和使用绝对定位相似，<br>  容器设置position: relative。<br>  子元素设置<br>      position: absolute;<br>      设置固定宽度和高度<br>      top、left、bottom、right都设置为0;<br>      margin设置为auto；<br>      也能实现垂直水平居中。</p>
</li>
</ul>
<h2 id="em和rem的区别"><a href="#em和rem的区别" class="headerlink" title="em和rem的区别"></a>em和rem的区别</h2><h6 id="em"><a href="#em" class="headerlink" title="em"></a>em</h6><ul>
<li>是一个相对单位，相对于当前父级文本的font-size，如果当前文字的字体尺寸没有设置，则相对于浏览器的默认字体尺寸，即1em&#x3D;16px<br>  特点：<br>  1、em的值并不是固定的<br>  2、em会继承父元素的字体大小</li>
</ul>
<h6 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h6><ul>
<li>是相对单位，是相对HTML根元素，比如HTML标签设置font-size：100px；那么1rem就相当于100px<br>  特点：<br>  1、rem为元素设定字体大小的时候，是相对于根元素进行计算的<br>  2、当我改变根元素下的字体大小时，下面的大小都会改变<br>  3、通过rem既可以做的只修改根元素就可以成比例的调整所以字体，又可以避免字体大小逐层复合的连锁反应</li>
</ul>
<h2 id="HTTP1-0和HTTP2-0的区别"><a href="#HTTP1-0和HTTP2-0的区别" class="headerlink" title="HTTP1.0和HTTP2.0的区别"></a>HTTP1.0和HTTP2.0的区别</h2><h6 id="1、连接复用"><a href="#1、连接复用" class="headerlink" title="1、连接复用"></a>1、连接复用</h6><ul>
<li>HTTP1.0：每个HTTP请求都需要建立一个新的TCP连接，请求结束后立即关闭连接，这样的方式会导致每个请求都需要重新建立连接，增加了延迟和开销</li>
<li>HTTP2.0：引入了多路复用技术，允许在同一个TCP连接上发送多个请求和响应，避免了建立和关闭多个连接的开销，提高了性能和效率</li>
</ul>
<h6 id="2、请求-响应方式"><a href="#2、请求-响应方式" class="headerlink" title="2、请求-响应方式"></a>2、请求-响应方式</h6><ul>
<li>HTTP1.0：采用的是单向请求-响应模式，即每个请求只能对应一个响应，请求和响应是一一对应的</li>
<li>HTTP2.0：引入了Server Push机制，服务器可以在客户端请求之前主动推送相关资源，避免了客户端重复请求的等待事件，提高了页面加载速度</li>
</ul>
<h6 id="3、头部压缩"><a href="#3、头部压缩" class="headerlink" title="3、头部压缩"></a>3、头部压缩</h6><ul>
<li>HTTP1.0：每个请求和响应的头部都包含大量的重复信息，造成了较大的网络传输开销</li>
<li>HTTP2.0：使用HPACK算法对头部进行压缩，减少了头部的大小，降低了网络传输开销</li>
</ul>
<h6 id="4、二进制协议"><a href="#4、二进制协议" class="headerlink" title="4、二进制协议"></a>4、二进制协议</h6><ul>
<li>HTTP1.0：采用文本形式进行数据传输，易于阅读和调试，但是传输效率较低</li>
<li>HTTP2.0：采用二进制格式传输数据，减少了解析的复杂性，提高了传输效率</li>
</ul>
<h6 id="5、流控制和优先级"><a href="#5、流控制和优先级" class="headerlink" title="5、流控制和优先级"></a>5、流控制和优先级</h6><ul>
<li>HTTP1.0：没有流控制和优先级的概念，所有请求头都是按照发生的顺序进行处理</li>
<li>HTTP2.0：引入了流控制和优先级的机制，可以根据需求对请求进行优先级排序和流量控制，确保重要请求的及时处理</li>
</ul>
<h6 id="6、长连接支持"><a href="#6、长连接支持" class="headerlink" title="6、长连接支持"></a>6、长连接支持</h6><ul>
<li>HTTP1.0：基本都是短连接，每个请求响应完成之后立即关闭连接</li>
<li>HTTP2.0：支持长连接，即一个TCP连接可以承载多个请求和响应，减少连接的建立和关闭次数，提高了性能</li>
</ul>
<h2 id="（DFS）深度优先搜索算法"><a href="#（DFS）深度优先搜索算法" class="headerlink" title="（DFS）深度优先搜索算法"></a>（DFS）深度优先搜索算法</h2><ul>
<li>其过程为沿着每一个可能的路径向下进行搜索，直到不能再深入为止，并且每一个节点只能访问一次。</li>
</ul>
<h2 id="BFS（宽度优先算法）"><a href="#BFS（宽度优先算法）" class="headerlink" title="BFS（宽度优先算法）"></a>BFS（宽度优先算法）</h2><ul>
<li>它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。简单来说，bfs好像是一个耳听六路眼观八方的人</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>原理：<br>  相邻的数据进行两两比较，小数放在前面，大数放在后面，这样一趟下来，最小的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成。</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>原理：<br>  选择数组中的一个值作为基准，将数组中小于该值的数置于该数之前，大于该值的数置于该数之后，接着对该数前后的两个数组进行重复操作直至排序完成。</li>
</ul>
<h2 id="JavaScript中常见的数据结构"><a href="#JavaScript中常见的数据结构" class="headerlink" title="JavaScript中常见的数据结构"></a>JavaScript中常见的数据结构</h2><h6 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h6><ul>
<li>队列是一个先进先出的数据结构，一般JavaScript中采用队列解决问题时会用到<br>  入队push ()：在数组的尾部添加元素<br>  出队shift ()：移除数组中第一个元素<br>  queue (0) ：取数组的第一个元素<br>  isEmpty ()：确定队列是否为空<br>  size ()：获取队列中元素的数量</li>
</ul>
<h6 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h6><ul>
<li>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进⬇后出⬆的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。</li>
</ul>
<p>JavaScript中没有栈，但是可以用Array实现栈的功能。<br>栈中数组长度减一即为栈尾元素，也就是最后进入的那个元素，最先出去的那个元素<br>JavaScript中对栈的操作一般会使用到<br>    push()方法，将元素压入栈顶<br>    pop()方法，从栈顶弹出（删除）元素，并返回该元素<br>    peek()方法，返回栈顶元素，不删除<br>    clear()方法，清空栈<br>    length拿到栈中元素数量</p>
<h6 id="Linked-List-链表"><a href="#Linked-List-链表" class="headerlink" title="Linked List 链表"></a>Linked List 链表</h6><ul>
<li>链表是由多个元素组成的列表，链表中的元素储存不连续，用next指针连接在一起。</li>
<li>数组：增删非数组元素需要移动元素</li>
<li>链表：增删非首尾元素不需要移动元素只需要更改next的指向即可</li>
<li>链表是一个链式数据结构，每个节点由两个信息组成：节点的数据和指向下一个节点的指针。链表和传统数组都是线性数据结构，具有序列化的存储方式。</li>
<li>JavaScript中没有链表，但是可以用object来模拟链表</li>
</ul>
<h6 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h6><ul>
<li>集合：一种无序且唯一的数据结构，集合区别队列、栈、链表最大的区别就是元素不能重复</li>
<li>JavaScript中ES6中新增了集合这种数据结构，可以通过实例化Set对象来创建集合const set &#x3D; new Set()</li>
</ul>
<h6 id="树"><a href="#树" class="headerlink" title="树"></a>树</h6><p>前端🎄树结构还是比较常见的，例如级联选择、层级目录等都是树形结构。<br>javascript中没有树这个数据结构，但是一般用object和array来模拟树。</p>
<ul>
<li>树的常用遍历方式<br>  1、深度优先遍历<br>  2、广度优先遍历</li>
</ul>
<h6 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h6><ul>
<li><p>叉树是n(n&gt;&#x3D;0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成</p>
</li>
<li><p>树的每个节点最多只能有两个子节点</p>
</li>
<li><p>js中自然也没有二叉树这个数据结构，一般还是用object对象来模拟二叉树</p>
</li>
<li><p>二叉树遍历（递归）<br>  （1）前序遍历<br>  DLR：根节点——左子树——右子树<br>  每次遍历到一个节点都重复一次前序遍历<br>  （2）中序遍历<br>  LDR：左子树——根节点——右子树<br>  每次遍历到一个节点都重复一次中序遍历<br>  （3）后序遍历<br>  LRD：左子树——右子树——根节点<br>  每次遍历到一个节点都重复一次后序遍历<br>  注意：<br>  前序遍历第一个为根节点<br>  中序遍历根节点左边为左子树，右边为右子树<br>  后序遍历最后一个为根节点</p>
</li>
</ul>
<h6 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h6><ul>
<li>堆是一种特殊的完全二叉树</li>
<li>所有的节点都大于等于（最大堆）或者小于等于（最小堆）他的子节点</li>
</ul>
<h2 id="es6中map和object的区别是什么"><a href="#es6中map和object的区别是什么" class="headerlink" title="es6中map和object的区别是什么"></a>es6中map和object的区别是什么</h2><ul>
<li>1、Map的键可以是任意值，而Object的键必须是一个String或是Symbol。</li>
<li>2、Map中的key是有序的，而Object的键是无序的。</li>
<li>3、Map的键值对个数可以轻易地通过size属性获取，而Object的键值对个数只能手动计算。</li>
<li>4、Map可以直接被迭代，而Object不可以直接被迭代。</li>
<li>5、Map在频繁增删键值对的场景下表现更好，而Object的效率比较差。</li>
</ul>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Vue的最大优势是什么"><a href="#Vue的最大优势是什么" class="headerlink" title="Vue的最大优势是什么?"></a>Vue的最大优势是什么?</h2><ul>
<li>比较轻量，中国人自己写的框架，文档易读（这里比较轻松，拿出平时和朋友聊天的语气）<ul>
<li>双向数据绑定,</li>
<li>数据驱动视图,</li>
<li>组件化开发</li>
<li>数据和视图分离</li>
<li>单页面应用可以实现页面数据局部刷新</li>
</ul>
</li>
</ul>
<h2 id="MVVM和MVC区别是什么"><a href="#MVVM和MVC区别是什么" class="headerlink" title="MVVM和MVC区别是什么?"></a>MVVM和MVC区别是什么?</h2><h3 id="MVC-：-传统的设计模式。"><a href="#MVC-：-传统的设计模式。" class="headerlink" title="MVC ： 传统的设计模式。"></a>MVC ： 传统的设计模式。</h3><ul>
<li>设计模式： 一套广泛被使用的开发方式<br>  M： model 模型<br>  模型：就是数据的意思<br>  V ： view视图<br>  视图：就是页面的意思<br>  C：controller控制器<br>  控制器：在这里写js业务逻辑，把数据M 渲染到 视图 V （有点类似于我们之前学习的，把数据渲染到页面）</li>
</ul>
<h3 id="MVVM：-vue所使用的设计模式"><a href="#MVVM：-vue所使用的设计模式" class="headerlink" title="MVVM： vue所使用的设计模式"></a>MVVM： vue所使用的设计模式</h3><pre><code>M： model数据模型 (data里定义)
V： view视图 （页面标签）
VM： ViewModel视图模型 (vue.js源码)
</code></pre>
<ul>
<li><p>MVVM通过数据双向绑定让数据自动地双向同步 不再需要操作DOM<br>  V （修改视图） -&gt; M（数据自动同步）<br>  M（修改数据） -&gt; V （视图自动同步）</p>
</li>
<li><p>设计模式: 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。(代码分层, 架构设计)</p>
</li>
</ul>
<h6 id="1-在vue中，不推荐直接手动操作DOM！！！"><a href="#1-在vue中，不推荐直接手动操作DOM！！！" class="headerlink" title="1. 在vue中，不推荐直接手动操作DOM！！！"></a>1. 在vue中，不推荐直接手动操作DOM！！！</h6><h6 id="2-在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！-思想转变"><a href="#2-在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！-思想转变" class="headerlink" title="2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！(思想转变)"></a>2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！(思想转变)</h6><h2 id="vue第一次加载页面"><a href="#vue第一次加载页面" class="headerlink" title="vue第一次加载页面"></a>vue第一次加载页面</h2><p>1、创建vue实例<br>2、在创建Vue实例的时候，执行了init()初始化，在init过程中先调用了beforeCreate钩子函数；<br>3、同时监听data数据，初始化vue内部事件，进行属性和方法的计算<br>4、模板开始编译，把vue里面的数据和语法编译成HTML</p>
<p>当页面第一次加载时会触发 beforeCreate, created, beforeMount, mounted</p>
<h2 id="Vue常用修饰符有哪些"><a href="#Vue常用修饰符有哪些" class="headerlink" title="Vue常用修饰符有哪些?"></a>Vue常用修饰符有哪些?</h2><p>.prevent: 提交事件不再重载页面；<br>.stop: 阻止单击事件冒泡；<br>.once: 只执行一次这个事件<br>.enter:监听键盘enter键</p>
<h2 id="对Vue渐进式的理解"><a href="#对Vue渐进式的理解" class="headerlink" title="对Vue渐进式的理解"></a>对Vue渐进式的理解</h2><pre><code>- 主张最少,
- 自底向上,
- 增量开发,
- 组件集合,
- 便于复用
</code></pre>
<ul>
<li>个人见解<br>  使用模块化规范，实现自助餐式开发，用什么导什么。 最大程度上节省资源。</li>
</ul>
<h2 id="vue-生命周期"><a href="#vue-生命周期" class="headerlink" title="vue 生命周期"></a>vue 生命周期</h2><p>什么是vue生命周期和生命周期钩子函数？<br>beforeCreated：在实例初始化之后，el 和 data 并未初始化<br>（这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到）<br>created:完成了 data 数据的初始化，el没有<br>（这个时候可以操作vue实例中的数据和各种方法，但是还不能对”dom”节点进行操作）<br>beforeMount：完成了 el 和 data 初始化 &#x2F;&#x2F;这里的el是虚拟的dom；<br>mounted ：完成挂载，在这发起后端请求，拿回数据，配合路由钩子做一些事情<br>（挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行）<br>beforeUpdate：是指view层数据变化前，不是data中的数据改变前触发；<br>update：是指view层的数据变化之后，<br>beforeDestroy： 你确认删除XX吗？<br>destroyed ：当前组件已被删除，清空相关内容<br>A、什么是vue生命周期？<br>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程。<br>B、vue生命周期的作用是什么？<br>它的生命周期有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑。<br>C、vue生命周期总共有几个阶段？<br>它可以总共分为8个阶段：创建前&#x2F;后, 载入前&#x2F;后,更新前&#x2F;后,销毁前&#x2F;销毁后<br>D、第一次页面加载会触发哪几个钩子？<br>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子<br>E、DOM 渲染在 哪个周期中就已经完成？<br>DOM 渲染在 mounted 中就已经完成了。<br>F、简单描述每个周期具体适合哪些场景？<br>生命周期钩子的一些使用方法： beforeCreate : 可以在这加个loading事件，<br>在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，<br>异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，</p>
<h2 id="说出至少4个Vue指令及作用"><a href="#说出至少4个Vue指令及作用" class="headerlink" title="说出至少4个Vue指令及作用"></a>说出至少4个Vue指令及作用</h2><ul>
<li>v-on 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在methods里面</li>
<li>v-bind 动态绑定 作用： 及时对页面的数据进行更改, 可以简写成:分号</li>
<li>v-slot: 缩写为#, 组件插槽</li>
<li>v-for 根据数组的个数, 循环数组元素的同时还生成所在的标签</li>
<li>v-show 显示内容</li>
<li>v-if 显示与隐藏</li>
<li>v-else 必须和v-if连用 不能单独使用 否则报错</li>
<li>v-text 解析文本</li>
<li>v-html 解析html标签</li>
</ul>
<h2 id="为什么避免v-for和v-if在一起使用"><a href="#为什么避免v-for和v-if在一起使用" class="headerlink" title="为什么避免v-for和v-if在一起使用"></a>为什么避免v-for和v-if在一起使用</h2><p>Vue 处理指令时，v-for 比 v-if 具有更高的优先级, 虽然用起来也没报错好使, 但是性能不高, 如果你有5个元素被v-for循环, v-if也会分别执行5次.</p>
<h2 id="v-if与v-show区别逐字稿"><a href="#v-if与v-show区别逐字稿" class="headerlink" title="v-if与v-show区别逐字稿"></a>v-if与v-show区别逐字稿</h2><p>面试官你好，我是这么理解v-if和v-show的。 v-if本质其实是动态的创建 或者 删除元素节点。一般不用频繁切换, 要么显示, 要么隐藏的情况, 我都会用 v-if。因为v-if 是惰性的, 如果初始值为 false, 那么这些元素就直接不创建了, 这样就可以节省一些初始渲染开销。v-show本质是在控制元素的 css 样式,display: none;，一般元素需要频繁的切换显示隐藏, 用 v-show。因为v-if在频繁切换会大量的创建和删除元素, 消耗性能。</p>
<h2 id="Vue中key值作用"><a href="#Vue中key值作用" class="headerlink" title="Vue中key值作用"></a>Vue中key值作用</h2><ul>
<li>1.vue在渲染的时候,会 先把 新DOM 与 旧DOM 进行对比， 如果dom结构一致，则vue会复用旧的dom。 （此时可能造成数据渲染异常）</li>
<li>2.使用key可以给dom添加一个 唯一标识符，让vue强制更新dom</li>
</ul>
<h6 id="面试官你好-我是这么理解key值的-key值的主要作用是给元素添加一个唯一标识符-用于提高vue渲染性能-当data发生变化的时候-vue会使用diff算法来对比新旧虚拟DOM-如果key值相同-才会考虑复用元素-如果key值不同-则会强制更新元素-一般通过给元素key设置为id-来保证vue更新数据的时候可以最大限度复用相同的key值的元素"><a href="#面试官你好-我是这么理解key值的-key值的主要作用是给元素添加一个唯一标识符-用于提高vue渲染性能-当data发生变化的时候-vue会使用diff算法来对比新旧虚拟DOM-如果key值相同-才会考虑复用元素-如果key值不同-则会强制更新元素-一般通过给元素key设置为id-来保证vue更新数据的时候可以最大限度复用相同的key值的元素" class="headerlink" title="面试官你好,我是这么理解key值的,key值的主要作用是给元素添加一个唯一标识符,用于提高vue渲染性能,当data发生变化的时候,vue会使用diff算法来对比新旧虚拟DOM.如果key值相同,才会考虑复用元素.如果key值不同,则会强制更新元素.一般通过给元素key设置为id,来保证vue更新数据的时候可以最大限度复用相同的key值的元素."></a>面试官你好,我是这么理解key值的,key值的主要作用是给元素添加一个唯一标识符,用于提高vue渲染性能,当data发生变化的时候,vue会使用diff算法来对比新旧虚拟DOM.如果key值相同,才会考虑复用元素.如果key值不同,则会强制更新元素.一般通过给元素key设置为id,来保证vue更新数据的时候可以最大限度复用相同的key值的元素.</h6><h2 id="v-for指令使用key值几种情况"><a href="#v-for指令使用key值几种情况" class="headerlink" title="v-for指令使用key值几种情况"></a>v-for指令使用key值几种情况</h2><p>[v-for指令使用key值几种情况逐字稿]</p>
<ol>
<li>没有key值(默认是下标) :   不复用，就地更新</li>
<li>key值为下标(相当于没设置) :  不复用，就地更新</li>
<li>key值是id   :  复用相同的key，更新不同的key<br>总结 ： key值优先设置id, 没有id就用下标</li>
</ol>
<h2 id="Vue中-key作用-为什么不能用索引"><a href="#Vue中-key作用-为什么不能用索引" class="headerlink" title="Vue中:key作用, 为什么不能用索引"></a>Vue中:key作用, 为什么不能用索引</h2><ul>
<li>:key是给v-for循环生成标签颁发唯一标识的, 用于性能的优化</li>
<li>因为v-for数据项的顺序改变，Vue 也不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素</li>
</ul>
<h2 id="v-model的作用及原理"><a href="#v-model的作用及原理" class="headerlink" title="v-model的作用及原理"></a>v-model的作用及原理</h2><ul>
<li>作用<ul>
<li>数据双向绑定指令，专门给表单元素</li>
</ul>
</li>
<li>原理<ul>
<li>v-model是一个语法糖，他背后本质上是包含两个操作<ul>
<li>v-bind绑定一个value属性</li>
<li>v-on指令给当前元素绑定input事件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">v-model实现原理的例子<br>&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;message&quot;</span>&gt;<br><span class="hljs-comment">// 等于</span><br><span class="hljs-comment">// @input input框的事件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;message&quot;</span>  @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;message = $event.target.value&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Vue中有时候数组会更新页面，有时候不更新，这是为什么"><a href="#Vue中有时候数组会更新页面，有时候不更新，这是为什么" class="headerlink" title="Vue中有时候数组会更新页面，有时候不更新，这是为什么?"></a>Vue中有时候数组会更新页面，有时候不更新，这是为什么?</h2><ul>
<li>因为vue内部只能监测到数组顺序&#x2F;位置的改变&#x2F;数量的改变, 但是值被重新赋予监测不到变更, 可以用 Vue.set() &#x2F; vm.$set()</li>
</ul>
<h2 id="请说下封装-vue-组件的过程"><a href="#请说下封装-vue-组件的过程" class="headerlink" title="请说下封装 vue 组件的过程"></a>请说下封装 vue 组件的过程</h2><ul>
<li>有复用的地方就有封装<br>1.先分析需求：确定业务需求，把页面中可以复用的结构，样式以及功能<br>2.具体步骤：Vue.component 或者在new Vue配置项components中, 定义组件名, 可以在props中接受给组件传的参数和值，子组件修改好数据后，想把数据传递给父组件。可以采用$emit方法</li>
</ul>
<h2 id="vue组件传值"><a href="#vue组件传值" class="headerlink" title="vue组件传值"></a>vue组件传值</h2><ul>
<li>父传子<br>  1.子组件props定义变量<br>  2.父组件在使用子组件时通过行内属性给props变量传值<br>  特点：单向数据流</li>
<li>子传父<br>  1.子组件：$emit触发父的事件<br>  2.父在使用组件用@自定义事件名&#x3D;父的方法 (子把值带出来)<br>  特点：事件监听</li>
<li>非父子组件<br>  vuex<br>  事件总线(Event Bus)<br>  事件总线是一种通过中央事件管理器来实现组件通信的方式。在Vue中，可以使用Vue实例作为事件总线来发送和接收事件。</li>
</ul>
<h2 id="Vue-组件-data-为什么必须是函数"><a href="#Vue-组件-data-为什么必须是函数" class="headerlink" title="Vue 组件 data 为什么必须是函数"></a>Vue 组件 data 为什么必须是函数</h2><pre><code>因为组件是需要在多个地方使用的
    如果data是一个对象，对象是引用类型。 一旦某一个地方修改，就会全部修改
    data是一个函数，每一次复用组件的时候就会从这个函数返回一个新的对象。 这样组件在复用的时候就可以做到数据互不干扰。
</code></pre>
<h2 id="讲一下组件的命名规范"><a href="#讲一下组件的命名规范" class="headerlink" title="讲一下组件的命名规范"></a>讲一下组件的命名规范</h2><ul>
<li>一种是使用链式命名”my-component”，一种是使用大驼峰命名”MyComponent”，</li>
<li>因为要遵循W3C规范中的自定义组件名 (字母全小写且必须包含一个连字符)，避免和当前以及未来的 HTML 元素相冲突</li>
</ul>
<h2 id="scoped作用与原理"><a href="#scoped作用与原理" class="headerlink" title="scoped作用与原理"></a>scoped作用与原理</h2><p>作用：组件css作用域，避免子组件内部的css样式被父组件覆盖<br>默认情况下，如果子组件和父组件css选择器权重相同，优先加载父组件css样式<br>原理：给元素添加一个自定义属性 v-data-xxxxx</p>
<p>一针见血答案： 通过属性选择题来提高css权重值</p>
<h2 id="Vue-的-nextTick-的原理是什么"><a href="#Vue-的-nextTick-的原理是什么" class="headerlink" title="Vue 的 nextTick 的原理是什么?"></a>Vue 的 nextTick 的原理是什么?</h2><p>为什么需要 nextTick<br>    Vue 是异步修改 DOM 的并且不鼓励开发者直接接触 DOM，但有时候业务需要必须对数据更改–刷新后的 DOM 做相应的处理，这时候就可以使用 Vue.nextTick(callback)这个 api 了。<br>最终答案：<br>    nextTick 的原理是 vue 通过异步队列控制 DOM 更新<br>    nextTick底层是promise，所以是微任务。这个一定要知道</p>
<h2 id="子组件修改父组件的数据"><a href="#子组件修改父组件的数据" class="headerlink" title="子组件修改父组件的数据"></a>子组件修改父组件的数据</h2><p>子组件通过this.$emit(“自定义事件名称a”,传递的参数)<br>父组件通过子组件标签接收<br>&lt;组件标签 @自定义事件名称a&#x3D;”自定义名称b”&#x2F;&gt;<br>methods：{<br>    自定义名称b(v){<br>        console.log(v)<br>    }<br>}</p>
<ul>
<li>$eventBus 灵活<ul>
<li>this.$emit(‘事件名’,传递的参数)</li>
<li>this.$on(‘事件名’,接收的回调)</li>
</ul>
</li>
<li>vuex 也算是一种</li>
</ul>
<h2 id="vue事件冒泡"><a href="#vue事件冒泡" class="headerlink" title="vue事件冒泡"></a>vue事件冒泡</h2><p>当一个父元素div1 包裹着一个子元素div2 同时都有点击事件，我们点击子元素，不想触发父元素的事件，我们可以采用阻止事件冒泡解决<br>.stop 清除事件冒泡<br>.prevent 阻止默认行为<br>.once 只触发一次<br>.self 只允许元素自己触发</p>
<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p> 简单说就是用户更改数据(Data)时，视图可以自动刷新，页面UI能够响应数据变化。<br>原理：在生成vue实例时，为对传入的data进行遍历，使用Object.defineProperty把这些属性转为getter&#x2F;setter<br>每个vue实例都有一个watcher实例，它会在实例渲染时记录这些属性，并在setter触发时通知render重新渲染。</p>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html">更高级的组件复用方式。 接收dom片段或内容，加工处理后返回显示。<br>	匿名插槽(默认插槽)<br>		写在插槽组件中的内容或者template没有命名都会视为匿名插槽，相当于#default<br>		<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>我是匿名插槽接收的数据<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br>		b组件<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">solt</span>&gt;</span>我要接收匿名插槽数据的<span class="hljs-tag">&lt;/<span class="hljs-name">solt</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>	具名插槽<br>		插槽组件中在template模板上使用v-slot命令绑定一个名称<br>		插槽组件使用内置组件slot，用name属性去匹配v-slot名称<br>		<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;aa&#x27;</span>&gt;</span>要传的内容<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br>		b插槽组件内：<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;aa&#x27;</span>&gt;</span>要传的内容会在这里显示<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>	作用域插槽<br>		父组件中的插槽模板template里， 其作用域属于插槽组件。<br>			父传子：父组件使用v-bind向插槽组件进行传参<br>			子传父：插槽组件在slot组件上使用v-bind反向传参， 父组件使用v-slot=&#x27;参数&#x27;接收数据<br>			子集<span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>			父级：<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>&#123;&#123;user.data.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>什么时候使用插槽<br>当子组件被复用时，需要在特定的区域展示不同的定制化的内容。</li>
<li>插槽的使用场景</li>
</ul>
<h2 id="v-show-v-if"><a href="#v-show-v-if" class="headerlink" title="v-show  v-if"></a>v-show  v-if</h2><p>共同点: v-if 和 v-show 都是动态显示DOM元素。<br>区别<br>编译过程：<br>v-if 是真正的条件渲染，因为它会在切换过程对元素和组件适当的销毁和重建 。<br>v-show的元素始终会被渲染。只是基于CSS属性display的切换<br>编译条件：<br>v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做。直到条件第一次变为真时，才会开始渲染。<br>v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS进行切换<br>性能消耗：<br>v-if有更高的切换消耗。<br>v-show有更高的 初始渲染消耗&#96;。<br>应用场景：<br>v-if适合条件很少改变时使用。<br>v-show适合频繁切换</p>
<h2 id="自定义指令的方法有哪些-它有哪些钩子函数-还有哪些钩子函数参数-（必会）"><a href="#自定义指令的方法有哪些-它有哪些钩子函数-还有哪些钩子函数参数-（必会）" class="headerlink" title="自定义指令的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）"></a>自定义指令的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）</h2><p>全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives<br>钩子函数：bind(绑定事件触发)、inserted(节点插入的时候触发)、update(组件内相关更新)<br>钩子函数参数：el、binding</p>
<h2 id="vue路由作用与原理"><a href="#vue路由作用与原理" class="headerlink" title="vue路由作用与原理"></a>vue路由作用与原理</h2><p>路由作用： 实现单页面应用<br>原理：监听location的hash值</p>
<h2 id="路由之间是怎么跳转的？有哪些方式"><a href="#路由之间是怎么跳转的？有哪些方式" class="headerlink" title="路由之间是怎么跳转的？有哪些方式?"></a>路由之间是怎么跳转的？有哪些方式?</h2><p>1、<router-link to="需要跳转到页面的路径"><br>2、this.$router.push()跳转到指定的url，并在history中添加记录，点击回退返回到上一个页面<br>3、this.$router.replace()跳转到指定的url，但是history中不会添加记录，点击回退到上上个页面<br>4、this.$touter.go(n)向前或者后跳转n个页面，n可以是正数也可以是负数</p>
<h2 id="再用动态路由的时候防止刷新白屏"><a href="#再用动态路由的时候防止刷新白屏" class="headerlink" title="再用动态路由的时候防止刷新白屏"></a>再用动态路由的时候防止刷新白屏</h2><p>router.addRoutes(routes) routes新的路由<br>next({…to,replace:true})</p>
<h2 id="vue-router怎么配置路由（路由配置六个流程）"><a href="#vue-router怎么配置路由（路由配置六个流程）" class="headerlink" title="vue-router怎么配置路由（路由配置六个流程）"></a>vue-router怎么配置路由（路由配置六个流程）</h2><p>1.引入组件<br>2.配置路由path和组件, 和生成路由对象routes<br>3.创建路由对象router<br>4.把路由对象挂载到new Vue()<br>5.页面使用<router-view></router-view> 承载路由<br>6.<router-link to="要跳转的路径"></router-link> 设置路由导航(声明式导航方式&#x2F;编程式跳转)</p>
<h2 id="vue-router的钩子函数都有哪些（导航守卫）"><a href="#vue-router的钩子函数都有哪些（导航守卫）" class="headerlink" title="vue-router的钩子函数都有哪些（导航守卫）"></a>vue-router的钩子函数都有哪些（导航守卫）</h2><p>关于vue-router中的钩子函数主要分为3类<br>    1.全局钩子函数beforeEach（全局前置守卫，所有路由生效）<br>        beforeEach函数有三个参数,分别是:<br>            to:router即将进入的路由对象<br>            from:当前导航即将离开的路由<br>            next:function,进行管道中的一个钩子，如果执行完了,则导航的状态就是 confirmed （确认的）否则为false,终止导航。<br>    2.单独路由独享组件（只对这个路由生效）<br>        beforeEnter,<br>    3 组件内钩子<br>        beforeRouterEnter，（渲染路由组件前）<br>        beforeRouterUpdate,（路由改变）<br>        beforeRouterLeave（路由离开）</p>
<h2 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h2><ul>
<li>1.导航被触发。</li>
<li>2.在失活的组件里调用 beforeRouteLeave 守卫。</li>
<li>3.调用全局的 beforeEach 守卫。</li>
<li>4.在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li>
<li>5.在路由配置里调用 beforeEnter。</li>
<li>6.解析异步路由组件。</li>
<li>7.在被激活的组件里调用 beforeRouteEnter。</li>
<li>8.调用全局的 beforeResolve 守卫(2.5+)。</li>
<li>9.导航被确认。</li>
<li>10.调用全局的 afterEach 钩子。</li>
<li>11.触发 DOM 更新。</li>
<li>12.调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>
</ul>
<h2 id="什么是路由守卫？"><a href="#什么是路由守卫？" class="headerlink" title="什么是路由守卫？"></a>什么是路由守卫？</h2><p>路由守卫又叫导航守卫，就是路由跳转 前，中，后过程中的一些钩子函数，这个函数能够让你操作一些其他的事。</p>
<h2 id="路由传值的方式有哪几种"><a href="#路由传值的方式有哪几种" class="headerlink" title="路由传值的方式有哪几种"></a>路由传值的方式有哪几种</h2><p>Vue-router传参可以分为两大类，分别是编程式的导航和声明式的导航<br>    1.编程式导航：router.push<br>        字符串：直接传递路由地址，但是不能传递参数<br>            this.$router.push(“home”)<br>        对象：<br>            命名路由 这种方式传递参数，目标页面刷新会报错 name+params<br>            this.$router.push({name:”news”,params:{userId:123}})<br>            查询参数 和path配对的是query<br>            this.$router.push({path:”&#x2F;news’,query:{usersId:123}})<br>        接收参数 this.$route.query<br>    2.声明式导航<br>        字符串 &lt;router-link to:”news”&gt;</router-link><br>        命名路由 &lt;router-link :to:”{name:’news’,params:{userId:1111}}”&gt;</route-link><br>        还可以to&#x3D;”&#x2F;path&#x2F;值” - 需要提前在路由 规则里值 &#x2F;path&#x2F;:key<br>        查询参数 <router-link :to="{path:'/news',query:{userId:1111}}"></router-link><br>        还可以to&#x3D;”&#x2F;path?key&#x3D;value</p>
<h2 id="Vue路由传参方式，如何接收对应的值？"><a href="#Vue路由传参方式，如何接收对应的值？" class="headerlink" title="Vue路由传参方式，如何接收对应的值？"></a>Vue路由传参方式，如何接收对应的值？</h2><p>三种： 分别是query，params，动态路由传参<br>接收：<br>通过query方式传递过来的参数一般是通过this.$route.query接收<br>通过params方式传递过来的参数一般是通过this.$route.params接收<br>通过动态路由传参方式传递过来的参数一般是通过this.$route.params接收</p>
<h2 id="Vue的路由实现模式：hash模式和history模式"><a href="#Vue的路由实现模式：hash模式和history模式" class="headerlink" title="Vue的路由实现模式：hash模式和history模式"></a>Vue的路由实现模式：hash模式和history模式</h2><p>1.路径不同<br>    hash有#, history没有#<br>2.工作模式不同<br>    hash : 修改当前页面hash,不需要服务器额外配<br>    history: 会给服务器发送请求，需要服务器配置</p>
<p>1.hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。</p>
<p>2.history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更</p>
<h2 id="请说出路由配置项常用的属性及作用"><a href="#请说出路由配置项常用的属性及作用" class="headerlink" title="请说出路由配置项常用的属性及作用"></a>请说出路由配置项常用的属性及作用</h2><p>路由配置参数：<br>    path : 跳转路径<br>    component : 路径相对于的组件<br>    name:命名路由<br>    children:子路由的配置参数(路由嵌套)<br>    props:路由解耦<br>    redirect : 重定向路由</p>
<h2 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别?"></a>$route和$router的区别?</h2><p>$router 对象。用于跳转路由和传递参数<br>$route 对象。用于接收路由跳转参数</p>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>keep-alive组件 作用就是保持一个组件活着</p>
<ul>
<li>缓存状态组件，他不会渲染成真实dom，只是将被包裹的自定义组件的状态缓存到内存中</li>
<li>多用于缓存 表单填写的组件</li>
<li>它不能缓存v-for循环渲染出来的组件<br> include属性,表示在被keep-alive管理的组件中,哪些需要保持活跃,有多个需要保持的,以逗号隔开<br> exclude属性,表示在被keep-alive管理的组件中,哪些不需要保持活跃,</li>
</ul>
<h2 id="跟keep-alive有关的生命周期是哪些？"><a href="#跟keep-alive有关的生命周期是哪些？" class="headerlink" title="跟keep-alive有关的生命周期是哪些？"></a>跟keep-alive有关的生命周期是哪些？</h2><p>1.前言：在开发Vue项目的时候，大部分组件是没必要多次渲染的，所以Vue提供了一个内置组件keep-alive来缓存组件内部状态，避免重新渲染<br>2.生命周期函数：在被keep-alive包含的组件&#x2F;路由中，会多出两个生命周期的钩子:activated 与 deactivated。<br>    activated钩子：在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。<br>    deactivated钩子：组件被停用（离开路由）时调用</p>
<h2 id="vuex作用及五大组成部分"><a href="#vuex作用及五大组成部分" class="headerlink" title="vuex作用及五大组成部分"></a>vuex作用及五大组成部分</h2><pre><code>vuex作用： 全局数据管理 解决复杂的父子组件传值
state作用：存储数据
getter作用：派生数据。相当于state计算属性
mutations作用：修改state中的数据
actions作用： 异步更新数据
module作用：模块化处理vuex数据
</code></pre>
<h2 id="vuex中action工作流程"><a href="#vuex中action工作流程" class="headerlink" title="vuex中action工作流程"></a>vuex中action工作流程</h2><p>1.组件给actions发送消息<br>2.actions异步请求数据<br>3.actions将请求到的数据提交给mutations<br>4.mutations同步更新state中的数据</p>
<h2 id="vuex刷新页面丢失数据原因和解决方法？"><a href="#vuex刷新页面丢失数据原因和解决方法？" class="headerlink" title="vuex刷新页面丢失数据原因和解决方法？"></a>vuex刷新页面丢失数据原因和解决方法？</h2><p>原因：- 因为js的数据都是保存在浏览器的堆和栈内的，刷新浏览器页面，以前堆栈申请的内存被释放(这就是浏览器的运行机制),那么堆栈里的数据自然就被清空了</p>
<ul>
<li>解决方法<ul>
<li>使用cookie或localstorage</li>
<li>第二种方法是 vuex-along<ul>
<li>安装 vuex-along -  npm install vuex-along –save</li>
</ul>
</li>
<li>第三种方法是 vuex-persistedstate po si te si de te<ul>
<li>安装 vuex-persistedstate -  npm install –save vuex-persistedstate</li>
</ul>
</li>
<li>第四种方法是 vuex-persist<ul>
<li>安装 vuex-persist - npm install –save vuex-persistor</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="说一下你在vue中踩过的坑"><a href="#说一下你在vue中踩过的坑" class="headerlink" title="说一下你在vue中踩过的坑"></a>说一下你在vue中踩过的坑</h2><p>1、操作data中的数据，发现没有响应式<br>    原因： 数组中有很多方法，有的会改变数组（例如pop push）,有的不会改变数组（例如slice, filter）<br>    解决方案：通过Vue.set(对象，属性，值)这种方式就可以达到，对象新添加的属性是响应式的<br>2、在created操作dom的时候，是报错的，获取不到dom，这个时候实例vue实例没有挂载<br>    解决方案：Vue.nextTick(回调函数进行获取)</p>
<h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><h2 id="小程序的登录流程是什么"><a href="#小程序的登录流程是什么" class="headerlink" title="小程序的登录流程是什么"></a>小程序的登录流程是什么</h2><ol>
<li>用户点击登录按钮 通过wx.login() 获取用户的code码</li>
<li>通过wx.request() 网络请求将code码发送给开发者服务器</li>
<li>后端开发者拿到code码后需要通过appid+appsecret+code向微信接口服务器请求当前用户的session_key和openid</li>
<li>后端得到session_key 和openid后 会自定义一个登录态(token)和session_key及openid进行绑定</li>
<li>后端会将token返回给小程序端&#x2F;&#x2F;tao kin</li>
<li>将小程序端得到token后 要将token存到本地</li>
</ol>
<h2 id="小程序项目允许的最大体积是多少"><a href="#小程序项目允许的最大体积是多少" class="headerlink" title="小程序项目允许的最大体积是多少"></a>小程序项目允许的最大体积是多少</h2><p>不适用分包的情况下 小程序总体积不能超过2MB<br>如果使用分包的情况下 总体积不能超过20MB 单个包体积不能超过2MB</p>
<h2 id="小程序和普通网页区别"><a href="#小程序和普通网页区别" class="headerlink" title="小程序和普通网页区别"></a>小程序和普通网页区别</h2><p>运行环境不同：网页在浏览器运行，小程序在微信环境运行</p>
<p>开发模式不同： 网页开发用浏览器+代码编辑器 小程序有自己的一套标准开发模式，使<br>用小程序开发工具</p>
<p>api不同 运行环境不同所以小程序没有办法调用bom和dom的api 小程序可以调用微信环境<br>提供的各种api 比如扫码，支付，地理定位，摇一摇，附近的人等等…</p>
<h2 id="小程序的项目构成"><a href="#小程序的项目构成" class="headerlink" title="小程序的项目构成"></a>小程序的项目构成</h2><p>pages 用来存放所有小程序页面<br>utils 用来存放工具性质模块，比如格式化时间.wxs文件，封装请求数据组件.js文件<br>​<br>app.js 小程序项目的入口文件  类似vue的 app.vue<br>app.json 小程序项目的全局配置文件<br>app.wxss 小程序项目的全局样式文件<br>project.config.json 项目的配置文件<br>sitemap.json 用来配置小程序是否允许被微信搜索引擎搜索到，比如：在微信小程序搜<br>京东，会弹出京东小程序，<br>如果关闭，搭建的项目，微信是无法搜索到的。</p>
<h2 id="小程序页面的组成部分"><a href="#小程序页面的组成部分" class="headerlink" title="小程序页面的组成部分**"></a>小程序页面的组成部分**</h2><p>每个页面由四个基本文件组成，在app.json文件中配置好pages后小程序会自动生成文件</p>
<ol>
<li>.js文件 存放页面脚本文件，存放页面的数据，事件处理函数等 （写逻辑代码）</li>
<li>.json文件 当前页面配置文件，配置窗口的外观，表现等</li>
<li>.wxml文件 存放页面布局，类似html但不同，div&#x3D;view span&#x3D;text img&#x3D;image</li>
<li>.wxss文件 存放样式类似css但是和css不同，.wxss新增了rpx像素单位，只能引入外<br>链文件和样式背景图等都必须外链文件。</li>
</ol>
<h2 id="app-json中的配置有哪些"><a href="#app-json中的配置有哪些" class="headerlink" title="## app.json中的配置有哪些"></a>## app.json中的配置有哪些</h2><p>1、pages 用于保存页面的路径<br>2、window 配置页面头部的导航栏<br>3、tabBar 配置页面底部菜单栏<br>4、entryPagePath 页面加载时初始化的页面<br>5、networkTimeout 配置网络超时时间<br>6、subpackage 配置小程序的分包功能</p>
<h2 id="window配置中的配置项有哪些"><a href="#window配置中的配置项有哪些" class="headerlink" title="window配置中的配置项有哪些"></a>window配置中的配置项有哪些</h2><ul>
<li>navigationBarBackgroundColor：导航栏背景色 只支持十六进制的颜色表示法 &#x2F;&#x2F;nav一给身霸拜克哥软的卡乐</li>
<li>navigationBarTextStyle：导航栏的文本样式，只支持两个值 block white</li>
<li>navigationBarTitleText：导航栏的标题文本</li>
<li>backgroundColor：设置下拉刷新的背景色</li>
<li>backgroundTextStyle：下拉刷新界面的文本样式 只支持两个值 dark light</li>
<li>enablePullDownRefresh：是否启用下拉刷新功能 &#x2F;&#x2F;以内bo pou当瑞服瑞吃</li>
<li>navigationStyle:导航栏的样式 只支持两个值 default与custom default表示默认显示导航栏，custom表示隐藏导航栏 只保留右侧胶囊按钮 可以自己定义</li>
</ul>
<h2 id="tabBar配置中的配置项有哪些"><a href="#tabBar配置中的配置项有哪些" class="headerlink" title="tabBar配置中的配置项有哪些"></a>tabBar配置中的配置项有哪些</h2><ul>
<li>list 配置底部的菜单栏列表项</li>
<li>color 设置默认状态的文本颜色</li>
<li>selectedColor 设置激活状态的文本颜色</li>
<li>backgroundColor 设置菜单栏的背景色</li>
<li>borderStyle 设置菜单栏的上边框样式 支持white和black </li>
<li>position 菜单栏的位置 只支持top和bottom</li>
<li>custom 自定义菜单栏 true  或者  false</li>
</ul>
<h2 id="如何自定义tabBar"><a href="#如何自定义tabBar" class="headerlink" title="如何自定义tabBar"></a>如何自定义tabBar</h2><p>首先在app.json中 配置“tabBar”，对象然后创建list数组，写实际的路径，最少两个，最多五个。</p>
<h2 id="networkTimeout配置中的配置项有哪些"><a href="#networkTimeout配置中的配置项有哪些" class="headerlink" title="networkTimeout配置中的配置项有哪些"></a>networkTimeout配置中的配置项有哪些</h2><ul>
<li>request：配置网络请求的超时时间</li>
<li>connectSocket：配置既时通讯的超时时间</li>
<li>uploadFile：配置上传内容的超时时间</li>
<li>downloadFile：配置下载文件的超时时间</li>
</ul>
<h2 id="小程序渲染数据如何渲染"><a href="#小程序渲染数据如何渲染" class="headerlink" title="小程序渲染数据如何渲染"></a>小程序渲染数据如何渲染</h2><p>使用插值表达式渲染数据</p>
<h2 id="列表渲染的指令是什么"><a href="#列表渲染的指令是什么" class="headerlink" title="列表渲染的指令是什么"></a>列表渲染的指令是什么</h2><pre><code>wx:for
</code></pre>
<h2 id="列表渲染如何修改item和index的名字"><a href="#列表渲染如何修改item和index的名字" class="headerlink" title="列表渲染如何修改item和index的名字"></a>列表渲染如何修改item和index的名字</h2><pre><code>wx:for-item   wx:for-index
</code></pre>
<h2 id="列表渲染可以渲染的数据类型有哪些"><a href="#列表渲染可以渲染的数据类型有哪些" class="headerlink" title="列表渲染可以渲染的数据类型有哪些"></a>列表渲染可以渲染的数据类型有哪些</h2><pre><code>Array  Object  String  Number
</code></pre>
<h2 id="block标签的作用是什么"><a href="#block标签的作用是什么" class="headerlink" title="block标签的作用是什么"></a>block标签的作用是什么</h2><pre><code>专门用于条件渲染和列表渲染使用的,block标签不会渲染到页面视图中
</code></pre>
<h2 id="小程序中如何实现响应式的数据修改"><a href="#小程序中如何实现响应式的数据修改" class="headerlink" title="小程序中如何实现响应式的数据修改"></a>小程序中如何实现响应式的数据修改</h2><pre><code>获取数据使用this.data.变量名
通过this.setData() 方法来修改数据
</code></pre>
<h2 id="小程序生命周期函数有哪些"><a href="#小程序生命周期函数有哪些" class="headerlink" title="小程序生命周期函数有哪些"></a>小程序生命周期函数有哪些</h2><pre><code>onLaunch:整个小程序初始化完成
onShow:小程序加载完成或者当小程序切回前台时触发
onHide:小程序切换到后台时触发
</code></pre>
<h2 id="页面级生命周期函数有哪些"><a href="#页面级生命周期函数有哪些" class="headerlink" title="页面级生命周期函数有哪些"></a>页面级生命周期函数有哪些</h2><pre><code>onLoad:当前页面加载时触发的时间
onShow:当前页面在前台显示时触发
onReady:当前页面初次渲染完成后触发
onHide:当前页面隐藏是触发
onUnload:当前页面卸载是触发
</code></pre>
<h2 id="组件级生命周期函数有哪些"><a href="#组件级生命周期函数有哪些" class="headerlink" title="组件级生命周期函数有哪些"></a>组件级生命周期函数有哪些</h2><pre><code>created:当前组件初始化完成时触发,无法调用setData方法
attached:当前组件在页面中挂载是会触发
ready:当前组件已经全部渲染完成后触发
moved:当前组件从节点树中的一个位置移动到另一个位置时触发
detached:当前组件被移除是触发--*
</code></pre>
<h2 id="组件的主要生命周期"><a href="#组件的主要生命周期" class="headerlink" title="组件的主要生命周期"></a>组件的主要生命周期</h2><p>在小程序中，最重要的生命周期函数有三个分别是，<br>    created，attached，detached<br>    1.组件实例刚刚被创建好触发created，不能调用setData<br>    用来给组件的this添加一些自定义属性<br>    2.组件完全初始化完毕，进入页面节点树后，触发<br>    attached。this.data已经被初始化完毕，初始化工作比如发送请求。<br>    3.组件离开页面节点树，触发detached生命周期函数，清理性质工作</p>
<h2 id="input组件如何实现双线数据绑定"><a href="#input组件如何实现双线数据绑定" class="headerlink" title="input组件如何实现双线数据绑定"></a>input组件如何实现双线数据绑定</h2><p>需要通过 value&#x3D;’‘ 将数据渲染到输入框中  再通过bind:input 事件 获取用户输入的内容，来修改数据的值</p>
<h2 id="input组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值"><a href="#input组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值" class="headerlink" title="input组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值"></a>input组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值</h2><pre><code>send	   发送
search	 搜索
next	   下一个
go	     前往
done	   完成
</code></pre>
<h2 id="input组件中有几种键盘类型，分别是什么"><a href="#input组件中有几种键盘类型，分别是什么" class="headerlink" title="input组件中有几种键盘类型，分别是什么"></a>input组件中有几种键盘类型，分别是什么</h2><pre><code>input 键盘类型
text              文本输入键盘  
number            数字输入键盘  
idcard            身份证输入键盘 
digit             带小数点的数字键盘 
safe-password     密码安全输入键盘 指引 
nickname          昵称输入键盘
</code></pre>
<h2 id="scroll-view组件想要纵向滚动时，必须要设置的内容有哪些"><a href="#scroll-view组件想要纵向滚动时，必须要设置的内容有哪些" class="headerlink" title="scroll-view组件想要纵向滚动时，必须要设置的内容有哪些"></a>scroll-view组件想要纵向滚动时，必须要设置的内容有哪些</h2><pre><code>scroll-y 必须设置高
</code></pre>
<h2 id="navigator组件的跳转方式有哪些"><a href="#navigator组件的跳转方式有哪些" class="headerlink" title="navigator组件的跳转方式有哪些"></a>navigator组件的跳转方式有哪些</h2><pre><code>navigate  redirect  switchTab reLaunch  navigateBack  exit
</code></pre>
<h2 id="navigate和-redirect方式有什么区别，共同点"><a href="#navigate和-redirect方式有什么区别，共同点" class="headerlink" title="navigate和 redirect方式有什么区别，共同点"></a>navigate和 redirect方式有什么区别，共同点</h2><pre><code>navigate:保留当前页面
redirect:关闭当前页面
共同点：不能跳到tabBar页面 可以携带参数
</code></pre>
<h2 id="navigate和-switchTab-方式有什么区别，共同点"><a href="#navigate和-switchTab-方式有什么区别，共同点" class="headerlink" title="navigate和 switchTab 方式有什么区别，共同点"></a>navigate和 switchTab 方式有什么区别，共同点</h2><pre><code>navigate:保留当前页面 不可以跳转tabBar 可以携带参数
switchTab:跳转到tabBar页面 并关闭其他所有非tabBar页面 不可以传参
没有共同点
</code></pre>
<h2 id="navigate和-reLaunch-方式有什么区别，共同点"><a href="#navigate和-reLaunch-方式有什么区别，共同点" class="headerlink" title="navigate和 reLaunch 方式有什么区别，共同点"></a>navigate和 reLaunch 方式有什么区别，共同点</h2><pre><code>navigate:保留当前页面 不可以跳转tabBar
reLaunch:关闭所有页面 允许跳转任意页面
共同点：可以传递参数
</code></pre>
<h2 id="图片组件是否有默认宽高，默认宽高是多少"><a href="#图片组件是否有默认宽高，默认宽高是多少" class="headerlink" title="图片组件是否有默认宽高，默认宽高是多少?"></a>图片组件是否有默认宽高，默认宽高是多少?</h2><pre><code>宽：320px 高240px
</code></pre>
<h2 id="wxss和css的不同之处有哪些"><a href="#wxss和css的不同之处有哪些" class="headerlink" title="wxss和css的不同之处有哪些"></a>wxss和css的不同之处有哪些</h2><pre><code>wxss文件
在小程序中,不能使用通配符选择器(*)
新增了尺寸单位 rpx
新增样式导入   使用@import语句可以导入外联样式表  该语句后面必须要以分号结尾,不然会报错
可以配置全局样式与局部样式,全局样式直接写在app.wxss中
</code></pre>
<h2 id="小程序有几种绑定事件的方式，有什么区别"><a href="#小程序有几种绑定事件的方式，有什么区别" class="headerlink" title="小程序有几种绑定事件的方式，有什么区别"></a>小程序有几种绑定事件的方式，有什么区别</h2><pre><code>小程序的事件系统
两种绑定事件的语法 bind 与catch
通过bind绑定通用事件,会产生事件流,如果祖级元素有相同类型的事件,会同时触发
catch绑定通用事件,不会产生事件流,
bind与catch绑定时,语法为bind:事件名,但是中间的:可以省略
</code></pre>
<h2 id="常见移动端事件有哪，说出5个以上"><a href="#常见移动端事件有哪，说出5个以上" class="headerlink" title="常见移动端事件有哪，说出5个以上"></a>常见移动端事件有哪，说出5个以上</h2><p>移动端事件:<br>    tap 触摸事件<br>    longtap 长按事件(被longpress代替)<br>    touchstart 手指触摸动作开始事件<br>    touchend 手指触摸动作结束事件<br>    touchmove 手指触摸后移动事件<br>    touchcancel 手指触摸动作被打断，如来电提醒，弹窗<br>    longpress 手指触摸后,超过350ms再离开,如果指定了事件回调函数并触发了这个事件,tap事件将不被触发<br>    touchforcechange  在支持 3D Touch 的 iPhone 设备，重按时会触发</p>
<h2 id="触摸事件的事件对象中有哪些常见属性，作用是什么"><a href="#触摸事件的事件对象中有哪些常见属性，作用是什么" class="headerlink" title="触摸事件的事件对象中有哪些常见属性，作用是什么"></a>触摸事件的事件对象中有哪些常见属性，作用是什么</h2><p>事件对象<br>在小程序的事件绑定函数上,不允许加括号调用<br>触摸事件的事件对象<br>     changedTouches:[] 记录发生改变的手指的数量<br>     currentTarget: 表示真正触发事件的元素<br>     offsetLeft: 元素与设备左侧的距离<br>     offsetTop: 元素与设备上方的距离<br>     detail: 记录参数信息,手指触摸的坐标,<br>     target: 手指触摸的元素<br>     touches:[] 记录手指触摸的个数<br>     type: 事件类型</p>
<h2 id="target-和currentTarget两者的区别是什么"><a href="#target-和currentTarget两者的区别是什么" class="headerlink" title="target 和currentTarget两者的区别是什么"></a>target 和currentTarget两者的区别是什么</h2><pre><code>target表示的是手指触摸的元素,而currentTarget表示响应事件的元素

我们可以通过target中的内容来进行判断,实现事件委托的操作
我们可以通过target中的id属性来进行判断触发的是哪一个组件,实现事件委托的操作
</code></pre>
<h2 id="小程序中的事件如何传递数据"><a href="#小程序中的事件如何传递数据" class="headerlink" title="小程序中的事件如何传递数据"></a>小程序中的事件如何传递数据</h2><pre><code>通过data-属性来传递数据  例 data-变量名=&quot;传递的数据&quot;  通过e.currentTarget.dataset.变量名接收数据
</code></pre>
<h2 id="小程序中全局数据如何使用，有什么特点"><a href="#小程序中全局数据如何使用，有什么特点" class="headerlink" title="小程序中全局数据如何使用，有什么特点"></a>小程序中全局数据如何使用，有什么特点</h2><pre><code>在app.js中,配置一个globalData属性,在这个属性中保存的内容就是全局数据
在其他页面中使用时,通过getApp()方法,可以获取到app实例,从而使用app.globalData就可以拿到数据
在globalData中的数据不能通过setData()方法来更新
</code></pre>
<h2 id="如何自定义一个组件"><a href="#如何自定义一个组件" class="headerlink" title="如何自定义一个组件"></a>如何自定义一个组件</h2><pre><code>在项目中新建一个components 目录 该目录用于保存自定义组件 在页面的json文件中的usingComponents字段中 引入对应的组件路径 之后就可以在对应页面的wxml中使用该组件
</code></pre>
<h2 id="关于父子组件之间样式是如何影响的"><a href="#关于父子组件之间样式是如何影响的" class="headerlink" title="关于父子组件之间样式是如何影响的"></a>关于父子组件之间样式是如何影响的</h2><pre><code>在组件的js文件中可以添加一个options，该选项是一个对象，对象中可以添加一个styleIsolation属性用于控制父子组件之间的样式隔离问题
styleIsolation属性有3个可选值：
    isolated ：默认不会相互影响
    apply-shared 父影响子
    shared:相互影响
</code></pre>
<h2 id="组件的外部样式类如何设置"><a href="#组件的外部样式类如何设置" class="headerlink" title="组件的外部样式类如何设置"></a>组件的外部样式类如何设置</h2><pre><code>- 在子组件希望有样式的标签上添加一个类名
- 在子组件的component构造器中添加externalclasses:[]添加上的类名 
- 在父组件的子组件标签上 添加对应的class的属性名 值是一个父组件的类名
- 在父组件的wxss中设置对应的class的样式即可生效
</code></pre>
<h2 id="小程序想要实现多个插槽使用如何设置"><a href="#小程序想要实现多个插槽使用如何设置" class="headerlink" title="小程序想要实现多个插槽使用如何设置"></a>小程序想要实现多个插槽使用如何设置</h2><pre><code>如果想要同时使用多个 需要在组件的js文件的options选项内开启配置multipleSlots:true 才会生效
</code></pre>
<h2 id="父组件如何传值给子组件"><a href="#父组件如何传值给子组件" class="headerlink" title="父组件如何传值给子组件"></a>父组件如何传值给子组件</h2><pre><code>1. 在父组件的子组件标签上动态绑定一个自定义属性，将要需要传递的数据放到属性值中
2. 在子组件的js文件中 通过properties属性来接收父组件传递的数据
</code></pre>
<h2 id="子组件如何传值给父组件"><a href="#子组件如何传值给父组件" class="headerlink" title="子组件如何传值给父组件"></a>子组件如何传值给父组件</h2><pre><code>1. 在子组件的事件函数中 通过this.triggerEvent()向父组件发出一个自定义事件 该方法有两个参数 第一个是自定义事件名 第二个是传递的参数
2. 在父组件的子组件标签上 通过bind监听子组件发出的自定义事件 在事件对象event的detail属性中可以接收到子组件传递过来的数据
</code></pre>
<h2 id="组件如何监听页面级生命周期"><a href="#组件如何监听页面级生命周期" class="headerlink" title="组件如何监听页面级生命周期"></a>组件如何监听页面级生命周期</h2><pre><code>通过pageLifetimes属性来监听
该属性对象中有三个响应函数 show hide resize
    1. show 表示组件所在页面被展示时的函数
    2. hide 表示组件所在页面被隐藏时的函数
    3. resize 表示组件所在页面尺寸发生变化时的函数
</code></pre>
<h2 id="小程序中的交互API有哪些"><a href="#小程序中的交互API有哪些" class="headerlink" title="小程序中的交互API有哪些"></a>小程序中的交互API有哪些</h2><pre><code>wx.showToast：消息提示框
wx.showModal：显示模态对话框
wx.showLoading 显示 loading 提示框。需主动调用 wx.hideLoading 才能关闭提示框
wx.showActionSheet 显示操作菜单
wx.hideToast 隐藏消息提示框
wx.hideLoading 隐藏loading提示框
</code></pre>
<h2 id="小程序中域名无法识别如何处理"><a href="#小程序中域名无法识别如何处理" class="headerlink" title="小程序中域名无法识别如何处理"></a>小程序中域名无法识别如何处理</h2><pre><code>在小程序本地设置中勾选不校验合法域名选项即可请求
在发布阶段，如果希望能够请求服务器资源，那么我们必须为这个服务器配置白名单
</code></pre>
<h2 id="网络请求限制，如何配置合法域名？"><a href="#网络请求限制，如何配置合法域名？" class="headerlink" title="网络请求限制，如何配置合法域名？"></a>网络请求限制，如何配置合法域名？</h2><pre><code>1.出于安全考虑，小程序对数据接口的请求有限制要求，小程序只能请求https类型接口，
必须将接口的域名添加到信任列表中否则控制台会提示（警告）
2.登录小程序公众平台---&gt;开发管理----&gt;开发设置---&gt;服务器域名---&gt;修改合法域名
</code></pre>
<h2 id="小程序中base64与二进制数据流之间的转换如何转换"><a href="#小程序中base64与二进制数据流之间的转换如何转换" class="headerlink" title="小程序中base64与二进制数据流之间的转换如何转换"></a>小程序中base64与二进制数据流之间的转换如何转换</h2><pre><code>wx.base64ToArrayBuffer
wx.arrayBufferToBase64
</code></pre>
<h2 id="你是怎么封装微信小程序的数据请求的？"><a href="#你是怎么封装微信小程序的数据请求的？" class="headerlink" title="你是怎么封装微信小程序的数据请求的？"></a>你是怎么封装微信小程序的数据请求的？</h2><pre><code>在根目录下创建util目录及api.js文件和apiConfig.js文件
在apiConfig.js封装基础的get，post和put，upload等请求方法，设置请求体，带上token和异常处理等
在api中引入apiConfig.js封装好的请求方法.根据页面数据请求的urls，设置对应的方法并导出
在具体的页面中导入或将所有的接口放在统一的js文件中并导出
在app.js中创建封装请求数据的方法
</code></pre>
<h2 id="小程序支付如何实现？"><a href="#小程序支付如何实现？" class="headerlink" title="小程序支付如何实现？"></a>小程序支付如何实现？</h2><p>小程序注册，要以公司的身份去注册一个小程序，才有微信支付权限</p>
<p>绑定商户号</p>
<p>在小程序填写合法域</p>
<p>调用wx.login()获取appid</p>
<p>调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">wx.<span class="hljs-title function_">requestPayment</span>(<br>&#123;<br>    <span class="hljs-string">&#x27;timeStamp&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">//时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间</span><br>    <span class="hljs-string">&#x27;nonceStr&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">//随机字符串，长度为32个字符以下。</span><br>    <span class="hljs-string">&#x27;package&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">//统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=*</span><br>    <span class="hljs-string">&#x27;signType&#x27;</span>: <span class="hljs-string">&#x27;MD5&#x27;</span>,<span class="hljs-comment">//签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致</span><br>    <span class="hljs-string">&#x27;paySign&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">//签名,具体签名方案参见微信公众号支付帮助文档;</span><br>    <span class="hljs-string">&#x27;success&#x27;</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;&#125;,<span class="hljs-comment">//成功回调</span><br>    <span class="hljs-string">&#x27;fail&#x27;</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;&#125;,<span class="hljs-comment">//失败</span><br>    <span class="hljs-string">&#x27;complete&#x27;</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;&#125;<span class="hljs-comment">//接口调用结束的回调函数（调用成功、失败都会执行）</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="小程序如何进行分包"><a href="#小程序如何进行分包" class="headerlink" title="小程序如何进行分包"></a>小程序如何进行分包</h2><pre><code>在subpackages字段里面的页面都是分包内容
root 分包根目录
name 分包别名
pages 分包页面路径
</code></pre>
<h2 id="普通分包和独立分包有什么不同"><a href="#普通分包和独立分包有什么不同" class="headerlink" title="普通分包和独立分包有什么不同"></a>普通分包和独立分包有什么不同</h2><pre><code>普通分包 那么该包必须依赖主包才能加载 不允许单独加载
独立分包 独立运行 不需要先加载主包
</code></pre>
<h2 id="分包有哪些注意事项"><a href="#分包有哪些注意事项" class="headerlink" title="分包有哪些注意事项"></a>分包有哪些注意事项</h2><pre><code>tabBar页面不允许放在分包中 只能放在主包
一个分包的根目录不能是另一个分包的子目录
一个分包不能require导入另一个分包的js文件 但是可以使用主包的js文件
一个分包不能使用另一个分包中的资源 但是可以使用主包资源
</code></pre>
<h1 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h1><h2 id="uni-app有哪些优势"><a href="#uni-app有哪些优势" class="headerlink" title="uni-app有哪些优势?"></a>uni-app有哪些优势?</h2><ul>
<li>开发者&#x2F;案例的数量最多</li>
<li>平台能力不受限制</li>
<li>性能体验优秀</li>
<li>周边生态丰富</li>
<li>学习成本低</li>
<li>开发成本低</li>
</ul>
<h2 id="uni-app语法、组件-及-生命周期-的-相同之处？"><a href="#uni-app语法、组件-及-生命周期-的-相同之处？" class="headerlink" title="uni-app语法、组件 及 生命周期 的 相同之处？"></a>uni-app语法、组件 及 生命周期 的 相同之处？</h2><ul>
<li>所有的语法接近与vue 可以使用vue的所有的指令，以及vue中的语法</li>
<li>所有的组件接近与微信小程序</li>
<li>所有的生命周期接近于小程序</li>
</ul>
<h4 id="uni-app的不同之处？"><a href="#uni-app的不同之处？" class="headerlink" title="uni-app的不同之处？"></a>uni-app的不同之处？</h4><ul>
<li>条件编译 可以在任意位置出现<br>是以注释的形式来添加条件编译</li>
</ul>
<p>#ifdef 表示包含那些端渲染，起始位置<br>#idndef 表示排除那些端渲染，起始位置<br>#endif 表示结束位置<br>各端的条件：<br>H5 表示移动端<br>MP 表示所有小程序<br>MP-WEIXIN 表示微信小程序<br>APP-PLUS 表示APP端</p>
<ul>
<li>APP端的Nvue开发<br>如果你不开发APP，那么是不需要使用Nvue的</li>
<li>HTML5+引擎<br>APP内置了HTML5+引擎，可以让js具有直接调用原生能力，在H5和小程序端没有HTML5+引擎的，因此如果需要使用这个引擎，还是需要加条件编译</li>
</ul>
<h2 id="网络封装"><a href="#网络封装" class="headerlink" title="网络封装"></a>网络封装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> baseUrl=<span class="hljs-string">&quot;网址&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">confing</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res,rej</span>)=&gt;</span>&#123;<br>    wx.<span class="hljs-title function_">request</span>(&#123;<br>      <span class="hljs-attr">url</span>:baseUrl+confing.<span class="hljs-property">url</span>,<br>      <span class="hljs-attr">method</span>:confing.<span class="hljs-property">method</span>||<span class="hljs-string">&quot;GET&quot;</span>,<br>      <span class="hljs-attr">data</span>:confing.<span class="hljs-property">data</span>,<br>      <span class="hljs-attr">header</span>:&#123;<br>        <span class="hljs-string">&quot;content-type&quot;</span>:<span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">success</span>:<span class="hljs-function">(<span class="hljs-params">r</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">res</span>(r)<br>    &#125;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="vue2和Vue3的区别"><a href="#vue2和Vue3的区别" class="headerlink" title="vue2和Vue3的区别"></a>vue2和Vue3的区别</h2><h6 id="一-根节点不同"><a href="#一-根节点不同" class="headerlink" title="一. 根节点不同"></a>一. 根节点不同</h6><pre><code>vue2中必须要有根标签
vue3中可以没有根标签，会默认将多个根标签包裹在一个fragement虚拟标签中，有利于减少内存。
</code></pre>
<h6 id="二-组合式API和选项式API"><a href="#二-组合式API和选项式API" class="headerlink" title="二. 组合式API和选项式API"></a>二. 组合式API和选项式API</h6><pre><code>在vue2中采用选项式API，将数据和函数集中起来处理，将功能点切割了当逻辑复杂的时候不利于代码阅读。
在vue3中采用组合式API，将同一个功能的代码集中起来处理，使得代码更加有序，有利于代码的书写和维护。
</code></pre>
<h6 id="三-生命周期的变化"><a href="#三-生命周期的变化" class="headerlink" title="三. 生命周期的变化"></a>三. 生命周期的变化</h6><pre><code>创建前：beforeCreate -&gt; 使用setup()
创建后：created -&gt; 使用setup()
挂载前：beforeMount -&gt; onBeforeMount
挂载后：mounted -&gt; onMounted
更新前：beforeUpdate -&gt; onBeforeUpdate
更新后：updated -&gt; onUpdated
销毁前：beforeDestroy -&gt; onBeforeUnmount
销毁后：destroyed -&gt; onUnmounted
异常捕获：errorCaptured -&gt; onErrorCaptured
被激活：onActivated 被包含在&lt;keep-alive&gt;中的组件，会多出两个生命周期钩子函数。被激活时执行。
切换：onDeactivated 比如从 A 组件，切换到 B 组件，A 组件消失时执行
</code></pre>
<h6 id="四-v-if和v-for的优先级"><a href="#四-v-if和v-for的优先级" class="headerlink" title="四. v-if和v-for的优先级"></a>四. v-if和v-for的优先级</h6><pre><code>在vue2中v-for的优先级高于v-if，可以放在一起使用，但是不建议这么做，会带来性能上的浪费
在vue3中v-if的优先级高于v-for，一起使用会报错。可以通过在外部添加一个标签，将v-for移到外层
</code></pre>
<h6 id="五-diff算法不同"><a href="#五-diff算法不同" class="headerlink" title="五. diff算法不同"></a>五. diff算法不同</h6><ul>
<li><p>vue2中的diff算法<br>  遍历每一个虚拟节点，进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方。<br>  用patch记录的消息去更新dom<br>  缺点：比较每一个节点，而对于一些不参与更新的元素，进行比较是有点消耗性能的。<br>  特点：特别要提一下Vue的patch是即时的，并不是打包所有修改最后一起操作DOM，也就是在vue中边记录变更新。（React则是将更新放入队列后集中处理）。</p>
</li>
<li><p>vue3中的diff算法<br>  在初始化的时候会给每一个虚拟节点添加一个patchFlags，是一种优化的标识。<br>  只会比较patchFlags发生变化的节点，进行识图更新。而对于patchFlags没有变化的元素作静态标记，在渲染的时候直接复用。</p>
</li>
</ul>
<h6 id="六-响应式原理不同"><a href="#六-响应式原理不同" class="headerlink" title="六. 响应式原理不同"></a>六. 响应式原理不同</h6><ul>
<li><p>vue2通过Object.definedProperty()的get()和set()来做数据劫持、结合和发布订阅者模式来实现，Object.definedProperty()会遍历每一个属性。</p>
</li>
<li><p>vue3通过proxy代理的方式实现。<br>  proxy的优势：不需要像Object.definedProperty()的那样遍历每一个属性，有一定的性能提升proxy可以理解为在目标对象之前架设一层“拦截”，外界对该对象的访问都必须通过这一层拦截。这个拦截可以对外界的访问进行过滤和改写。<br>  当属性过多的时候利用Object.definedProperty()要通过遍历的方式监听每一个属性。利用proxy则不需要遍历，会自动监听所有属性，有利于性能的提升</p>
</li>
</ul>
<h2 id="更多vue3相关请查看-http-liuminghao-top"><a href="#更多vue3相关请查看-http-liuminghao-top" class="headerlink" title="更多vue3相关请查看 http://liuminghao.top"></a>更多vue3相关请查看 <a class="link"   target="_blank" rel="noopener" href="http://liuminghao.top/" >http://liuminghao.top<i class="fas fa-external-link-alt"></i></a></h2>
            </div>

            

            

            
                <div class="article-nav">
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2023/06/08/ExpoRN/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item text-ellipsis">expo版rn</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
                






            
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript"><span class="nav-number">1.</span> <span class="nav-text">JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">普通函数与箭头函数的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generator%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">Generator函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFPromise"><span class="nav-number">1.3.</span> <span class="nav-text">什么是Promise?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.4.</span> <span class="nav-text">promise的使用场景?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">什么是回调地狱？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9this%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">对this的理解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.7.</span> <span class="nav-text">什么是事件循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.8.</span> <span class="nav-text">事件循环机制的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%9C%BA%E5%88%B6-%E4%B9%9F%E5%8F%AB%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%88eventLoop%EF%BC%89"><span class="nav-number">1.9.</span> <span class="nav-text">事件轮询的机制 也叫事件循环的机制（eventLoop）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-in%E5%92%8Cfor-of%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.10.</span> <span class="nav-text">for in和for of区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.11.</span> <span class="nav-text">new一个对象的过程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="nav-number">1.12.</span> <span class="nav-text">什么是闭包？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">1.13.</span> <span class="nav-text">什么是堆内存和栈内存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%EF%BC%9F"><span class="nav-number">1.14.</span> <span class="nav-text">节流和防抖？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="nav-number">1.15.</span> <span class="nav-text">哪些数组方法可以改变原数组？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="nav-number">1.16.</span> <span class="nav-text">虚拟DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E4%B8%80%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">1.17.</span> <span class="nav-text">谈一谈垃圾回收机制?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#less-%E5%92%8C-sass-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.18.</span> <span class="nav-text">less 和 sass 的区别 ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.19.</span> <span class="nav-text">CSS预处理器是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="nav-number">1.20.</span> <span class="nav-text">纯函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.21.</span> <span class="nav-text">浏览器的同源策略机制?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#token%E4%B8%80%E8%88%AC%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AD%98%E6%94%BE%E5%9C%A8cookie%E5%86%85"><span class="nav-number">1.22.</span> <span class="nav-text">token一般存放在哪里?为什么不存放在cookie内?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#token%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.23.</span> <span class="nav-text">token是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%9D%A10-5%E5%83%8F%E7%B4%A0%E7%9A%84%E7%BA%BF"><span class="nav-number">1.24.</span> <span class="nav-text">如何实现一条0.5像素的线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.25.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async-x2F-await"><span class="nav-number">1.26.</span> <span class="nav-text">async&#x2F;await</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#transform%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.27.</span> <span class="nav-text">transform的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IE%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.28.</span> <span class="nav-text">IE盒模型和标准盒模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">1.29.</span> <span class="nav-text">css实现三角形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axios"><span class="nav-number">1.30.</span> <span class="nav-text">axios</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JQ%E4%B8%AD-%E7%AC%A6"><span class="nav-number">1.31.</span> <span class="nav-text">JQ中$()符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.32.</span> <span class="nav-text">普通函数和构造函数的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D"><span class="nav-number">1.33.</span> <span class="nav-text">浮动与定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">1.34.</span> <span class="nav-text">递归函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#label%E6%A0%87%E7%AD%BE"><span class="nav-number">1.35.</span> <span class="nav-text">label标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.36.</span> <span class="nav-text">ajax执行步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E9%80%89%E4%B8%ADcss"><span class="nav-number">1.37.</span> <span class="nav-text">最后一个元素选中css</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E6%AF%8D"><span class="nav-number">1.38.</span> <span class="nav-text">统计字符串中出现最多的字母</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="nav-number">1.39.</span> <span class="nav-text">自执行函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%B1%A1%E5%8C%BA%E5%88%AB"><span class="nav-number">1.40.</span> <span class="nav-text">数组 对象区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.41.</span> <span class="nav-text">元素绑定事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8B%89%E5%B9%B3"><span class="nav-number">1.42.</span> <span class="nav-text">数组拉平</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#postion%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.43.</span> <span class="nav-text">postion属性的值有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.44.</span> <span class="nav-text">静态方法 实例方法和原型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#documentFragment"><span class="nav-number">1.45.</span> <span class="nav-text">documentFragment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.46.</span> <span class="nav-text">创建对象的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%AF%B9%E8%B1%A1-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-%E5%AE%BF%E4%B8%BB%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.47.</span> <span class="nav-text">本地对象 内置对象 宿主对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPA"><span class="nav-number">1.48.</span> <span class="nav-text">SPA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JQ%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="nav-number">1.49.</span> <span class="nav-text">JQ链式调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="nav-number">1.50.</span> <span class="nav-text">网页渲染过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="nav-number">1.51.</span> <span class="nav-text">获取元素属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.52.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css%E6%9D%83%E9%87%8D"><span class="nav-number">1.53.</span> <span class="nav-text">css权重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#delete%E4%B8%8Evue-delete"><span class="nav-number">1.54.</span> <span class="nav-text">delete与vue.delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.55.</span> <span class="nav-text">盒子模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javaScript%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.56.</span> <span class="nav-text">javaScript的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON%E6%96%B9%E6%B3%95"><span class="nav-number">1.57.</span> <span class="nav-text">JSON方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">1.58.</span> <span class="nav-text">http状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%9C%86%E8%A7%92"><span class="nav-number">1.59.</span> <span class="nav-text">最后一个圆角</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#document-reday%E4%B8%8Ewindow-onload%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.60.</span> <span class="nav-text">document.reday与window.onload的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if%E6%9C%89%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%90%97"><span class="nav-number">1.61.</span> <span class="nav-text">if有作用域吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-x2F-%E7%8A%B6%E6%80%81"><span class="nav-number">1.62.</span> <span class="nav-text">ajax生命周期&#x2F;状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5"><span class="nav-number">1.63.</span> <span class="nav-text">同步异步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9Dcookie%E5%92%8C%E6%8C%81%E4%B9%85cookie"><span class="nav-number">1.64.</span> <span class="nav-text">会话cookie和持久cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.65.</span> <span class="nav-text">typeof返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="nav-number">1.66.</span> <span class="nav-text">获取时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#url%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="nav-number">1.67.</span> <span class="nav-text">url请求过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.68.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98"><span class="nav-number">1.69.</span> <span class="nav-text">回流和重绘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98"><span class="nav-number">1.70.</span> <span class="nav-text">如何减少回流和重绘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GET-%E5%92%8C-POST"><span class="nav-number">1.71.</span> <span class="nav-text">GET 和 POST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">1.72.</span> <span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.73.</span> <span class="nav-text">深拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.74.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.75.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="nav-number">1.76.</span> <span class="nav-text">事件冒泡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#H5%E6%96%B0%E6%A0%87%E7%AD%BE"><span class="nav-number">1.77.</span> <span class="nav-text">H5新标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="nav-number">1.78.</span> <span class="nav-text">浏览器内核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F"><span class="nav-number">1.79.</span> <span class="nav-text">跨域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjs"><span class="nav-number">1.80.</span> <span class="nav-text">异步加载js</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#px%EF%BC%8Cem%E5%92%8Crem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.81.</span> <span class="nav-text">px，em和rem的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#link%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.82.</span> <span class="nav-text">link和@import的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.83.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#img-%E4%B8%AD-title%E5%92%8Calt%E5%8C%BA%E5%88%AB"><span class="nav-number">1.84.</span> <span class="nav-text">img 中 title和alt区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM%E4%B8%8EBOM%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.85.</span> <span class="nav-text">DOM与BOM分别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="nav-number">1.86.</span> <span class="nav-text">数组去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%86%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.87.</span> <span class="nav-text">区分数组对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.88.</span> <span class="nav-text">反转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="nav-number">1.89.</span> <span class="nav-text">事件委托</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="nav-number">1.90.</span> <span class="nav-text">原型对象和对象的原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.91.</span> <span class="nav-text">形参和实参是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arguments%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.92.</span> <span class="nav-text">arguments是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.93.</span> <span class="nav-text">解决跨域的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.94.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E6%8A%BD%E8%B1%A1%E3%80%82"><span class="nav-number">1.94.0.0.0.1.</span> <span class="nav-text">面向对象的特征：封装、继承、多态、抽象。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">1.95.</span> <span class="nav-text">原型 原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E5%90%91%E7%9A%84%E6%83%85%E5%86%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.96.</span> <span class="nav-text">this指向的情况有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.97.</span> <span class="nav-text">Null和undefined的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.98.</span> <span class="nav-text">Call、apply、bind的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOCtype-document-type-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.99.</span> <span class="nav-text">DOCtype(document type)的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS%E8%AF%AD%E8%A8%80%E4%B8%BB%E8%A6%81%E5%88%86%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86-%E4%B8%89%E9%83%A8%E5%88%86"><span class="nav-number">1.100.</span> <span class="nav-text">JS语言主要分哪几部分 三部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.101.</span> <span class="nav-text">原型对象、实例对象、构造函数三者之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E8%87%AA%E8%BA%AB%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%AD%A4%E5%B1%9E%E6%80%A7"><span class="nav-number">1.102.</span> <span class="nav-text">判断对象自身是否包含此属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.103.</span> <span class="nav-text">认识函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.104.</span> <span class="nav-text">JavaScript数组常用方法有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E8%87%B4JavaScript%E4%B8%ADthis%E6%8C%87%E5%90%91%E6%B7%B7%E4%B9%B1%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.105.</span> <span class="nav-text">导致JavaScript中this指向混乱的原因是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="nav-number">1.105.0.0.0.1.</span> <span class="nav-text">1、函数调用方式不同：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">1.105.0.0.0.2.</span> <span class="nav-text">2、箭头函数的使用：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8apply%E3%80%81call%E3%80%81bind%E6%96%B9%E6%B3%95"><span class="nav-number">1.105.0.0.0.3.</span> <span class="nav-text">3、使用apply、call、bind方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B5%8C%E5%A5%97%E5%92%8C%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="nav-number">1.105.0.0.0.4.</span> <span class="nav-text">4、对象的嵌套和继承：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8"><span class="nav-number">1.106.</span> <span class="nav-text">怎么实现虚拟列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E8%BD%AE%E8%AF%A2%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.107.</span> <span class="nav-text">说说对轮询的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AE%E8%AF%A2"><span class="nav-number">1.107.0.0.0.1.</span> <span class="nav-text">什么是轮询</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.107.0.0.0.2.</span> <span class="nav-text">轮询和长轮询有什么区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88"><span class="nav-number">1.107.0.0.0.3.</span> <span class="nav-text">前端轮询的实现方法有什么</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9"><span class="nav-number">1.107.0.0.0.4.</span> <span class="nav-text">轮询有什么缺点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BD%AE%E8%AF%A2%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.107.0.0.0.5.</span> <span class="nav-text">如何避免轮询的缺点</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="nav-number">1.108.</span> <span class="nav-text">作用域和作用域链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.108.1.</span> <span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.108.1.0.0.1.</span> <span class="nav-text">全局作用域</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.108.1.0.0.2.</span> <span class="nav-text">函数作用域</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.108.1.0.0.3.</span> <span class="nav-text">块级作用域</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.108.2.</span> <span class="nav-text">词法作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="nav-number">1.108.3.</span> <span class="nav-text">作用域链</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.109.</span> <span class="nav-text">ES6有哪些新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81let%E3%80%81const-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%92%8C-var-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.109.1.</span> <span class="nav-text">1、let、const 块级作用域以及和 var 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%A7%A3%E6%9E%84-%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8F%96%E6%95%B0%E7%BB%84-x2F-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">1.109.2.</span> <span class="nav-text">2、解构-快速提取数组&#x2F;对象中的元素</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="nav-number">1.109.2.0.0.1.</span> <span class="nav-text">数组解构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="nav-number">1.109.2.0.0.2.</span> <span class="nav-text">对象解构</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.109.3.</span> <span class="nav-text">3、模板字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="nav-number">1.109.4.</span> <span class="nav-text">4、字符串扩展方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC-amp-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="nav-number">1.109.5.</span> <span class="nav-text">5、参数默认值&amp;剩余参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E5%B1%95%E5%BC%80%E6%95%B0%E7%BB%84"><span class="nav-number">1.109.6.</span> <span class="nav-text">6、展开数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">1.109.7.</span> <span class="nav-text">7、箭头函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E6%80%A7-amp-%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="nav-number">1.109.7.0.0.1.</span> <span class="nav-text">特性&amp;优势：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E5%A2%9E%E5%BC%BA"><span class="nav-number">1.109.8.</span> <span class="nav-text">8、对象字面量增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81Object-assign-target1-target2-targetN-%E5%A4%8D%E5%88%B6-x2F-%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.109.9.</span> <span class="nav-text">9、Object.assign(target1, target2, targetN)-复制&#x2F;合并对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81Object-is-value1-value2"><span class="nav-number">1.109.10.</span> <span class="nav-text">10、Object.is(value1, value2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81Proxy-object-handler"><span class="nav-number">1.109.11.</span> <span class="nav-text">11、Proxy(object, handler)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Reflect"><span class="nav-number">1.109.12.</span> <span class="nav-text">12.Reflect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Promise"><span class="nav-number">1.109.13.</span> <span class="nav-text">13.Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-class-amp-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-amp-%E7%BB%A7%E6%89%BF"><span class="nav-number">1.109.14.</span> <span class="nav-text">14.class&amp;静态方法&amp;继承</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.109.14.0.0.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">1.109.14.0.0.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%9A%E5%AD%90%E7%B1%BB%E4%BD%BF%E7%94%A8-extends-%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="nav-number">1.109.14.0.0.3.</span> <span class="nav-text">继承：子类使用 extends 关键字实现继承，可以继承父类所有属性</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-Set"><span class="nav-number">1.109.15.</span> <span class="nav-text">15.Set</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="nav-number">1.109.15.0.0.1.</span> <span class="nav-text">说明：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="nav-number">1.109.15.0.0.2.</span> <span class="nav-text">特性：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E9%80%94%EF%BC%9A"><span class="nav-number">1.109.15.0.0.3.</span> <span class="nav-text">用途：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-Map"><span class="nav-number">1.109.16.</span> <span class="nav-text">16.Map</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A-1"><span class="nav-number">1.109.16.0.0.1.</span> <span class="nav-text">说明：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">1.109.16.0.0.2.</span> <span class="nav-text">区别：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.109.16.0.0.3.</span> <span class="nav-text">实例：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-Symbol"><span class="nav-number">1.109.17.</span> <span class="nav-text">17.Symbol</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A-2"><span class="nav-number">1.109.17.0.0.1.</span> <span class="nav-text">说明：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="nav-number">1.109.17.0.0.2.</span> <span class="nav-text">作用：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-for%E2%80%A6of%E2%80%A6"><span class="nav-number">1.109.18.</span> <span class="nav-text">18.for…of…</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E9%80%94%EF%BC%9A-1"><span class="nav-number">1.109.18.0.0.1.</span> <span class="nav-text">用途：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9A-1"><span class="nav-number">1.109.18.0.0.2.</span> <span class="nav-text">特性：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A-1"><span class="nav-number">1.109.18.0.0.3.</span> <span class="nav-text">实例：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.109.19.</span> <span class="nav-text">19. 迭代器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A-1"><span class="nav-number">1.109.19.0.0.1.</span> <span class="nav-text">作用：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87-for%E2%80%A6of%E2%80%A6%E5%8E%BB%E8%BF%AD%E4%BB%A3%E5%86%85%E9%83%A8%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">1.109.19.0.0.2.</span> <span class="nav-text">外部可以通过 for…of…去迭代内部的数据</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20%E3%80%81Generator%E5%87%BD%E6%95%B0"><span class="nav-number">1.109.20.</span> <span class="nav-text">20、Generator函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-includes-%E5%87%BD%E6%95%B0-es2016"><span class="nav-number">1.109.21.</span> <span class="nav-text">21.includes 函数-es2016</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E8%BF%90%E7%AE%97%E7%AC%A6-es2016"><span class="nav-number">1.109.22.</span> <span class="nav-text">22. 运算符-es2016</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-values-%E5%87%BD%E6%95%B0-es2017"><span class="nav-number">1.109.23.</span> <span class="nav-text">23.values 函数-es2017</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-entries-%E5%87%BD%E6%95%B0-es2017"><span class="nav-number">1.109.24.</span> <span class="nav-text">24.entries 函数-es2017</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-Object-getOwnPropertyDescriptors-obj-es2017"><span class="nav-number">1.109.25.</span> <span class="nav-text">25.Object.getOwnPropertyDescriptors(obj)-es2017</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-padStart-padEnd-%E5%87%BD%E6%95%B0-es2017"><span class="nav-number">1.109.26.</span> <span class="nav-text">26.padStart, padEnd 函数-es2017</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="nav-number">1.109.26.0.0.1.</span> <span class="nav-text">参数：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%84%E5%88%99%EF%BC%9A"><span class="nav-number">1.109.26.0.0.2.</span> <span class="nav-text">规则：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A-2"><span class="nav-number">1.109.26.0.0.3.</span> <span class="nav-text">作用：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">1.110.</span> <span class="nav-text">函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.110.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.110.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.110.3.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">1.110.3.0.0.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">1.110.3.0.0.2.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie%E3%80%81localStorage%E5%92%8CsessionStorage-%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.111.</span> <span class="nav-text">cookie、localStorage和sessionStorage 三者之间有什么区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.111.1.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.111.2.</span> <span class="nav-text">存放数据大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%93%E7%94%A8%E6%80%A7"><span class="nav-number">1.111.3.</span> <span class="nav-text">易用性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%EF%BC%8C%E5%90%84%E7%A7%8D%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">1.112.</span> <span class="nav-text">浏览器有哪几种缓存，各种缓存的优先级是什么样的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="nav-number">1.112.1.</span> <span class="nav-text">强制缓存：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="nav-number">1.112.2.</span> <span class="nav-text">协商缓存：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Service-Worker-%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="nav-number">1.112.3.</span> <span class="nav-text">Service Worker 缓存：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-Storage-%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="nav-number">1.112.4.</span> <span class="nav-text">Web Storage 缓存：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%99%E4%BA%9B%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">1.112.5.</span> <span class="nav-text">这些缓存的优先级如下：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E6%8F%90%E9%80%9F"><span class="nav-number">1.113.</span> <span class="nav-text">项目首屏提速</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%84%9F%E7%9F%A5%E6%8F%90%E9%80%9F"><span class="nav-number">1.113.1.</span> <span class="nav-text">用户感知提速</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E5%8A%A0%E8%BD%BD%E6%8F%90%E9%80%9F"><span class="nav-number">1.113.2.</span> <span class="nav-text">技术加载提速</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css%E5%85%83%E7%B4%A0%E9%9A%90%E8%97%8F"><span class="nav-number">1.114.</span> <span class="nav-text">css元素隐藏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD"><span class="nav-number">1.115.</span> <span class="nav-text">css元素居中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#em%E5%92%8Crem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.116.</span> <span class="nav-text">em和rem的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#em"><span class="nav-number">1.116.0.0.0.1.</span> <span class="nav-text">em</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#rem"><span class="nav-number">1.116.0.0.0.2.</span> <span class="nav-text">rem</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP1-0%E5%92%8CHTTP2-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.117.</span> <span class="nav-text">HTTP1.0和HTTP2.0的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8"><span class="nav-number">1.117.0.0.0.1.</span> <span class="nav-text">1、连接复用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%96%B9%E5%BC%8F"><span class="nav-number">1.117.0.0.0.2.</span> <span class="nav-text">2、请求-响应方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="nav-number">1.117.0.0.0.3.</span> <span class="nav-text">3、头部压缩</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.117.0.0.0.4.</span> <span class="nav-text">4、二进制协议</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E6%B5%81%E6%8E%A7%E5%88%B6%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.117.0.0.0.5.</span> <span class="nav-text">5、流控制和优先级</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%94%AF%E6%8C%81"><span class="nav-number">1.117.0.0.0.6.</span> <span class="nav-text">6、长连接支持</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88DFS%EF%BC%89%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.118.</span> <span class="nav-text">（DFS）深度优先搜索算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS%EF%BC%88%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.119.</span> <span class="nav-text">BFS（宽度优先算法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.120.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.121.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.122.</span> <span class="nav-text">JavaScript中常见的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Queue-%E9%98%9F%E5%88%97"><span class="nav-number">1.122.0.0.0.1.</span> <span class="nav-text">Queue 队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Stack-%E6%A0%88"><span class="nav-number">1.122.0.0.0.2.</span> <span class="nav-text">Stack 栈</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Linked-List-%E9%93%BE%E8%A1%A8"><span class="nav-number">1.122.0.0.0.3.</span> <span class="nav-text">Linked List 链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.122.0.0.0.4.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.122.0.0.0.5.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.122.0.0.0.6.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.122.0.0.0.7.</span> <span class="nav-text">堆</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#es6%E4%B8%ADmap%E5%92%8Cobject%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.123.</span> <span class="nav-text">es6中map和object的区别是什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue"><span class="nav-number">2.</span> <span class="nav-text">Vue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.</span> <span class="nav-text">Vue的最大优势是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVVM%E5%92%8CMVC%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.2.</span> <span class="nav-text">MVVM和MVC区别是什么?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MVC-%EF%BC%9A-%E4%BC%A0%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="nav-number">2.2.1.</span> <span class="nav-text">MVC ： 传统的设计模式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVVM%EF%BC%9A-vue%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">MVVM： vue所使用的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E5%9C%A8vue%E4%B8%AD%EF%BC%8C%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9B%B4%E6%8E%A5%E6%89%8B%E5%8A%A8%E6%93%8D%E4%BD%9CDOM%EF%BC%81%EF%BC%81%EF%BC%81"><span class="nav-number">2.2.2.0.0.1.</span> <span class="nav-text">1. 在vue中，不推荐直接手动操作DOM！！！</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E5%9C%A8vue%E4%B8%AD%EF%BC%8C%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%83%B3%E7%9D%80%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9CDOM%EF%BC%8C%E8%80%8C%E6%98%AF%E6%83%B3%E7%9D%80%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81%EF%BC%81-%E6%80%9D%E6%83%B3%E8%BD%AC%E5%8F%98"><span class="nav-number">2.2.2.0.0.2.</span> <span class="nav-text">2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！(思想转变)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">vue第一次加载页面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.4.</span> <span class="nav-text">Vue常用修饰符有哪些?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9Vue%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.5.</span> <span class="nav-text">对Vue渐进式的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.6.</span> <span class="nav-text">vue 生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E5%87%BA%E8%87%B3%E5%B0%914%E4%B8%AAVue%E6%8C%87%E4%BB%A4%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">2.7.</span> <span class="nav-text">说出至少4个Vue指令及作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%BF%E5%85%8Dv-for%E5%92%8Cv-if%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-number">2.8.</span> <span class="nav-text">为什么避免v-for和v-if在一起使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-if%E4%B8%8Ev-show%E5%8C%BA%E5%88%AB%E9%80%90%E5%AD%97%E7%A8%BF"><span class="nav-number">2.9.</span> <span class="nav-text">v-if与v-show区别逐字稿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E4%B8%ADkey%E5%80%BC%E4%BD%9C%E7%94%A8"><span class="nav-number">2.10.</span> <span class="nav-text">Vue中key值作用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BD%A0%E5%A5%BD-%E6%88%91%E6%98%AF%E8%BF%99%E4%B9%88%E7%90%86%E8%A7%A3key%E5%80%BC%E7%9A%84-key%E5%80%BC%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E6%98%AF%E7%BB%99%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6-%E7%94%A8%E4%BA%8E%E6%8F%90%E9%AB%98vue%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD-%E5%BD%93data%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99-vue%E4%BC%9A%E4%BD%BF%E7%94%A8diff%E7%AE%97%E6%B3%95%E6%9D%A5%E5%AF%B9%E6%AF%94%E6%96%B0%E6%97%A7%E8%99%9A%E6%8B%9FDOM-%E5%A6%82%E6%9E%9Ckey%E5%80%BC%E7%9B%B8%E5%90%8C-%E6%89%8D%E4%BC%9A%E8%80%83%E8%99%91%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-%E5%A6%82%E6%9E%9Ckey%E5%80%BC%E4%B8%8D%E5%90%8C-%E5%88%99%E4%BC%9A%E5%BC%BA%E5%88%B6%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0-%E4%B8%80%E8%88%AC%E9%80%9A%E8%BF%87%E7%BB%99%E5%85%83%E7%B4%A0key%E8%AE%BE%E7%BD%AE%E4%B8%BAid-%E6%9D%A5%E4%BF%9D%E8%AF%81vue%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E6%9C%80%E5%A4%A7%E9%99%90%E5%BA%A6%E5%A4%8D%E7%94%A8%E7%9B%B8%E5%90%8C%E7%9A%84key%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">2.10.0.0.0.1.</span> <span class="nav-text">面试官你好,我是这么理解key值的,key值的主要作用是给元素添加一个唯一标识符,用于提高vue渲染性能,当data发生变化的时候,vue会使用diff算法来对比新旧虚拟DOM.如果key值相同,才会考虑复用元素.如果key值不同,则会强制更新元素.一般通过给元素key设置为id,来保证vue更新数据的时候可以最大限度复用相同的key值的元素.</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-for%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8key%E5%80%BC%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">2.11.</span> <span class="nav-text">v-for指令使用key值几种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E4%B8%AD-key%E4%BD%9C%E7%94%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">2.12.</span> <span class="nav-text">Vue中:key作用, 为什么不能用索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-model%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="nav-number">2.13.</span> <span class="nav-text">v-model的作用及原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E4%B8%AD%E6%9C%89%E6%97%B6%E5%80%99%E6%95%B0%E7%BB%84%E4%BC%9A%E6%9B%B4%E6%96%B0%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%9C%89%E6%97%B6%E5%80%99%E4%B8%8D%E6%9B%B4%E6%96%B0%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">2.14.</span> <span class="nav-text">Vue中有时候数组会更新页面，有时候不更新，这是为什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E4%B8%8B%E5%B0%81%E8%A3%85-vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.15.</span> <span class="nav-text">请说下封装 vue 组件的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC"><span class="nav-number">2.16.</span> <span class="nav-text">vue组件传值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%BB%84%E4%BB%B6-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0"><span class="nav-number">2.17.</span> <span class="nav-text">Vue 组件 data 为什么必须是函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">2.18.</span> <span class="nav-text">讲一下组件的命名规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scoped%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-number">2.19.</span> <span class="nav-text">scoped作用与原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%9A%84-nextTick-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.20.</span> <span class="nav-text">Vue 的 nextTick 的原理是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BF%AE%E6%94%B9%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">2.21.</span> <span class="nav-text">子组件修改父组件的数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="nav-number">2.22.</span> <span class="nav-text">vue事件冒泡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="nav-number">2.23.</span> <span class="nav-text">响应式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E6%A7%BD"><span class="nav-number">2.24.</span> <span class="nav-text">插槽</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-show-v-if"><span class="nav-number">2.25.</span> <span class="nav-text">v-show  v-if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-%EF%BC%88%E5%BF%85%E4%BC%9A%EF%BC%89"><span class="nav-number">2.26.</span> <span class="nav-text">自定义指令的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E8%B7%AF%E7%94%B1%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-number">2.27.</span> <span class="nav-text">vue路由作用与原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%B3%E8%BD%AC%E7%9A%84%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="nav-number">2.28.</span> <span class="nav-text">路由之间是怎么跳转的？有哪些方式?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E7%94%A8%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E6%97%B6%E5%80%99%E9%98%B2%E6%AD%A2%E5%88%B7%E6%96%B0%E7%99%BD%E5%B1%8F"><span class="nav-number">2.29.</span> <span class="nav-text">再用动态路由的时候防止刷新白屏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-router%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%EF%BC%88%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%85%AD%E4%B8%AA%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="nav-number">2.30.</span> <span class="nav-text">vue-router怎么配置路由（路由配置六个流程）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-router%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%EF%BC%89"><span class="nav-number">2.31.</span> <span class="nav-text">vue-router的钩子函数都有哪些（导航守卫）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="nav-number">2.32.</span> <span class="nav-text">完整的导航解析流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%EF%BC%9F"><span class="nav-number">2.33.</span> <span class="nav-text">什么是路由守卫？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="nav-number">2.34.</span> <span class="nav-text">路由传值的方式有哪几种</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%A5%E6%94%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="nav-number">2.35.</span> <span class="nav-text">Vue路由传参方式，如何接收对应的值？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%BC%8F%EF%BC%9Ahash%E6%A8%A1%E5%BC%8F%E5%92%8Chistory%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.36.</span> <span class="nav-text">Vue的路由实现模式：hash模式和history模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E9%A1%B9%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">2.37.</span> <span class="nav-text">请说出路由配置项常用的属性及作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#route%E5%92%8C-router%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.38.</span> <span class="nav-text">$route和$router的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keep-alive"><span class="nav-number">2.39.</span> <span class="nav-text">keep-alive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%9Fkeep-alive%E6%9C%89%E5%85%B3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.40.</span> <span class="nav-text">跟keep-alive有关的生命周期是哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vuex%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BA%94%E5%A4%A7%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">2.41.</span> <span class="nav-text">vuex作用及五大组成部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vuex%E4%B8%ADaction%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.42.</span> <span class="nav-text">vuex中action工作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vuex%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">2.43.</span> <span class="nav-text">vuex刷新页面丢失数据原因和解决方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%9C%A8vue%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91"><span class="nav-number">2.44.</span> <span class="nav-text">说一下你在vue中踩过的坑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">小程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.1.</span> <span class="nav-text">小程序的登录流程是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E5%85%81%E8%AE%B8%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BD%93%E7%A7%AF%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-number">3.2.</span> <span class="nav-text">小程序项目允许的最大体积是多少</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%99%AE%E9%80%9A%E7%BD%91%E9%A1%B5%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">小程序和普通网页区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%84%E6%88%90"><span class="nav-number">3.4.</span> <span class="nav-text">小程序的项目构成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">3.5.</span> <span class="nav-text">小程序页面的组成部分**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#app-json%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.6.</span> <span class="nav-text">## app.json中的配置有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#window%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.7.</span> <span class="nav-text">window配置中的配置项有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tabBar%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.8.</span> <span class="nav-text">tabBar配置中的配置项有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89tabBar"><span class="nav-number">3.9.</span> <span class="nav-text">如何自定义tabBar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#networkTimeout%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.10.</span> <span class="nav-text">networkTimeout配置中的配置项有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93"><span class="nav-number">3.11.</span> <span class="nav-text">小程序渲染数据如何渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E7%9A%84%E6%8C%87%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.12.</span> <span class="nav-text">列表渲染的指令是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9item%E5%92%8Cindex%E7%9A%84%E5%90%8D%E5%AD%97"><span class="nav-number">3.13.</span> <span class="nav-text">列表渲染如何修改item和index的名字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E5%8F%AF%E4%BB%A5%E6%B8%B2%E6%9F%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.14.</span> <span class="nav-text">列表渲染可以渲染的数据类型有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.15.</span> <span class="nav-text">block标签的作用是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9"><span class="nav-number">3.16.</span> <span class="nav-text">小程序中如何实现响应式的数据修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.17.</span> <span class="nav-text">小程序生命周期函数有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BA%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.18.</span> <span class="nav-text">页面级生命周期函数有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%BA%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.19.</span> <span class="nav-text">组件级生命周期函数有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.20.</span> <span class="nav-text">组件的主要生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#input%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%BA%BF%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="nav-number">3.21.</span> <span class="nav-text">input组件如何实现双线数据绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#input%E7%BB%84%E4%BB%B6%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E9%94%AE%E7%9B%98%E5%8F%B3%E4%B8%8B%E8%A7%92%E6%96%87%E5%AD%97%E6%8F%90%E7%A4%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E6%88%90%E5%93%AA%E4%BA%9B%E5%80%BC"><span class="nav-number">3.22.</span> <span class="nav-text">input组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#input%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E9%94%AE%E7%9B%98%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.23.</span> <span class="nav-text">input组件中有几种键盘类型，分别是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scroll-view%E7%BB%84%E4%BB%B6%E6%83%B3%E8%A6%81%E7%BA%B5%E5%90%91%E6%BB%9A%E5%8A%A8%E6%97%B6%EF%BC%8C%E5%BF%85%E9%A1%BB%E8%A6%81%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%86%85%E5%AE%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.24.</span> <span class="nav-text">scroll-view组件想要纵向滚动时，必须要设置的内容有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#navigator%E7%BB%84%E4%BB%B6%E7%9A%84%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.25.</span> <span class="nav-text">navigator组件的跳转方式有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#navigate%E5%92%8C-redirect%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">3.26.</span> <span class="nav-text">navigate和 redirect方式有什么区别，共同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#navigate%E5%92%8C-switchTab-%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">3.27.</span> <span class="nav-text">navigate和 switchTab 方式有什么区别，共同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#navigate%E5%92%8C-reLaunch-%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">3.28.</span> <span class="nav-text">navigate和 reLaunch 方式有什么区别，共同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E7%BB%84%E4%BB%B6%E6%98%AF%E5%90%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%AE%BD%E9%AB%98%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%AE%BD%E9%AB%98%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-number">3.29.</span> <span class="nav-text">图片组件是否有默认宽高，默认宽高是多少?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wxss%E5%92%8Ccss%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.30.</span> <span class="nav-text">wxss和css的不同之处有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">3.31.</span> <span class="nav-text">小程序有几种绑定事件的方式，有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6%E6%9C%89%E5%93%AA%EF%BC%8C%E8%AF%B4%E5%87%BA5%E4%B8%AA%E4%BB%A5%E4%B8%8A"><span class="nav-number">3.32.</span> <span class="nav-text">常见移动端事件有哪，说出5个以上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.33.</span> <span class="nav-text">触摸事件的事件对象中有哪些常见属性，作用是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#target-%E5%92%8CcurrentTarget%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.34.</span> <span class="nav-text">target 和currentTarget两者的区别是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="nav-number">3.35.</span> <span class="nav-text">小程序中的事件如何传递数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-number">3.36.</span> <span class="nav-text">小程序中全局数据如何使用，有什么特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6"><span class="nav-number">3.37.</span> <span class="nav-text">如何自定义一个组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%A0%B7%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E7%9A%84"><span class="nav-number">3.38.</span> <span class="nav-text">关于父子组件之间样式是如何影响的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%96%E9%83%A8%E6%A0%B7%E5%BC%8F%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.39.</span> <span class="nav-text">组件的外部样式类如何设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%83%B3%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8F%92%E6%A7%BD%E4%BD%BF%E7%94%A8%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.40.</span> <span class="nav-text">小程序想要实现多个插槽使用如何设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E5%80%BC%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="nav-number">3.41.</span> <span class="nav-text">父组件如何传值给子组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E5%80%BC%E7%BB%99%E7%88%B6%E7%BB%84%E4%BB%B6"><span class="nav-number">3.42.</span> <span class="nav-text">子组件如何传值给父组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E7%BA%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.43.</span> <span class="nav-text">组件如何监听页面级生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E4%BA%A4%E4%BA%92API%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.44.</span> <span class="nav-text">小程序中的交互API有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%9F%9F%E5%90%8D%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">3.45.</span> <span class="nav-text">小程序中域名无法识别如何处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%99%90%E5%88%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%90%88%E6%B3%95%E5%9F%9F%E5%90%8D%EF%BC%9F"><span class="nav-number">3.46.</span> <span class="nav-text">网络请求限制，如何配置合法域名？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%ADbase64%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.47.</span> <span class="nav-text">小程序中base64与二进制数据流之间的转换如何转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%EF%BC%9F"><span class="nav-number">3.48.</span> <span class="nav-text">你是怎么封装微信小程序的数据请求的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">3.49.</span> <span class="nav-text">小程序支付如何实现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8C%85"><span class="nav-number">3.50.</span> <span class="nav-text">小程序如何进行分包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%88%86%E5%8C%85%E5%92%8C%E7%8B%AC%E7%AB%8B%E5%88%86%E5%8C%85%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">3.51.</span> <span class="nav-text">普通分包和独立分包有什么不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.52.</span> <span class="nav-text">分包有哪些注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uni-app"><span class="nav-number">4.</span> <span class="nav-text">uni-app</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#uni-app%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF"><span class="nav-number">4.1.</span> <span class="nav-text">uni-app有哪些优势?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uni-app%E8%AF%AD%E6%B3%95%E3%80%81%E7%BB%84%E4%BB%B6-%E5%8F%8A-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E7%9A%84-%E7%9B%B8%E5%90%8C%E4%B9%8B%E5%A4%84%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">uni-app语法、组件 及 生命周期 的 相同之处？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#uni-app%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%EF%BC%9F"><span class="nav-number">4.2.0.1.</span> <span class="nav-text">uni-app的不同之处？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B0%81%E8%A3%85"><span class="nav-number">4.3.</span> <span class="nav-text">网络封装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue3"><span class="nav-number">5.</span> <span class="nav-text">Vue3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vue2%E5%92%8CVue3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">vue2和Vue3的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80-%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%8D%E5%90%8C"><span class="nav-number">5.1.0.0.0.1.</span> <span class="nav-text">一. 根节点不同</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C-%E7%BB%84%E5%90%88%E5%BC%8FAPI%E5%92%8C%E9%80%89%E9%A1%B9%E5%BC%8FAPI"><span class="nav-number">5.1.0.0.0.2.</span> <span class="nav-text">二. 组合式API和选项式API</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%89-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">5.1.0.0.0.3.</span> <span class="nav-text">三. 生命周期的变化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%9B-v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">5.1.0.0.0.4.</span> <span class="nav-text">四. v-if和v-for的优先级</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%94-diff%E7%AE%97%E6%B3%95%E4%B8%8D%E5%90%8C"><span class="nav-number">5.1.0.0.0.5.</span> <span class="nav-text">五. diff算法不同</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%AD-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B8%8D%E5%90%8C"><span class="nav-number">5.1.0.0.0.6.</span> <span class="nav-text">六. 响应式原理不同</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9Avue3%E7%9B%B8%E5%85%B3%E8%AF%B7%E6%9F%A5%E7%9C%8B-http-liuminghao-top"><span class="nav-number">5.2.</span> <span class="nav-text">更多vue3相关请查看 http:&#x2F;&#x2F;liuminghao.top</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;2023
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">刘小烨</a>
                
            </div>

            <div class="theme-info info-item default">
                Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.7.3</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            

            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript"><span class="nav-number">1.</span> <span class="nav-text">JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">普通函数与箭头函数的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generator%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">Generator函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFPromise"><span class="nav-number">1.3.</span> <span class="nav-text">什么是Promise?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.4.</span> <span class="nav-text">promise的使用场景?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">什么是回调地狱？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9this%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">对this的理解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.7.</span> <span class="nav-text">什么是事件循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.8.</span> <span class="nav-text">事件循环机制的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%9C%BA%E5%88%B6-%E4%B9%9F%E5%8F%AB%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%88eventLoop%EF%BC%89"><span class="nav-number">1.9.</span> <span class="nav-text">事件轮询的机制 也叫事件循环的机制（eventLoop）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-in%E5%92%8Cfor-of%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.10.</span> <span class="nav-text">for in和for of区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.11.</span> <span class="nav-text">new一个对象的过程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="nav-number">1.12.</span> <span class="nav-text">什么是闭包？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">1.13.</span> <span class="nav-text">什么是堆内存和栈内存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%EF%BC%9F"><span class="nav-number">1.14.</span> <span class="nav-text">节流和防抖？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="nav-number">1.15.</span> <span class="nav-text">哪些数组方法可以改变原数组？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="nav-number">1.16.</span> <span class="nav-text">虚拟DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E4%B8%80%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">1.17.</span> <span class="nav-text">谈一谈垃圾回收机制?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#less-%E5%92%8C-sass-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.18.</span> <span class="nav-text">less 和 sass 的区别 ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.19.</span> <span class="nav-text">CSS预处理器是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="nav-number">1.20.</span> <span class="nav-text">纯函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.21.</span> <span class="nav-text">浏览器的同源策略机制?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#token%E4%B8%80%E8%88%AC%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AD%98%E6%94%BE%E5%9C%A8cookie%E5%86%85"><span class="nav-number">1.22.</span> <span class="nav-text">token一般存放在哪里?为什么不存放在cookie内?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#token%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.23.</span> <span class="nav-text">token是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%9D%A10-5%E5%83%8F%E7%B4%A0%E7%9A%84%E7%BA%BF"><span class="nav-number">1.24.</span> <span class="nav-text">如何实现一条0.5像素的线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.25.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async-x2F-await"><span class="nav-number">1.26.</span> <span class="nav-text">async&#x2F;await</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#transform%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.27.</span> <span class="nav-text">transform的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IE%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.28.</span> <span class="nav-text">IE盒模型和标准盒模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">1.29.</span> <span class="nav-text">css实现三角形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axios"><span class="nav-number">1.30.</span> <span class="nav-text">axios</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JQ%E4%B8%AD-%E7%AC%A6"><span class="nav-number">1.31.</span> <span class="nav-text">JQ中$()符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.32.</span> <span class="nav-text">普通函数和构造函数的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D"><span class="nav-number">1.33.</span> <span class="nav-text">浮动与定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">1.34.</span> <span class="nav-text">递归函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#label%E6%A0%87%E7%AD%BE"><span class="nav-number">1.35.</span> <span class="nav-text">label标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.36.</span> <span class="nav-text">ajax执行步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E9%80%89%E4%B8%ADcss"><span class="nav-number">1.37.</span> <span class="nav-text">最后一个元素选中css</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E6%AF%8D"><span class="nav-number">1.38.</span> <span class="nav-text">统计字符串中出现最多的字母</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="nav-number">1.39.</span> <span class="nav-text">自执行函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%B1%A1%E5%8C%BA%E5%88%AB"><span class="nav-number">1.40.</span> <span class="nav-text">数组 对象区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.41.</span> <span class="nav-text">元素绑定事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8B%89%E5%B9%B3"><span class="nav-number">1.42.</span> <span class="nav-text">数组拉平</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#postion%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.43.</span> <span class="nav-text">postion属性的值有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.44.</span> <span class="nav-text">静态方法 实例方法和原型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#documentFragment"><span class="nav-number">1.45.</span> <span class="nav-text">documentFragment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.46.</span> <span class="nav-text">创建对象的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%AF%B9%E8%B1%A1-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-%E5%AE%BF%E4%B8%BB%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.47.</span> <span class="nav-text">本地对象 内置对象 宿主对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPA"><span class="nav-number">1.48.</span> <span class="nav-text">SPA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JQ%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="nav-number">1.49.</span> <span class="nav-text">JQ链式调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="nav-number">1.50.</span> <span class="nav-text">网页渲染过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="nav-number">1.51.</span> <span class="nav-text">获取元素属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.52.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css%E6%9D%83%E9%87%8D"><span class="nav-number">1.53.</span> <span class="nav-text">css权重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#delete%E4%B8%8Evue-delete"><span class="nav-number">1.54.</span> <span class="nav-text">delete与vue.delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.55.</span> <span class="nav-text">盒子模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javaScript%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.56.</span> <span class="nav-text">javaScript的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON%E6%96%B9%E6%B3%95"><span class="nav-number">1.57.</span> <span class="nav-text">JSON方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">1.58.</span> <span class="nav-text">http状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%9C%86%E8%A7%92"><span class="nav-number">1.59.</span> <span class="nav-text">最后一个圆角</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#document-reday%E4%B8%8Ewindow-onload%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.60.</span> <span class="nav-text">document.reday与window.onload的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if%E6%9C%89%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%90%97"><span class="nav-number">1.61.</span> <span class="nav-text">if有作用域吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-x2F-%E7%8A%B6%E6%80%81"><span class="nav-number">1.62.</span> <span class="nav-text">ajax生命周期&#x2F;状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5"><span class="nav-number">1.63.</span> <span class="nav-text">同步异步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9Dcookie%E5%92%8C%E6%8C%81%E4%B9%85cookie"><span class="nav-number">1.64.</span> <span class="nav-text">会话cookie和持久cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.65.</span> <span class="nav-text">typeof返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="nav-number">1.66.</span> <span class="nav-text">获取时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#url%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="nav-number">1.67.</span> <span class="nav-text">url请求过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.68.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98"><span class="nav-number">1.69.</span> <span class="nav-text">回流和重绘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98"><span class="nav-number">1.70.</span> <span class="nav-text">如何减少回流和重绘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GET-%E5%92%8C-POST"><span class="nav-number">1.71.</span> <span class="nav-text">GET 和 POST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">1.72.</span> <span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.73.</span> <span class="nav-text">深拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.74.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.75.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="nav-number">1.76.</span> <span class="nav-text">事件冒泡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#H5%E6%96%B0%E6%A0%87%E7%AD%BE"><span class="nav-number">1.77.</span> <span class="nav-text">H5新标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="nav-number">1.78.</span> <span class="nav-text">浏览器内核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F"><span class="nav-number">1.79.</span> <span class="nav-text">跨域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjs"><span class="nav-number">1.80.</span> <span class="nav-text">异步加载js</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#px%EF%BC%8Cem%E5%92%8Crem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.81.</span> <span class="nav-text">px，em和rem的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#link%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.82.</span> <span class="nav-text">link和@import的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.83.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#img-%E4%B8%AD-title%E5%92%8Calt%E5%8C%BA%E5%88%AB"><span class="nav-number">1.84.</span> <span class="nav-text">img 中 title和alt区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM%E4%B8%8EBOM%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.85.</span> <span class="nav-text">DOM与BOM分别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="nav-number">1.86.</span> <span class="nav-text">数组去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%86%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.87.</span> <span class="nav-text">区分数组对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.88.</span> <span class="nav-text">反转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="nav-number">1.89.</span> <span class="nav-text">事件委托</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="nav-number">1.90.</span> <span class="nav-text">原型对象和对象的原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.91.</span> <span class="nav-text">形参和实参是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arguments%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.92.</span> <span class="nav-text">arguments是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.93.</span> <span class="nav-text">解决跨域的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.94.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E6%8A%BD%E8%B1%A1%E3%80%82"><span class="nav-number">1.94.0.0.0.1.</span> <span class="nav-text">面向对象的特征：封装、继承、多态、抽象。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">1.95.</span> <span class="nav-text">原型 原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E5%90%91%E7%9A%84%E6%83%85%E5%86%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.96.</span> <span class="nav-text">this指向的情况有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.97.</span> <span class="nav-text">Null和undefined的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.98.</span> <span class="nav-text">Call、apply、bind的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOCtype-document-type-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.99.</span> <span class="nav-text">DOCtype(document type)的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS%E8%AF%AD%E8%A8%80%E4%B8%BB%E8%A6%81%E5%88%86%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86-%E4%B8%89%E9%83%A8%E5%88%86"><span class="nav-number">1.100.</span> <span class="nav-text">JS语言主要分哪几部分 三部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.101.</span> <span class="nav-text">原型对象、实例对象、构造函数三者之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E8%87%AA%E8%BA%AB%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%AD%A4%E5%B1%9E%E6%80%A7"><span class="nav-number">1.102.</span> <span class="nav-text">判断对象自身是否包含此属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.103.</span> <span class="nav-text">认识函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.104.</span> <span class="nav-text">JavaScript数组常用方法有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E8%87%B4JavaScript%E4%B8%ADthis%E6%8C%87%E5%90%91%E6%B7%B7%E4%B9%B1%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.105.</span> <span class="nav-text">导致JavaScript中this指向混乱的原因是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="nav-number">1.105.0.0.0.1.</span> <span class="nav-text">1、函数调用方式不同：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">1.105.0.0.0.2.</span> <span class="nav-text">2、箭头函数的使用：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8apply%E3%80%81call%E3%80%81bind%E6%96%B9%E6%B3%95"><span class="nav-number">1.105.0.0.0.3.</span> <span class="nav-text">3、使用apply、call、bind方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B5%8C%E5%A5%97%E5%92%8C%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="nav-number">1.105.0.0.0.4.</span> <span class="nav-text">4、对象的嵌套和继承：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8"><span class="nav-number">1.106.</span> <span class="nav-text">怎么实现虚拟列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E8%BD%AE%E8%AF%A2%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.107.</span> <span class="nav-text">说说对轮询的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AE%E8%AF%A2"><span class="nav-number">1.107.0.0.0.1.</span> <span class="nav-text">什么是轮询</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.107.0.0.0.2.</span> <span class="nav-text">轮询和长轮询有什么区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88"><span class="nav-number">1.107.0.0.0.3.</span> <span class="nav-text">前端轮询的实现方法有什么</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9"><span class="nav-number">1.107.0.0.0.4.</span> <span class="nav-text">轮询有什么缺点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BD%AE%E8%AF%A2%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.107.0.0.0.5.</span> <span class="nav-text">如何避免轮询的缺点</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="nav-number">1.108.</span> <span class="nav-text">作用域和作用域链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.108.1.</span> <span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.108.1.0.0.1.</span> <span class="nav-text">全局作用域</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.108.1.0.0.2.</span> <span class="nav-text">函数作用域</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.108.1.0.0.3.</span> <span class="nav-text">块级作用域</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.108.2.</span> <span class="nav-text">词法作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="nav-number">1.108.3.</span> <span class="nav-text">作用域链</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.109.</span> <span class="nav-text">ES6有哪些新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81let%E3%80%81const-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%92%8C-var-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.109.1.</span> <span class="nav-text">1、let、const 块级作用域以及和 var 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%A7%A3%E6%9E%84-%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8F%96%E6%95%B0%E7%BB%84-x2F-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">1.109.2.</span> <span class="nav-text">2、解构-快速提取数组&#x2F;对象中的元素</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="nav-number">1.109.2.0.0.1.</span> <span class="nav-text">数组解构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="nav-number">1.109.2.0.0.2.</span> <span class="nav-text">对象解构</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.109.3.</span> <span class="nav-text">3、模板字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="nav-number">1.109.4.</span> <span class="nav-text">4、字符串扩展方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC-amp-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="nav-number">1.109.5.</span> <span class="nav-text">5、参数默认值&amp;剩余参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E5%B1%95%E5%BC%80%E6%95%B0%E7%BB%84"><span class="nav-number">1.109.6.</span> <span class="nav-text">6、展开数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">1.109.7.</span> <span class="nav-text">7、箭头函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E6%80%A7-amp-%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="nav-number">1.109.7.0.0.1.</span> <span class="nav-text">特性&amp;优势：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E5%A2%9E%E5%BC%BA"><span class="nav-number">1.109.8.</span> <span class="nav-text">8、对象字面量增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81Object-assign-target1-target2-targetN-%E5%A4%8D%E5%88%B6-x2F-%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.109.9.</span> <span class="nav-text">9、Object.assign(target1, target2, targetN)-复制&#x2F;合并对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81Object-is-value1-value2"><span class="nav-number">1.109.10.</span> <span class="nav-text">10、Object.is(value1, value2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81Proxy-object-handler"><span class="nav-number">1.109.11.</span> <span class="nav-text">11、Proxy(object, handler)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Reflect"><span class="nav-number">1.109.12.</span> <span class="nav-text">12.Reflect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Promise"><span class="nav-number">1.109.13.</span> <span class="nav-text">13.Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-class-amp-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-amp-%E7%BB%A7%E6%89%BF"><span class="nav-number">1.109.14.</span> <span class="nav-text">14.class&amp;静态方法&amp;继承</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.109.14.0.0.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">1.109.14.0.0.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%9A%E5%AD%90%E7%B1%BB%E4%BD%BF%E7%94%A8-extends-%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="nav-number">1.109.14.0.0.3.</span> <span class="nav-text">继承：子类使用 extends 关键字实现继承，可以继承父类所有属性</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-Set"><span class="nav-number">1.109.15.</span> <span class="nav-text">15.Set</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="nav-number">1.109.15.0.0.1.</span> <span class="nav-text">说明：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="nav-number">1.109.15.0.0.2.</span> <span class="nav-text">特性：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E9%80%94%EF%BC%9A"><span class="nav-number">1.109.15.0.0.3.</span> <span class="nav-text">用途：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-Map"><span class="nav-number">1.109.16.</span> <span class="nav-text">16.Map</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A-1"><span class="nav-number">1.109.16.0.0.1.</span> <span class="nav-text">说明：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">1.109.16.0.0.2.</span> <span class="nav-text">区别：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.109.16.0.0.3.</span> <span class="nav-text">实例：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-Symbol"><span class="nav-number">1.109.17.</span> <span class="nav-text">17.Symbol</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A-2"><span class="nav-number">1.109.17.0.0.1.</span> <span class="nav-text">说明：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="nav-number">1.109.17.0.0.2.</span> <span class="nav-text">作用：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-for%E2%80%A6of%E2%80%A6"><span class="nav-number">1.109.18.</span> <span class="nav-text">18.for…of…</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E9%80%94%EF%BC%9A-1"><span class="nav-number">1.109.18.0.0.1.</span> <span class="nav-text">用途：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9A-1"><span class="nav-number">1.109.18.0.0.2.</span> <span class="nav-text">特性：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A-1"><span class="nav-number">1.109.18.0.0.3.</span> <span class="nav-text">实例：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.109.19.</span> <span class="nav-text">19. 迭代器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A-1"><span class="nav-number">1.109.19.0.0.1.</span> <span class="nav-text">作用：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87-for%E2%80%A6of%E2%80%A6%E5%8E%BB%E8%BF%AD%E4%BB%A3%E5%86%85%E9%83%A8%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">1.109.19.0.0.2.</span> <span class="nav-text">外部可以通过 for…of…去迭代内部的数据</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20%E3%80%81Generator%E5%87%BD%E6%95%B0"><span class="nav-number">1.109.20.</span> <span class="nav-text">20、Generator函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-includes-%E5%87%BD%E6%95%B0-es2016"><span class="nav-number">1.109.21.</span> <span class="nav-text">21.includes 函数-es2016</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E8%BF%90%E7%AE%97%E7%AC%A6-es2016"><span class="nav-number">1.109.22.</span> <span class="nav-text">22. 运算符-es2016</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-values-%E5%87%BD%E6%95%B0-es2017"><span class="nav-number">1.109.23.</span> <span class="nav-text">23.values 函数-es2017</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-entries-%E5%87%BD%E6%95%B0-es2017"><span class="nav-number">1.109.24.</span> <span class="nav-text">24.entries 函数-es2017</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-Object-getOwnPropertyDescriptors-obj-es2017"><span class="nav-number">1.109.25.</span> <span class="nav-text">25.Object.getOwnPropertyDescriptors(obj)-es2017</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-padStart-padEnd-%E5%87%BD%E6%95%B0-es2017"><span class="nav-number">1.109.26.</span> <span class="nav-text">26.padStart, padEnd 函数-es2017</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="nav-number">1.109.26.0.0.1.</span> <span class="nav-text">参数：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%84%E5%88%99%EF%BC%9A"><span class="nav-number">1.109.26.0.0.2.</span> <span class="nav-text">规则：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A-2"><span class="nav-number">1.109.26.0.0.3.</span> <span class="nav-text">作用：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">1.110.</span> <span class="nav-text">函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.110.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.110.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.110.3.</span> <span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">1.110.3.0.0.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">1.110.3.0.0.2.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie%E3%80%81localStorage%E5%92%8CsessionStorage-%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.111.</span> <span class="nav-text">cookie、localStorage和sessionStorage 三者之间有什么区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.111.1.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.111.2.</span> <span class="nav-text">存放数据大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%93%E7%94%A8%E6%80%A7"><span class="nav-number">1.111.3.</span> <span class="nav-text">易用性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%EF%BC%8C%E5%90%84%E7%A7%8D%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">1.112.</span> <span class="nav-text">浏览器有哪几种缓存，各种缓存的优先级是什么样的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="nav-number">1.112.1.</span> <span class="nav-text">强制缓存：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="nav-number">1.112.2.</span> <span class="nav-text">协商缓存：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Service-Worker-%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="nav-number">1.112.3.</span> <span class="nav-text">Service Worker 缓存：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-Storage-%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="nav-number">1.112.4.</span> <span class="nav-text">Web Storage 缓存：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%99%E4%BA%9B%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">1.112.5.</span> <span class="nav-text">这些缓存的优先级如下：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E6%8F%90%E9%80%9F"><span class="nav-number">1.113.</span> <span class="nav-text">项目首屏提速</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%84%9F%E7%9F%A5%E6%8F%90%E9%80%9F"><span class="nav-number">1.113.1.</span> <span class="nav-text">用户感知提速</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E5%8A%A0%E8%BD%BD%E6%8F%90%E9%80%9F"><span class="nav-number">1.113.2.</span> <span class="nav-text">技术加载提速</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css%E5%85%83%E7%B4%A0%E9%9A%90%E8%97%8F"><span class="nav-number">1.114.</span> <span class="nav-text">css元素隐藏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD"><span class="nav-number">1.115.</span> <span class="nav-text">css元素居中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#em%E5%92%8Crem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.116.</span> <span class="nav-text">em和rem的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#em"><span class="nav-number">1.116.0.0.0.1.</span> <span class="nav-text">em</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#rem"><span class="nav-number">1.116.0.0.0.2.</span> <span class="nav-text">rem</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP1-0%E5%92%8CHTTP2-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.117.</span> <span class="nav-text">HTTP1.0和HTTP2.0的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8"><span class="nav-number">1.117.0.0.0.1.</span> <span class="nav-text">1、连接复用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%96%B9%E5%BC%8F"><span class="nav-number">1.117.0.0.0.2.</span> <span class="nav-text">2、请求-响应方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="nav-number">1.117.0.0.0.3.</span> <span class="nav-text">3、头部压缩</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.117.0.0.0.4.</span> <span class="nav-text">4、二进制协议</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E6%B5%81%E6%8E%A7%E5%88%B6%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.117.0.0.0.5.</span> <span class="nav-text">5、流控制和优先级</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%94%AF%E6%8C%81"><span class="nav-number">1.117.0.0.0.6.</span> <span class="nav-text">6、长连接支持</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88DFS%EF%BC%89%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.118.</span> <span class="nav-text">（DFS）深度优先搜索算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS%EF%BC%88%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.119.</span> <span class="nav-text">BFS（宽度优先算法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.120.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.121.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.122.</span> <span class="nav-text">JavaScript中常见的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Queue-%E9%98%9F%E5%88%97"><span class="nav-number">1.122.0.0.0.1.</span> <span class="nav-text">Queue 队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Stack-%E6%A0%88"><span class="nav-number">1.122.0.0.0.2.</span> <span class="nav-text">Stack 栈</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Linked-List-%E9%93%BE%E8%A1%A8"><span class="nav-number">1.122.0.0.0.3.</span> <span class="nav-text">Linked List 链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.122.0.0.0.4.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.122.0.0.0.5.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.122.0.0.0.6.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.122.0.0.0.7.</span> <span class="nav-text">堆</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#es6%E4%B8%ADmap%E5%92%8Cobject%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.123.</span> <span class="nav-text">es6中map和object的区别是什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue"><span class="nav-number">2.</span> <span class="nav-text">Vue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.</span> <span class="nav-text">Vue的最大优势是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVVM%E5%92%8CMVC%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.2.</span> <span class="nav-text">MVVM和MVC区别是什么?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MVC-%EF%BC%9A-%E4%BC%A0%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="nav-number">2.2.1.</span> <span class="nav-text">MVC ： 传统的设计模式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVVM%EF%BC%9A-vue%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">MVVM： vue所使用的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E5%9C%A8vue%E4%B8%AD%EF%BC%8C%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9B%B4%E6%8E%A5%E6%89%8B%E5%8A%A8%E6%93%8D%E4%BD%9CDOM%EF%BC%81%EF%BC%81%EF%BC%81"><span class="nav-number">2.2.2.0.0.1.</span> <span class="nav-text">1. 在vue中，不推荐直接手动操作DOM！！！</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E5%9C%A8vue%E4%B8%AD%EF%BC%8C%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%83%B3%E7%9D%80%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9CDOM%EF%BC%8C%E8%80%8C%E6%98%AF%E6%83%B3%E7%9D%80%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81%EF%BC%81-%E6%80%9D%E6%83%B3%E8%BD%AC%E5%8F%98"><span class="nav-number">2.2.2.0.0.2.</span> <span class="nav-text">2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！(思想转变)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">vue第一次加载页面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.4.</span> <span class="nav-text">Vue常用修饰符有哪些?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9Vue%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.5.</span> <span class="nav-text">对Vue渐进式的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.6.</span> <span class="nav-text">vue 生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E5%87%BA%E8%87%B3%E5%B0%914%E4%B8%AAVue%E6%8C%87%E4%BB%A4%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">2.7.</span> <span class="nav-text">说出至少4个Vue指令及作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%BF%E5%85%8Dv-for%E5%92%8Cv-if%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-number">2.8.</span> <span class="nav-text">为什么避免v-for和v-if在一起使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-if%E4%B8%8Ev-show%E5%8C%BA%E5%88%AB%E9%80%90%E5%AD%97%E7%A8%BF"><span class="nav-number">2.9.</span> <span class="nav-text">v-if与v-show区别逐字稿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E4%B8%ADkey%E5%80%BC%E4%BD%9C%E7%94%A8"><span class="nav-number">2.10.</span> <span class="nav-text">Vue中key值作用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BD%A0%E5%A5%BD-%E6%88%91%E6%98%AF%E8%BF%99%E4%B9%88%E7%90%86%E8%A7%A3key%E5%80%BC%E7%9A%84-key%E5%80%BC%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E6%98%AF%E7%BB%99%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6-%E7%94%A8%E4%BA%8E%E6%8F%90%E9%AB%98vue%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD-%E5%BD%93data%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99-vue%E4%BC%9A%E4%BD%BF%E7%94%A8diff%E7%AE%97%E6%B3%95%E6%9D%A5%E5%AF%B9%E6%AF%94%E6%96%B0%E6%97%A7%E8%99%9A%E6%8B%9FDOM-%E5%A6%82%E6%9E%9Ckey%E5%80%BC%E7%9B%B8%E5%90%8C-%E6%89%8D%E4%BC%9A%E8%80%83%E8%99%91%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-%E5%A6%82%E6%9E%9Ckey%E5%80%BC%E4%B8%8D%E5%90%8C-%E5%88%99%E4%BC%9A%E5%BC%BA%E5%88%B6%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0-%E4%B8%80%E8%88%AC%E9%80%9A%E8%BF%87%E7%BB%99%E5%85%83%E7%B4%A0key%E8%AE%BE%E7%BD%AE%E4%B8%BAid-%E6%9D%A5%E4%BF%9D%E8%AF%81vue%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E6%9C%80%E5%A4%A7%E9%99%90%E5%BA%A6%E5%A4%8D%E7%94%A8%E7%9B%B8%E5%90%8C%E7%9A%84key%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">2.10.0.0.0.1.</span> <span class="nav-text">面试官你好,我是这么理解key值的,key值的主要作用是给元素添加一个唯一标识符,用于提高vue渲染性能,当data发生变化的时候,vue会使用diff算法来对比新旧虚拟DOM.如果key值相同,才会考虑复用元素.如果key值不同,则会强制更新元素.一般通过给元素key设置为id,来保证vue更新数据的时候可以最大限度复用相同的key值的元素.</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-for%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8key%E5%80%BC%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">2.11.</span> <span class="nav-text">v-for指令使用key值几种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E4%B8%AD-key%E4%BD%9C%E7%94%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">2.12.</span> <span class="nav-text">Vue中:key作用, 为什么不能用索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-model%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="nav-number">2.13.</span> <span class="nav-text">v-model的作用及原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E4%B8%AD%E6%9C%89%E6%97%B6%E5%80%99%E6%95%B0%E7%BB%84%E4%BC%9A%E6%9B%B4%E6%96%B0%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%9C%89%E6%97%B6%E5%80%99%E4%B8%8D%E6%9B%B4%E6%96%B0%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">2.14.</span> <span class="nav-text">Vue中有时候数组会更新页面，有时候不更新，这是为什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E4%B8%8B%E5%B0%81%E8%A3%85-vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.15.</span> <span class="nav-text">请说下封装 vue 组件的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC"><span class="nav-number">2.16.</span> <span class="nav-text">vue组件传值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%BB%84%E4%BB%B6-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0"><span class="nav-number">2.17.</span> <span class="nav-text">Vue 组件 data 为什么必须是函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">2.18.</span> <span class="nav-text">讲一下组件的命名规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scoped%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-number">2.19.</span> <span class="nav-text">scoped作用与原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%9A%84-nextTick-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.20.</span> <span class="nav-text">Vue 的 nextTick 的原理是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BF%AE%E6%94%B9%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">2.21.</span> <span class="nav-text">子组件修改父组件的数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="nav-number">2.22.</span> <span class="nav-text">vue事件冒泡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="nav-number">2.23.</span> <span class="nav-text">响应式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E6%A7%BD"><span class="nav-number">2.24.</span> <span class="nav-text">插槽</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-show-v-if"><span class="nav-number">2.25.</span> <span class="nav-text">v-show  v-if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-%EF%BC%88%E5%BF%85%E4%BC%9A%EF%BC%89"><span class="nav-number">2.26.</span> <span class="nav-text">自定义指令的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E8%B7%AF%E7%94%B1%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-number">2.27.</span> <span class="nav-text">vue路由作用与原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%B3%E8%BD%AC%E7%9A%84%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="nav-number">2.28.</span> <span class="nav-text">路由之间是怎么跳转的？有哪些方式?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E7%94%A8%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E6%97%B6%E5%80%99%E9%98%B2%E6%AD%A2%E5%88%B7%E6%96%B0%E7%99%BD%E5%B1%8F"><span class="nav-number">2.29.</span> <span class="nav-text">再用动态路由的时候防止刷新白屏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-router%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%EF%BC%88%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%85%AD%E4%B8%AA%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="nav-number">2.30.</span> <span class="nav-text">vue-router怎么配置路由（路由配置六个流程）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-router%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%EF%BC%89"><span class="nav-number">2.31.</span> <span class="nav-text">vue-router的钩子函数都有哪些（导航守卫）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="nav-number">2.32.</span> <span class="nav-text">完整的导航解析流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%EF%BC%9F"><span class="nav-number">2.33.</span> <span class="nav-text">什么是路由守卫？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="nav-number">2.34.</span> <span class="nav-text">路由传值的方式有哪几种</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%A5%E6%94%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="nav-number">2.35.</span> <span class="nav-text">Vue路由传参方式，如何接收对应的值？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%BC%8F%EF%BC%9Ahash%E6%A8%A1%E5%BC%8F%E5%92%8Chistory%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.36.</span> <span class="nav-text">Vue的路由实现模式：hash模式和history模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E9%A1%B9%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">2.37.</span> <span class="nav-text">请说出路由配置项常用的属性及作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#route%E5%92%8C-router%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.38.</span> <span class="nav-text">$route和$router的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keep-alive"><span class="nav-number">2.39.</span> <span class="nav-text">keep-alive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%9Fkeep-alive%E6%9C%89%E5%85%B3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.40.</span> <span class="nav-text">跟keep-alive有关的生命周期是哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vuex%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BA%94%E5%A4%A7%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">2.41.</span> <span class="nav-text">vuex作用及五大组成部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vuex%E4%B8%ADaction%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.42.</span> <span class="nav-text">vuex中action工作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vuex%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">2.43.</span> <span class="nav-text">vuex刷新页面丢失数据原因和解决方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%9C%A8vue%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91"><span class="nav-number">2.44.</span> <span class="nav-text">说一下你在vue中踩过的坑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">小程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.1.</span> <span class="nav-text">小程序的登录流程是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E5%85%81%E8%AE%B8%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BD%93%E7%A7%AF%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-number">3.2.</span> <span class="nav-text">小程序项目允许的最大体积是多少</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%99%AE%E9%80%9A%E7%BD%91%E9%A1%B5%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">小程序和普通网页区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%84%E6%88%90"><span class="nav-number">3.4.</span> <span class="nav-text">小程序的项目构成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">3.5.</span> <span class="nav-text">小程序页面的组成部分**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#app-json%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.6.</span> <span class="nav-text">## app.json中的配置有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#window%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.7.</span> <span class="nav-text">window配置中的配置项有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tabBar%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.8.</span> <span class="nav-text">tabBar配置中的配置项有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89tabBar"><span class="nav-number">3.9.</span> <span class="nav-text">如何自定义tabBar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#networkTimeout%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.10.</span> <span class="nav-text">networkTimeout配置中的配置项有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93"><span class="nav-number">3.11.</span> <span class="nav-text">小程序渲染数据如何渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E7%9A%84%E6%8C%87%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.12.</span> <span class="nav-text">列表渲染的指令是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9item%E5%92%8Cindex%E7%9A%84%E5%90%8D%E5%AD%97"><span class="nav-number">3.13.</span> <span class="nav-text">列表渲染如何修改item和index的名字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E5%8F%AF%E4%BB%A5%E6%B8%B2%E6%9F%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.14.</span> <span class="nav-text">列表渲染可以渲染的数据类型有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.15.</span> <span class="nav-text">block标签的作用是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9"><span class="nav-number">3.16.</span> <span class="nav-text">小程序中如何实现响应式的数据修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.17.</span> <span class="nav-text">小程序生命周期函数有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BA%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.18.</span> <span class="nav-text">页面级生命周期函数有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%BA%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.19.</span> <span class="nav-text">组件级生命周期函数有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.20.</span> <span class="nav-text">组件的主要生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#input%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%BA%BF%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="nav-number">3.21.</span> <span class="nav-text">input组件如何实现双线数据绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#input%E7%BB%84%E4%BB%B6%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E9%94%AE%E7%9B%98%E5%8F%B3%E4%B8%8B%E8%A7%92%E6%96%87%E5%AD%97%E6%8F%90%E7%A4%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E6%88%90%E5%93%AA%E4%BA%9B%E5%80%BC"><span class="nav-number">3.22.</span> <span class="nav-text">input组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#input%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E9%94%AE%E7%9B%98%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.23.</span> <span class="nav-text">input组件中有几种键盘类型，分别是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scroll-view%E7%BB%84%E4%BB%B6%E6%83%B3%E8%A6%81%E7%BA%B5%E5%90%91%E6%BB%9A%E5%8A%A8%E6%97%B6%EF%BC%8C%E5%BF%85%E9%A1%BB%E8%A6%81%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%86%85%E5%AE%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.24.</span> <span class="nav-text">scroll-view组件想要纵向滚动时，必须要设置的内容有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#navigator%E7%BB%84%E4%BB%B6%E7%9A%84%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.25.</span> <span class="nav-text">navigator组件的跳转方式有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#navigate%E5%92%8C-redirect%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">3.26.</span> <span class="nav-text">navigate和 redirect方式有什么区别，共同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#navigate%E5%92%8C-switchTab-%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">3.27.</span> <span class="nav-text">navigate和 switchTab 方式有什么区别，共同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#navigate%E5%92%8C-reLaunch-%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">3.28.</span> <span class="nav-text">navigate和 reLaunch 方式有什么区别，共同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E7%BB%84%E4%BB%B6%E6%98%AF%E5%90%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%AE%BD%E9%AB%98%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%AE%BD%E9%AB%98%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-number">3.29.</span> <span class="nav-text">图片组件是否有默认宽高，默认宽高是多少?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wxss%E5%92%8Ccss%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.30.</span> <span class="nav-text">wxss和css的不同之处有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">3.31.</span> <span class="nav-text">小程序有几种绑定事件的方式，有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6%E6%9C%89%E5%93%AA%EF%BC%8C%E8%AF%B4%E5%87%BA5%E4%B8%AA%E4%BB%A5%E4%B8%8A"><span class="nav-number">3.32.</span> <span class="nav-text">常见移动端事件有哪，说出5个以上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.33.</span> <span class="nav-text">触摸事件的事件对象中有哪些常见属性，作用是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#target-%E5%92%8CcurrentTarget%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.34.</span> <span class="nav-text">target 和currentTarget两者的区别是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="nav-number">3.35.</span> <span class="nav-text">小程序中的事件如何传递数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-number">3.36.</span> <span class="nav-text">小程序中全局数据如何使用，有什么特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6"><span class="nav-number">3.37.</span> <span class="nav-text">如何自定义一个组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%A0%B7%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E7%9A%84"><span class="nav-number">3.38.</span> <span class="nav-text">关于父子组件之间样式是如何影响的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%96%E9%83%A8%E6%A0%B7%E5%BC%8F%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.39.</span> <span class="nav-text">组件的外部样式类如何设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%83%B3%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8F%92%E6%A7%BD%E4%BD%BF%E7%94%A8%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.40.</span> <span class="nav-text">小程序想要实现多个插槽使用如何设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E5%80%BC%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="nav-number">3.41.</span> <span class="nav-text">父组件如何传值给子组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E5%80%BC%E7%BB%99%E7%88%B6%E7%BB%84%E4%BB%B6"><span class="nav-number">3.42.</span> <span class="nav-text">子组件如何传值给父组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E7%BA%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.43.</span> <span class="nav-text">组件如何监听页面级生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E4%BA%A4%E4%BA%92API%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.44.</span> <span class="nav-text">小程序中的交互API有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%9F%9F%E5%90%8D%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">3.45.</span> <span class="nav-text">小程序中域名无法识别如何处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%99%90%E5%88%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%90%88%E6%B3%95%E5%9F%9F%E5%90%8D%EF%BC%9F"><span class="nav-number">3.46.</span> <span class="nav-text">网络请求限制，如何配置合法域名？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%ADbase64%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.47.</span> <span class="nav-text">小程序中base64与二进制数据流之间的转换如何转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%EF%BC%9F"><span class="nav-number">3.48.</span> <span class="nav-text">你是怎么封装微信小程序的数据请求的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">3.49.</span> <span class="nav-text">小程序支付如何实现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8C%85"><span class="nav-number">3.50.</span> <span class="nav-text">小程序如何进行分包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%88%86%E5%8C%85%E5%92%8C%E7%8B%AC%E7%AB%8B%E5%88%86%E5%8C%85%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">3.51.</span> <span class="nav-text">普通分包和独立分包有什么不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.52.</span> <span class="nav-text">分包有哪些注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uni-app"><span class="nav-number">4.</span> <span class="nav-text">uni-app</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#uni-app%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF"><span class="nav-number">4.1.</span> <span class="nav-text">uni-app有哪些优势?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uni-app%E8%AF%AD%E6%B3%95%E3%80%81%E7%BB%84%E4%BB%B6-%E5%8F%8A-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E7%9A%84-%E7%9B%B8%E5%90%8C%E4%B9%8B%E5%A4%84%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">uni-app语法、组件 及 生命周期 的 相同之处？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#uni-app%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%EF%BC%9F"><span class="nav-number">4.2.0.1.</span> <span class="nav-text">uni-app的不同之处？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B0%81%E8%A3%85"><span class="nav-number">4.3.</span> <span class="nav-text">网络封装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue3"><span class="nav-number">5.</span> <span class="nav-text">Vue3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vue2%E5%92%8CVue3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">vue2和Vue3的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80-%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%8D%E5%90%8C"><span class="nav-number">5.1.0.0.0.1.</span> <span class="nav-text">一. 根节点不同</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C-%E7%BB%84%E5%90%88%E5%BC%8FAPI%E5%92%8C%E9%80%89%E9%A1%B9%E5%BC%8FAPI"><span class="nav-number">5.1.0.0.0.2.</span> <span class="nav-text">二. 组合式API和选项式API</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%89-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">5.1.0.0.0.3.</span> <span class="nav-text">三. 生命周期的变化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%9B-v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">5.1.0.0.0.4.</span> <span class="nav-text">四. v-if和v-for的优先级</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%94-diff%E7%AE%97%E6%B3%95%E4%B8%8D%E5%90%8C"><span class="nav-number">5.1.0.0.0.5.</span> <span class="nav-text">五. diff算法不同</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%AD-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B8%8D%E5%90%8C"><span class="nav-number">5.1.0.0.0.6.</span> <span class="nav-text">六. 响应式原理不同</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9Avue3%E7%9B%B8%E5%85%B3%E8%AF%B7%E6%9F%A5%E7%9C%8B-http-liuminghao-top"><span class="nav-number">5.2.</span> <span class="nav-text">更多vue3相关请查看 http:&#x2F;&#x2F;liuminghao.top</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/local-search.js"></script>





    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/toc.js"></script>
        
    
    
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>




</body>
</html>
