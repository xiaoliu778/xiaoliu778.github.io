<!DOCTYPE html><html lang="zh-Hans" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>react面试题 | 博客</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">首页</span></a></li><li class="navItem" matchdata="标签,类别"><a class="navBlock" href="/archives/"><span class="navItemTitle">文章时间</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">关于我们</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>react面试题</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-03-29T01:42:32.022Z" id="date"> 2023-03-29</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-06-28T07:52:04.605Z" id="updated"> 2023-06-28</time></div></span></div></div><hr><div id="post-content"><h2 id="React面试题"><a href="#React面试题" class="headerlink" title="React面试题"></a>React面试题</h2><h3 id="props接受任意参，那具体使用场景都有哪些"><a href="#props接受任意参，那具体使用场景都有哪些" class="headerlink" title="props接受任意参，那具体使用场景都有哪些"></a>props接受任意参，那具体使用场景都有哪些</h3><ul>
<li>1.基础数组类型，复合数据类型</li>
<li>2.直接传递一组件</li>
<li>3.可以通过函数接收Html一个片段</li>
<li>4.props.children</li>
<li>5.{…obj}</li>
<li>6.cakkback 子传父</li>
</ul>
<h3 id="context的使用场景有哪些，分别是什么？与props的区别是什么？"><a href="#context的使用场景有哪些，分别是什么？与props的区别是什么？" class="headerlink" title="context的使用场景有哪些，分别是什么？与props的区别是什么？"></a>context的使用场景有哪些，分别是什么？与props的区别是什么？</h3><ul>
<li>1.基础数组类型，复合数据类型</li>
<li>2.直接传递一组件</li>
<li>3.可以通过函数接收Html一个片段</li>
<li>4.callback子传父</li>
<li>5.{…obj}<br>区别<br>解决propse一代传一代问题，context可以跨组件数据通信</li>
</ul>
<h3 id="React中事件this邦定的实现方法有哪些"><a href="#React中事件this邦定的实现方法有哪些" class="headerlink" title="React中事件this邦定的实现方法有哪些?"></a>React中事件this邦定的实现方法有哪些?</h3><ul>
<li>1.调用时使用this.set.bind(this)</li>
<li>2.在constructor中绑定this.set&#x3D;this.set.bind(this)</li>
<li>3.使用箭头函数进行绑定</li>
<li>4.onClick&#x3D;{()&#x3D;&gt;{this.set()}}</li>
</ul>
<h3 id="React组件生命周期的阶段是什么？常用生命周期方法有哪些？"><a href="#React组件生命周期的阶段是什么？常用生命周期方法有哪些？" class="headerlink" title="React组件生命周期的阶段是什么？常用生命周期方法有哪些？"></a>React组件生命周期的阶段是什么？常用生命周期方法有哪些？</h3><p>挂载、更新、卸载<br>挂载 constructor  render  componentDidMount<br>更新componentDidUpdate render<br>卸载componentWillUnmount<br>constructor 用来设置state默认值的<br>componentDidMount ajax 请求 定时器设置的<br>componentWillUnmount  清定时器、取消ajax请求</p>
<h3 id="state-修改的三种方式"><a href="#state-修改的三种方式" class="headerlink" title="state 修改的三种方式"></a>state 修改的三种方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>、<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    <span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-string">&#x27;3&#x27;</span><br>&#125;)<br><span class="hljs-number">2</span>、<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state,props</span>)=&gt;</span>(&#123;<br>    <span class="hljs-attr">a</span>:state.<span class="hljs-property">a</span>+<span class="hljs-number">1</span><br>&#125;))<br><span class="hljs-number">3</span>、<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    <span class="hljs-attr">obj</span>:&#123;<br>        ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">obj</span>,<br>        <span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-string">&#x27;3&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">obj</span>:<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;,<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">obj</span>,&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-string">&#x27;3&#x27;</span>&#125;)<br>&#125;)<br><br><br>&lt;select multiple=&#123;<span class="hljs-literal">true</span>&#125; value=&#123;[<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]&#125;&gt;<br>              <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;B&quot;</span>&gt;</span>葡萄柚<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br>              <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;C&quot;</span>&gt;</span>酸橙<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br>              <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;E&quot;</span>&gt;</span>酸橙<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br>              <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;F&quot;</span>&gt;</span>酸橙<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br>&lt;/select&gt;<br></code></pre></td></tr></table></figure>

<h3 id="函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对应类组件生命周期的？"><a href="#函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对应类组件生命周期的？" class="headerlink" title="函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对应类组件生命周期的？"></a>函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对应类组件生命周期的？</h3><p>props接收方式不一样<br>render渲染方式不一样<br>函数组件没有state<br>函数组件也没有生命周期</p>
<ul>
<li>生命周期<br>挂载、更新、卸载<ul>
<li>挂载 constructor render componentDidMount</li>
<li>更新 componentDidUpdate render</li>
<li>卸载componentWillUnmount</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">useEffect<br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><br>&#125;,[])componentDidMount <br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><br>&#125;,[count])componentDidUpdate <br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">return</span><span class="hljs-function">()=&gt;</span>&#123;    &#125; componentWillUnmount  <br>&#125;,[])<br></code></pre></td></tr></table></figure>

<h3 id="react是单向数据流，如何实现数据双向绑定"><a href="#react是单向数据流，如何实现数据双向绑定" class="headerlink" title="react是单向数据流，如何实现数据双向绑定"></a>react是单向数据流，如何实现数据双向绑定</h3><p>通过onChange事件进行实时监听来获取value值 通过serState来实现数据双想绑定</p>
<h3 id="vue、react打包的项目自定义路径-是否可以正常使用"><a href="#vue、react打包的项目自定义路径-是否可以正常使用" class="headerlink" title="vue、react打包的项目自定义路径 是否可以正常使用"></a>vue、react打包的项目自定义路径 是否可以正常使用</h3><p>无法正常使用<br>需要在nginx进行url重写</p>
<h3 id="我js中会使用return-false来组件默认事件，react中有合成事件想阻止默认事件以及阻止冒泡事件应该怎么做？"><a href="#我js中会使用return-false来组件默认事件，react中有合成事件想阻止默认事件以及阻止冒泡事件应该怎么做？" class="headerlink" title="我js中会使用return false来组件默认事件，react中有合成事件想阻止默认事件以及阻止冒泡事件应该怎么做？"></a>我js中会使用return false来组件默认事件，react中有合成事件想阻止默认事件以及阻止冒泡事件应该怎么做？</h3><p>e.preventDefault()、e.stopPropagation();</p>
<h3 id="在react开发中会涉及到多个组件交互操作，如果当前组件有ajax未请求完成，这时直接跳到另一个组件会报错，我们如何来阻止报错。"><a href="#在react开发中会涉及到多个组件交互操作，如果当前组件有ajax未请求完成，这时直接跳到另一个组件会报错，我们如何来阻止报错。" class="headerlink" title="在react开发中会涉及到多个组件交互操作，如果当前组件有ajax未请求完成，这时直接跳到另一个组件会报错，我们如何来阻止报错。"></a>在react开发中会涉及到多个组件交互操作，如果当前组件有ajax未请求完成，这时直接跳到另一个组件会报错，我们如何来阻止报错。</h3><p>在componentWillUnmount（）组件中取消或终止ajax请求</p>
<h3 id="当前组件引入一个子组件，如何在子组件中获取到这个data的值，并且使用es6进行改写"><a href="#当前组件引入一个子组件，如何在子组件中获取到这个data的值，并且使用es6进行改写" class="headerlink" title="当前组件引入一个子组件，如何在子组件中获取到这个data的值，并且使用es6进行改写"></a>当前组件引入一个子组件，如何在子组件中获取到这个data的值，并且使用es6进行改写</h3><p>this.props.data<br>&lt;App {…data}&#x2F;&gt;</p>
<h3 id="路由中NavLink-与Link什么区别？"><a href="#路由中NavLink-与Link什么区别？" class="headerlink" title="路由中NavLink 与Link什么区别？"></a>路由中NavLink 与Link什么区别？</h3><p>NavLink 当前选中会增加默认一个classname 而link直接就是链接跳转</p>
<h3 id="路由传参的三种方式？"><a href="#路由传参的三种方式？" class="headerlink" title="路由传参的三种方式？"></a>路由传参的三种方式？</h3><p>params,query,state<br>react路由传参(3种方式)</p>
<p>1、params传参(刷新页面后参数不消失，参数会在地址栏显示)上文的动态路由实现方式</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Route</span> exact path=<span class="hljs-string">&quot;/ceshi&quot;</span> component=&#123;<span class="hljs-title class_">Ceshi</span>&#125; /&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#123;</span>`/<span class="hljs-attr">ceshi</span>/<span class="hljs-attr">:page</span>`&#125; <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Ceshi&#125;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#123;</span>`/<span class="hljs-attr">ceshi</span>/<span class="hljs-attr">:page</span>/<span class="hljs-attr">:id</span>`&#125; <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Ceshi&#125;</span> /&gt;</span></span><br><br><br>路由跳转并传递参数：<br>链接方式：&lt;<span class="hljs-title class_">Link</span> to=&#123;<span class="hljs-string">`/ceshi/tg`</span>&#125;&gt;通过&lt;/<span class="hljs-title class_">Link</span>&gt;<br>或：&lt;<span class="hljs-title class_">Link</span> to=&#123;&#123;<span class="hljs-attr">pathname</span>:<span class="hljs-string">`/ceshi/tg`</span>&#125;&#125;&gt;通过&lt;/<span class="hljs-title class_">Link</span>&gt;<br>js方式：<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">`/ceshi/tg`</span>)<br>或：<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">pathname</span>:<span class="hljs-string">`/ceshi/tg`</span>&#125;)<br><br>页面获取参数：<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">match</span>.<span class="hljs-property">params</span>.<span class="hljs-property">page</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">match</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span><br><span class="hljs-comment">//注意这里是match而非history</span><br></code></pre></td></tr></table></figure>

<p>2、query传参(刷新页面后参数消失)</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">路由页面：&lt;<span class="hljs-title class_">Route</span> path=<span class="hljs-string">&#x27;/ceshi&#x27;</span> component=&#123;<span class="hljs-title class_">CeShi</span>&#125;/&gt;  <span class="hljs-comment">//无需配置</span><br><br>路由跳转并传递参数：<br>链接方式：<br>&lt;<span class="hljs-title class_">Link</span> to=&#123;&#123;<span class="hljs-attr">pathname</span>:<span class="hljs-string">`/ceshi`</span>,<span class="hljs-attr">query</span>:&#123;<span class="hljs-attr">id</span>:<span class="hljs-number">6</span>,<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;tg&#x27;</span>&#125;&#125;&#125;&gt;通过&lt;/<span class="hljs-title class_">Link</span>&gt;<br><br>js方式：<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">pathname</span>:<span class="hljs-string">`/ceshi`</span>,<span class="hljs-attr">query</span>:&#123;<span class="hljs-attr">id</span>:<span class="hljs-number">6</span>,<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;tg&#x27;</span>&#125;&#125;)<br>---<br>获取参数： <br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">location</span>.<span class="hljs-property">query</span>.<span class="hljs-property">name</span><br></code></pre></td></tr></table></figure>

<p>3、state传参( 刷新页面后参数不消失，state传的参数是加密的，比query传参好用)<br>注：state 传参的方式只支持Browserrouter路由，不支持hashrouter</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">路由页面：<br>&lt;<span class="hljs-title class_">Route</span> path=<span class="hljs-string">&#x27;/demo&#x27;</span> component=&#123;<span class="hljs-title class_">Ceshi</span>&#125;/&gt;  <span class="hljs-comment">//无需配置</span><br><br>路由跳转并传递参数：<br>链接方式： <br>&lt;<span class="hljs-title class_">Link</span> to=&#123;&#123;<span class="hljs-attr">pathname</span>:<span class="hljs-string">`/ceshi`</span>,<span class="hljs-attr">state</span>:&#123;<span class="hljs-attr">id</span>:<span class="hljs-number">12</span>,<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;tg&#x27;</span>&#125;&#125;&#125;&gt;通过&lt;/<span class="hljs-title class_">Link</span>&gt;<br>js方式：<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">pathname</span>:<span class="hljs-string">`/ceshi`</span>,<span class="hljs-attr">state</span>:&#123;<span class="hljs-attr">id</span>:<span class="hljs-number">12</span>,<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;tg&#x27;</span>&#125;&#125;)<br>---<br>获取参数： <br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">location</span>.<span class="hljs-property">state</span>.<span class="hljs-property">url</span><br></code></pre></td></tr></table></figure>

<h3 id="如何在组件更新时再发起一个ajax-请求，在更新时需要注意什么？"><a href="#如何在组件更新时再发起一个ajax-请求，在更新时需要注意什么？" class="headerlink" title="如何在组件更新时再发起一个ajax 请求，在更新时需要注意什么？"></a>如何在组件更新时再发起一个ajax 请求，在更新时需要注意什么？</h3><p>使用if判断某个值是否改变，当此值改变后在调用ajax函数</p>
<h3 id="已知对象boj-jajx返回一个后如何合并原有对象，使用至少两种方式实现"><a href="#已知对象boj-jajx返回一个后如何合并原有对象，使用至少两种方式实现" class="headerlink" title="已知对象boj,jajx返回一个后如何合并原有对象，使用至少两种方式实现"></a>已知对象boj,jajx返回一个后如何合并原有对象，使用至少两种方式实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">ajax</span>(<span class="hljs-params">url,fn(res)</span>)&#123;<br>  <span class="hljs-comment">// 假设res为对象</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    <span class="hljs-attr">obj</span>:&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">obj</span>,...res&#125;<br>  &#125;)<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;,obj,res)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="路由值系页面可以使用history，那非值系，隔代页面中如何使用路由相关信息"><a href="#路由值系页面可以使用history，那非值系，隔代页面中如何使用路由相关信息" class="headerlink" title="路由值系页面可以使用history，那非值系，隔代页面中如何使用路由相关信息"></a>路由值系页面可以使用history，那非值系，隔代页面中如何使用路由相关信息</h3><p>withrouter</p>
<h3 id="react是单向数据流，如何实现数据双向邦定？如何修改state自身值而使其可以累加？"><a href="#react是单向数据流，如何实现数据双向邦定？如何修改state自身值而使其可以累加？" class="headerlink" title="react是单向数据流，如何实现数据双向邦定？如何修改state自身值而使其可以累加？"></a>react是单向数据流，如何实现数据双向邦定？如何修改state自身值而使其可以累加？</h3><ul>
<li>通过onChange事件进行时时监听来获取value值 通过setState来实现数据双向邦定<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state,props</span>)=&gt;</span>(&#123;<br>         <span class="hljs-attr">page</span>:state.<span class="hljs-property">page</span>+<span class="hljs-number">1</span><br>&#125;))<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="在使用react项目开发时，你是如何与后端进行接口连调的"><a href="#在使用react项目开发时，你是如何与后端进行接口连调的" class="headerlink" title="在使用react项目开发时，你是如何与后端进行接口连调的"></a>在使用react项目开发时，你是如何与后端进行接口连调的</h3><p>在src中的react&#x2F;first-react&#x2F;src&#x2F;setupProxy.js配置在线接口的url，从而使用在线接口代理 到本地3000下</p>
<h3 id="props接收任意参，那具体使用场景都有哪些？context的使用场景有哪些，分别是什么"><a href="#props接收任意参，那具体使用场景都有哪些？context的使用场景有哪些，分别是什么" class="headerlink" title="props接收任意参，那具体使用场景都有哪些？context的使用场景有哪些，分别是什么"></a>props接收任意参，那具体使用场景都有哪些？context的使用场景有哪些，分别是什么</h3><p>props</p>
<ul>
<li>基础数组类型，复合数据类型</li>
<li>直接传递一组件</li>
<li>可以通过函数接收Html一个片段</li>
<li>props.children</li>
<li>callback 子传父</li>
</ul>
<p>Context<br>解决props一代传一代问题，context可以跨页面数据通信</p>
<ul>
<li>基础数组类型，复合数据类型</li>
<li>直接传递一组件</li>
<li>可以通过函数接收Html一个片段</li>
<li>callback 子传父</li>
</ul>
<h3 id="函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对类组件生命周期的？"><a href="#函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对类组件生命周期的？" class="headerlink" title="函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对类组件生命周期的？"></a>函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对类组件生命周期的？</h3><p>区别：<br>props接受方式不一样<br>render渲染方式不一样<br>函数没有state<br>函数组件也没有state<br>函数组件也没有生命周期<br>生命周期<br>挂载、更新、卸载<br>挂载 constructor render componentDidMount<br>更新 componentDidUpdate render<br>卸载 componentWillUnmount</p>
<p>useEffect：<br>useEffect(()&#x3D;&gt;{<br>},[])componentDidMount<br>useEffect(()&#x3D;&gt;{<br>},[count])componentDidUpdate<br>useEffect(()&#x3D;&gt;{<br>return()&#x3D;&gt;{<br>  }componentWillUnmount<br>},[])</p>
<h3 id="Mobx"><a href="#Mobx" class="headerlink" title="Mobx"></a>Mobx</h3><ul>
<li>简述一下你对mobx的理解，以及你在项目中使用mobx的流程是什么(类组件与函数组件)</li>
</ul>
<p>结合react的State和setState 把moxb简单概括为三点<br>1.定义一个observable 相当于我们的state<br>2.想要更改observable需要使用action 相当于我们setState<br>3.在视图中我们通过@observer 来响应数据变化<br>项目中使用：</p>
<ul>
<li>安装<ul>
<li>安装mobx mobx-React</li>
<li>解决@修饰符</li>
</ul>
</li>
<li>router.js<ul>
<li>引入 Provider</li>
<li>引入store.js</li>
<li>合并拆分 生成大store</li>
<li>App 外使用 Provider 并且…store</li>
</ul>
</li>
<li>store.js<ul>
<li>包引入</li>
<li>oberservale</li>
<li>action</li>
</ul>
</li>
<li>页面获取<ul>
<li>包引入</li>
<li>@withrouter</li>
<li>@inject</li>
<li>@observer</li>
</ul>
</li>
<li>hook<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;observer,<span class="hljs-title class_">MobXProviderContext</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mobx-react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; withRouter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useStores</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MobXProviderContext</span>)[name]<br>&#125;<br><span class="hljs-keyword">const</span> &#123; tradeCfg &#125; = <span class="hljs-title function_">useStores</span>(<span class="hljs-string">&#x27;FirstStore&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; name &#125; =  <span class="hljs-title function_">useStores</span>(<span class="hljs-string">&#x27;SecondStore&#x27;</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withRouter</span>(<span class="hljs-title function_">observer</span>(<span class="hljs-title class_">View</span>));<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="简述一下你对redux的理解，以及你在项目中使用redux的流程是什么（类组件与函数组件）？"><a href="#简述一下你对redux的理解，以及你在项目中使用redux的流程是什么（类组件与函数组件）？" class="headerlink" title="简述一下你对redux的理解，以及你在项目中使用redux的流程是什么（类组件与函数组件）？"></a>简述一下你对redux的理解，以及你在项目中使用redux的流程是什么（类组件与函数组件）？</h3><p>结合react 的State 可以把redux 简单概括为三点<br>1、通过Store.getState()来获取整个数据源<br>2、通过触发action 来修改State ,而修改action的唯一途径就是dispatch<br>3、使用一个reducer 纯函数来接收state 和action 从面生成新的state,再使用createStore来创建一个Redux 的Store<br>而在项目中使用流程是：<br>1、安装<br>2、router.js<br>3、store.js<br>4、view&#x2F;home&#x2F;redux<br>    actions.js<br>    actointypes.js<br>    reducer.js<br>    _index.js<br>5、页面</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;actions&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./_index.js&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mapStateToProps</span>(<span class="hljs-params">state</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">addList</span>:state.<span class="hljs-property">add</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapDispatchToProps</span> = (<span class="hljs-params">dispatch, ownProps</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">onAddFn</span>:<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">dispatch</span>(actions.<span class="hljs-title function_">add</span>())<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(mapStateToProps,mapDispatchToProps)(<span class="hljs-title class_">View</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span><br></code></pre></td></tr></table></figure>
<p>函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>state);<br><span class="hljs-keyword">const</span> add = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>)=&gt;</span>state.<span class="hljs-property">add</span>);<br><span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title function_">dispatch</span>(actions.<span class="hljs-title function_">add</span>())<br>&#125;,[])<br></code></pre></td></tr></table></figure>


<h3 id="React是什么，它的优缺点，它和vue的区别"><a href="#React是什么，它的优缺点，它和vue的区别" class="headerlink" title="React是什么，它的优缺点，它和vue的区别"></a>React是什么，它的优缺点，它和vue的区别</h3><h4 id="React是什么"><a href="#React是什么" class="headerlink" title="React是什么"></a>React是什么</h4><ul>
<li>React是一个JavaScript库，用于构建高效、快速的用户界面。React主要用于构建Ui</li>
</ul>
<h4 id="它的优缺点"><a href="#它的优缺点" class="headerlink" title="它的优缺点"></a>它的优缺点</h4><p>优点</p>
<ul>
<li>React速度快<ul>
<li>在React并不会直接对DOM进行操作，而是引入了一个叫虚拟DOM的概念，安插在javascript逻辑和实际的DOM之间，性能很好</li>
</ul>
</li>
<li>性能好&#x2F;跨浏览器兼容<ul>
<li>虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没有问题的</li>
</ul>
</li>
<li>一切都是component&#x2F;代码模块化<ul>
<li>代码模块化，重用代码更容易</li>
</ul>
</li>
<li>单向数据流<ul>
<li>Flux是一个用于在JavaScript应用程序中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化</li>
</ul>
</li>
<li>兼容性好<ul>
<li>比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用，它们使得那些艰难的任务不再让人望人生畏。</li>
</ul>
</li>
<li>同构、纯粹的JavaScript<ul>
<li>因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化</li>
</ul>
</li>
</ul>
<p>缺点</p>
<ul>
<li><p>React只是视图层的一个框架，如果需要做其他事情，需要依赖它的生态系统；比如使用路由需要用到Router，处理数据需要用到Redux</p>
</li>
<li><p>学习成本高</p>
</li>
</ul>
<h3 id="开发工具-react-devtool-安装"><a href="#开发工具-react-devtool-安装" class="headerlink" title="开发工具 react-devtool 安装"></a>开发工具 react-devtool 安装</h3><p>⚙️ 如何手动添加一个chrome扩展</p>
<ul>
<li>解压 react-devtools.zip 到磁盘一个用来保存 chrome 扩展的文件夹中</li>
<li>打开 chrome 浏览器…菜单，更多工具 &#x2F; 扩展程序</li>
<li>打开开发者模式</li>
<li>将 react-devtools 文件夹拖入到当前界面中，完成</li>
</ul>
<hr>
<hr>
<h3 id="其他-扩展"><a href="#其他-扩展" class="headerlink" title="其他 -扩展"></a>其他 -扩展</h3><h4 id="react-Hooks状态库"><a href="#react-Hooks状态库" class="headerlink" title="react Hooks状态库"></a>react Hooks状态库</h4><ul>
<li>ahooks (阿里巴巴出品的的一个react Hooks库)</li>
</ul>
<h4 id="redux与rtk的区别"><a href="#redux与rtk的区别" class="headerlink" title="redux与rtk的区别"></a>redux与rtk的区别</h4><ul>
<li>1、reduxjs&#x2F;tookit相对于react-redux来说比较方便，集成了redux-devtools-extension，不需要额外的配置，非常方便</li>
<li>2、reduxjs&#x2F;tookit集成immutable-js的功能，不需要安装配置使用，提升了开发效率</li>
<li>3、reduxjs&#x2F;tookit集成了redux-thunk的功能</li>
<li>4、reduxjs&#x2F;tookit将types、actions、reducers放在一起组成了全新的slices，简化了我们的使用</li>
</ul>
<h4 id="如何在react中使用sass"><a href="#如何在react中使用sass" class="headerlink" title="如何在react中使用sass"></a>如何在react中使用sass</h4><ul>
<li><p>首先安装依赖 npm install –save-dev node-sass</p>
</li>
<li><p>create-react-app 创建的react项目默认就是支持Sass的，<br>使用只要安装node-sass即可使用</p>
</li>
</ul>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/03/29/reactNative/">← Next 从零开始react Native</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/03/29/vue/">VUe Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">刘小烨</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#React%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">React面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#props%E6%8E%A5%E5%8F%97%E4%BB%BB%E6%84%8F%E5%8F%82%EF%BC%8C%E9%82%A3%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.</span> <span class="toc-text">props接受任意参，那具体使用场景都有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#context%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%8Eprops%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">context的使用场景有哪些，分别是什么？与props的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E4%B8%AD%E4%BA%8B%E4%BB%B6this%E9%82%A6%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.3.</span> <span class="toc-text">React中事件this邦定的实现方法有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E9%98%B6%E6%AE%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B8%B8%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">React组件生命周期的阶段是什么？常用生命周期方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state-%E4%BF%AE%E6%94%B9%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">state 修改的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%92%8C%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B4%E8%AF%B4%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9Fhook%E4%B8%AD%E7%9A%84useEffect%E5%A6%82%E4%BD%95%E5%AF%B9%E5%BA%94%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对应类组件生命周期的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E6%98%AF%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">1.7.</span> <span class="toc-text">react是单向数据流，如何实现数据双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E3%80%81react%E6%89%93%E5%8C%85%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E5%BE%84-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.</span> <span class="toc-text">vue、react打包的项目自定义路径 是否可以正常使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91js%E4%B8%AD%E4%BC%9A%E4%BD%BF%E7%94%A8return-false%E6%9D%A5%E7%BB%84%E4%BB%B6%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%EF%BC%8Creact%E4%B8%AD%E6%9C%89%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E6%83%B3%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">我js中会使用return false来组件默认事件，react中有合成事件想阻止默认事件以及阻止冒泡事件应该怎么做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8react%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BC%9A%E6%B6%89%E5%8F%8A%E5%88%B0%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E6%9C%89ajax%E6%9C%AA%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%EF%BC%8C%E8%BF%99%E6%97%B6%E7%9B%B4%E6%8E%A5%E8%B7%B3%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E6%88%91%E4%BB%AC%E5%A6%82%E4%BD%95%E6%9D%A5%E9%98%BB%E6%AD%A2%E6%8A%A5%E9%94%99%E3%80%82"><span class="toc-number">1.10.</span> <span class="toc-text">在react开发中会涉及到多个组件交互操作，如果当前组件有ajax未请求完成，这时直接跳到另一个组件会报错，我们如何来阻止报错。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E5%BC%95%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%90%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%88%B0%E8%BF%99%E4%B8%AAdata%E7%9A%84%E5%80%BC%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BD%BF%E7%94%A8es6%E8%BF%9B%E8%A1%8C%E6%94%B9%E5%86%99"><span class="toc-number">1.11.</span> <span class="toc-text">当前组件引入一个子组件，如何在子组件中获取到这个data的值，并且使用es6进行改写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%B8%ADNavLink-%E4%B8%8ELink%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">路由中NavLink 与Link什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">路由传参的三种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%97%B6%E5%86%8D%E5%8F%91%E8%B5%B7%E4%B8%80%E4%B8%AAajax-%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%9C%A8%E6%9B%B4%E6%96%B0%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">如何在组件更新时再发起一个ajax 请求，在更新时需要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E5%AF%B9%E8%B1%A1boj-jajx%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%90%8E%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%8E%9F%E6%9C%89%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%87%B3%E5%B0%91%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.15.</span> <span class="toc-text">已知对象boj,jajx返回一个后如何合并原有对象，使用至少两种方式实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%80%BC%E7%B3%BB%E9%A1%B5%E9%9D%A2%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8history%EF%BC%8C%E9%82%A3%E9%9D%9E%E5%80%BC%E7%B3%BB%EF%BC%8C%E9%9A%94%E4%BB%A3%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="toc-number">1.16.</span> <span class="toc-text">路由值系页面可以使用history，那非值系，隔代页面中如何使用路由相关信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E6%98%AF%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E9%82%A6%E5%AE%9A%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9state%E8%87%AA%E8%BA%AB%E5%80%BC%E8%80%8C%E4%BD%BF%E5%85%B6%E5%8F%AF%E4%BB%A5%E7%B4%AF%E5%8A%A0%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">react是单向数据流，如何实现数据双向邦定？如何修改state自身值而使其可以累加？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8react%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%B6%EF%BC%8C%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%8E%E5%90%8E%E7%AB%AF%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E8%BF%9E%E8%B0%83%E7%9A%84"><span class="toc-number">1.18.</span> <span class="toc-text">在使用react项目开发时，你是如何与后端进行接口连调的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#props%E6%8E%A5%E6%94%B6%E4%BB%BB%E6%84%8F%E5%8F%82%EF%BC%8C%E9%82%A3%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fcontext%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.19.</span> <span class="toc-text">props接收任意参，那具体使用场景都有哪些？context的使用场景有哪些，分别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%92%8C%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B4%E8%AF%B4%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9Fhook%E4%B8%AD%E7%9A%84useEffect%E5%A6%82%E4%BD%95%E5%AF%B9%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">1.20.</span> <span class="toc-text">函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对类组件生命周期的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mobx"><span class="toc-number">1.21.</span> <span class="toc-text">Mobx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9redux%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8redux%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%EF%BC%89%EF%BC%9F"><span class="toc-number">1.22.</span> <span class="toc-text">简述一下你对redux的理解，以及你在项目中使用redux的流程是什么（类组件与函数组件）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E5%AE%83%E5%92%8Cvue%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.23.</span> <span class="toc-text">React是什么，它的优缺点，它和vue的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#React%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.23.1.</span> <span class="toc-text">React是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.23.2.</span> <span class="toc-text">它的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-react-devtool-%E5%AE%89%E8%A3%85"><span class="toc-number">1.24.</span> <span class="toc-text">开发工具 react-devtool 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-%E6%89%A9%E5%B1%95"><span class="toc-number">1.25.</span> <span class="toc-text">其他 -扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#react-Hooks%E7%8A%B6%E6%80%81%E5%BA%93"><span class="toc-number">1.25.1.</span> <span class="toc-text">react Hooks状态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redux%E4%B8%8Ertk%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.25.2.</span> <span class="toc-text">redux与rtk的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8react%E4%B8%AD%E4%BD%BF%E7%94%A8sass"><span class="toc-number">1.25.3.</span> <span class="toc-text">如何在react中使用sass</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {code.findCode();
document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>