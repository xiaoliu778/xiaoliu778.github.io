[{"title":"Cesium","url":"/2023/09/02/Cesium/","content":"Cesium介绍Cesium是使用javascript开的的基于WebGL的，实现三维地球和地图可视化的JS库。Cesium支持海量的三维模型数据，影像数据，地形高度数据，矢量数据等丰富的地理数据的加载。在交通，规划，城市规划，地形仿真等领域有非常广泛的应用。Cesium为三维的GIS提供了一个高效的可视化平台\nCesium的特点\n1、跨平台，跨浏览器，无插件\n2、强大的地理数据可视化能力。Cesium自定义的3D Tiles数据格式，支持海量数据渲染\n3、丰富可用的工具。Cesium支持三类地图模式，三维，二维，哥伦布视图（2.5D）。Cesium图层选择器定义了丰富的地图和地形图层，支持地址搜索和信息属性框等交互功能，支持全屏模型和网络虚拟现实(WebVR)。\n\n"},{"title":"常用到的css","url":"/2021/07/20/Css/","content":"css设置文字间距/* 使用css样式属性单词text-indent抬头距离，letter-spacing字与字间距。 */text-indent: 20px;/*抬头间距*/    阿三哥东方红郡kilo挖讽德诵功letter-spacing: 20px; /*字体间距*/阿 三 哥 东 方 红 郡 k i l o 挖 讽 德 诵 功","categories":["css"]},{"title":"Eslint","url":"/2022/07/11/Eslint/","content":"eslint\n默认eslint规则\n代码末尾不能加分号；\n代码中不能存在多行空行\ntab键不能使用，必须换成两个空格\n代码中不能存在声明了但未使用的变量\n\n\n\n最简单的方法，关闭eslint检测，其实很简单，把build&#x2F;webpack.base.conf.js配置文件中的eslint rules注释掉即可。但是不推荐这么做，eslint检测是有必要的，能保持良好代码风格\n第二种方法就是把不符合自己习惯的规则去掉，找到配置文件，名字以.eslintrc.*命名\nmodule.exports = &#123;  root: true,  parser: &#x27;babel-eslint&#x27;,  parserOptions: &#123;    //设置&quot;script&quot;（默认）或&quot;module&quot;如果你的代码是在ECMAScript中的模块。    sourceType: &#x27;module&#x27;  &#125;,  env: &#123;    browser: true,  &#125;,  // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style  extends: &#x27;standard&#x27;,  // required to lint *.vue files  plugins: [    &#x27;html&#x27;  ],  // add your custom rules here  &#x27;rules&#x27;: &#123;    // allow paren-less arrow functions    &#x27;arrow-parens&#x27;: 0,    // allow async-await    &#x27;generator-star-spacing&#x27;: 0,    // allow debugger during development    &#x27;no-debugger&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? 2 : 0,    &quot;no-unused-vars&quot;: [2, &#123;       // 允许声明未使用变量      &quot;vars&quot;: &quot;local&quot;,      // 参数不检查      &quot;args&quot;: &quot;none&quot;     &#125;],    // 关闭语句强制分号结尾    &quot;semi&quot;: [0],    //key值前面是否要有空格     &quot;key-spacing&quot;: [0, &#123;      &quot;singleLine&quot;: &#123;        &quot;beforeColon&quot;: false,        &quot;afterColon&quot;: true      &#125;,      &quot;multiLine&quot;: &#123;        &quot;beforeColon&quot;: true,        &quot;afterColon&quot;: true,        &quot;align&quot;: &quot;colon&quot;      &#125;，    //空行最多不能超过100行    &quot;no-multiple-empty-lines&quot;: [0, &#123;&quot;max&quot;: 100&#125;],    //关闭禁止混用tab和空格    &quot;no-mixed-spaces-and-tabs&quot;: [0],    //数组第一个指定是否启用这个规则，第二个指定几个空格    &quot;indent&quot;:[1,2],&#125;其中的rules就是配置规则的。\n\n配置参数rules:&#123;    &quot;规则名&quot;:[规则值，规则配置]&#125;\n规则值&quot;off&quot;或者0    //关闭规则关闭&quot;warn&quot;或者1    //在打开的规则作为警告（不影响退出代码）&quot;error&quot;或者2    //把规则作为一个错误（退出代码触发时为1）\n常见规则列表&quot;no-alert&quot;: 0,//禁止使用alert confirm prompt&quot;no-array-constructor&quot;: 2,//禁止使用数组构造器&quot;no-bitwise&quot;: 0,//禁止使用按位运算符&quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee&quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名&quot;no-class-assign&quot;: 2,//禁止给类赋值&quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句&quot;no-console&quot;: 2,//禁止使用console&quot;no-const-assign&quot;: 2,//禁止修改const声明的变量&quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1)&quot;no-continue&quot;: 0,//禁止使用continue&quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符&quot;no-debugger&quot;: 2,//禁止使用debugger&quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符&quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/&quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;&quot;no-dupe-args&quot;: 2,//函数参数不能重复&quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复&quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句&quot;no-empty&quot;: 2,//块语句中的内容不能为空&quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空&quot;no-empty-label&quot;: 2,//禁止使用空label&quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符&quot;no-eval&quot;: 1,//禁止使用eval&quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值&quot;no-extend-native&quot;: 2,//禁止扩展native对象&quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定&quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换&quot;no-extra-parens&quot;: 2,//禁止非必要的括号&quot;no-extra-semi&quot;: 2,//禁止多余的冒号&quot;no-fallthrough&quot;: 1,//禁止switch穿透&quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3.&quot;no-func-assign&quot;: 2,//禁止重复的函数声明&quot;no-implicit-coercion&quot;: 1,//禁止隐式转换&quot;no-implied-eval&quot;: 2,//禁止使用隐式eval&quot;no-inline-comments&quot;: 0,//禁止行内备注&quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数）&quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式&quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量&quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格&quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性&quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同&quot;no-labels&quot;: 2,//禁止标签声明&quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块&quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句&quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）&quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型&quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格&quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格&quot;no-multi-spaces&quot;: 1,//不能用多余的空格&quot;no-multi-str&quot;: 2,//字符串不能用\\换行&quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行&quot;no-native-reassign&quot;: 2,//不能重写native对象&quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有!&quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算&quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值&quot;no-new-func&quot;: 1,//禁止使用new Function&quot;no-new-object&quot;: 2,//禁止使用new Object()&quot;no-new-require&quot;: 2,//禁止使用new require&quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number&quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON()&quot;no-octal&quot;: 2,//禁止使用八进制数字&quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列&quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值&quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接&quot;no-plusplus&quot;: 0,//禁止使用++，--&quot;no-process-env&quot;: 0,//禁止使用process.env&quot;no-process-exit&quot;: 0,//禁止使用process.exit()&quot;no-proto&quot;: 2,//禁止使用__proto__属性&quot;no-redeclare&quot;: 2,//禁止重复声明变量&quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/&quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错&quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式&quot;no-script-url&quot;: 0,//禁止使用javascript:void(0)&quot;no-self-compare&quot;: 2,//不能比较自身&quot;no-sequences&quot;: 0,//禁止使用逗号运算符&quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名&quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用&quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格&quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2]&quot;no-sync&quot;: 0,//nodejs 禁止同步方法&quot;no-ternary&quot;: 0,//禁止使用三目运算符&quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格&quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super&quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;;&quot;no-undef&quot;: 1,//不能有未定义的变量&quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined&quot;no-undefined&quot;: 2,//不能使用undefined&quot;no-unexpected-multiline&quot;: 2,//避免多行表达式&quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾&quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;&quot;no-unreachable&quot;: 2,//不能有无法执行的代码&quot;no-unused-expressions&quot;: 2,//禁止无用的表达式&quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数&quot;no-use-before-define&quot;: 2,//未定义前不能使用&quot;no-useless-call&quot;: 2,//禁止不必要的call和apply&quot;no-void&quot;: 2,//禁用void操作符&quot;no-var&quot;: 0,//禁用var，用let和const代替&quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注&quot;no-with&quot;: 2,//禁用with &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格&quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来&quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号&quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter&quot;block-scoped-var&quot;: 0,//块语句中使用var&quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格&quot;callback-return&quot;: 1,//避免多次调用回调什么的&quot;camelcase&quot;: 2,//强制驼峰法命名&quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号&quot;comma-spacing&quot;: 0,//逗号前后的空格&quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾&quot;complexity&quot;: [0, 11],//循环复杂度&quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的&quot;consistent-return&quot;: 0,//return 后面是否允许省略&quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名&quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super&quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125;&quot;default-case&quot;: 2,//switch语句最后必须有default&quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾&quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号&quot;eol-last&quot;: 0,//文件以单一的换行符结束&quot;eqeqeq&quot;: 2,//必须使用全等&quot;func-names&quot;: 0,//函数表达式必须有名字&quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式&quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格&quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤&quot;handle-callback-err&quot;: 0,//nodejs 处理错误&quot;id-length&quot;: 0,//变量名长度&quot;indent&quot;: [2, 4],//缩进风格&quot;init-declarations&quot;: 0,//声明时必须赋初值&quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格&quot;lines-around-comment&quot;: 0,//行前/行后备注&quot;max-depth&quot;: [0, 4],//嵌套块深度&quot;max-len&quot;: [0, 80, 4],//字符串最大长度&quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度&quot;max-params&quot;: [0, 3],//函数最多只能有3个参数&quot;max-statements&quot;: [0, 10],//函数内最多有几个声明&quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用&quot;new-parens&quot;: 2,//new时必须加小括号&quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行&quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格&quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法&quot;one-var&quot;: 1,//连续声明&quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的&quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首&quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行&quot;prefer-const&quot;: 0,//首选const&quot;prefer-spread&quot;: 0,//首选展开运算&quot;prefer-reflect&quot;: 0,//首选Reflect的方法&quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &#x27;&#x27;&quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号&quot;radix&quot;: 2,//parseInt必须指定第二个参数&quot;id-match&quot;: 0,//命名检测&quot;require-yield&quot;: 0,//生成器函数必须有yield&quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾&quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格&quot;sort-vars&quot;: 0,//变量声明时排序&quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格&quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格&quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格&quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格&quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格&quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格&quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格&quot;spaced-comment&quot;: 0,//注释风格要不要有空格什么的&quot;strict&quot;: 2,//使用严格模式&quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN()&quot;valid-jsdoc&quot;: 0,//jsdoc规则&quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值&quot;vars-on-top&quot;: 2,//var必须放在作用域顶部&quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格&quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来&quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件","categories":["eslint"]},{"title":"expo版rn","url":"/2023/06/08/ExpoRN/","content":"","categories":["RN"]},{"title":"Python","url":"/2021/08/20/Python/","content":"Anaconda\nAnaconda是用来管理python的工具就像，就跟nvm(用来管理node的版本的工具)一样\n\n安装Anaconda这个是用来管理Python版本的，他可以实现Python的多版本切换。安装时按默认的一路next就行。\n看版本\n打开conda prompt，输入conda -V 弹出版本号即为正确安装：栗：C:\\Users\\levero&gt; conda -Vconda 22.9.0conda版本，对上即可\n\n配置库包下载环境，加快网络速度替换下载库包地址为国内的清华镜像站。\n执行下面：\nconda config --set show_channel_urls yes\n生成.condarc 文件在C:\\Users\\leover下用记事本打开并修改.condarc文件。\n把下面的内容全部复制进去，全部覆盖原内容，ctrl+s保存，关闭文件：\nchannels:  - defaultsshow_channel_urls: truechannel_alias: https://mirrors.tuna.tsinghua.edu.cn/anacondadefault_channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloudssl_verify: true\n更改完成后，在命令行输入以下命令完成配置的更新：\nconda config --set show_channel_urls yes\n\nAnaconda修改python版本\n查看选择修改版本号\nconda search –full –name python\n\n\n使用python -V命令查看当前虚拟环境的python版本：\npython -V\n\n\n已知python版本为3.8.0，现在我想把它升级为3.10.6。\n使用命令：\nconda install python&#x3D;3.10.6  &#x2F;&#x2F;3.8版本号\n\n\n如果在conda install python&#x3D;3.10.6中遇到问题，例如：Solving environment: failed with initial frozen solve. Retrying with flexible solve.3.10.6\n则可以先使用：\nconda uninstall python\n对前版本python进行卸载，然后再使用conda install python&#x3D;3.10.6安装即可。\n\n\n\n\n\n1、1. 改变anaconda默认python版本：首先创建一个名为python36的环境，指定的Python版本是3.6。在命令行里输入：conda create --name python36 python=3.62、conda create -n py36python=3.6 anaconda ——等待更新完，然后输入以下命令。（因为要把python3.6的相关包下载下来，所以比较慢，请耐心等待）3、activate py364、python --version  可以看到，系统已经切换到了3.6的环境。作者：小赛TT链接：https://www.jianshu.com/p/a3a2218294f3来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":["python"]},{"title":"TypeScript","url":"/2022/01/26/TypeScript/","content":"什么的是TypeScript\njs的超集(超级集合)\n包含js里所有的元素\n能运行js代码\n支持ES语法(ES6,ES7…)\n是一种开源、跨平台的编程语言\n\n\n编译器编译为js代码，js解析器执行\n完全兼容js代码\n静态类型检查器\n静态类型，更加严格的语法\n减少运行时异常出现的几率\n后期维护\n\n\n\n写ts前的一些小配置\n安装TypeScript\nnpm install -g typescript\ntsc -v 查看typescript版本号\n\n\n编译ts文件为js文件\n手动编译为js\ntsc 文件名\n\n\nvscode自动编辑 (快速生成tsconfig.json)\ntsc –init 生成配置文件\n修改配置文件tsconfig.json\n“outDir”:”.&#x2F;js”\n“strict”:false\n\n\n启动监视任务\n终端\n运行任务\n监视tsconfig.json\n\n\n\n\n\n\n\n类型声明基础类型let num:Number=10num =11function ab(a:string)&#123;console.log(a);&#125;ab(&#x27;1111&#x27;)// 类型声明 指定ts变量(参数，形参)的类型 ts编译器，自动检查// 类型声明给变量设置了类型，使用变量只能存储某种类型的值// 布尔类型 booleanlet flag : boolean = true// flag = 123 报错 flag = false// 数字类型 Numberlet a:number = 10 //十进制let a1:number = 0b1010//二进制let a2:number = 0o12 //八进制let a3:number = 0xa  //十六进制a = 11//字符串类型 stringlet str:string = &#x27;123&#x27;// str=123str=&#x27;&#x27;// undefined和null，用的不多let u:undefined=undefinedlet n:null=nullconsole.log(u,n);// u=123 // undefined和null还可以作为其他类型的子类型   XXX行得通但是ts里会报错，js里没有事情// 可以吧undefined和null 赋值给其他类型的变量let b:number=undefinedlet str1:String= nullconsole.log(b,str1);\n数组// 定义数组一：let arr1:number[]=[1,2,3]arr1=[1,2,3]// 定义数组二：泛型let arr2:Array&lt;number&gt;=[12,20,30]\n对象\nobject 表示非原始类型，除了number、string、boolean之外的类型let obj:object=&#123;&#125;// 字面量// obj=123 报错// obj=&#x27;&#x27; 报错obj=nullobj=undefinedobj=[]obj= new String()  //实例对象obj=String\n\nany\nany 任何类型let h:any = 123h=trueh=&#x27;123&#x27;h=&#123;&#125;h=[]let newArr:any[]=[100,2,3,&quot;&quot;,true]// 有优点也有缺点console.log(newArr[0].split(&#x27;&#x27;));\n\nvoid\nvoid空值 ，便是没有任何返回值的函数function fun1():void&#123;    console.log(123);    // return undefined&#125;console.log(fun1());// 没有任何类型let v:void=undefined  \n\n类型推断// ts在没有明确的指定类型的时候推测一个类型// 两种情况// 1、定义变量的时候，直接给变量赋值，则定义类型为对应的类型// 2、定义变量的时候，没有赋值，则定义类型为iany类型let t=123; //将t定义为了一个number类型通过类型推断// t=&quot;&quot; 报错let g;g=123g=[]g=&#123;&#125;g=&quot;&quot;\n联合类型\n表示取值可以为多种类型中的一种// flag true，1, false，0let f:boolean |number | string  = truef=123  //再次赋值，类型推断，给变量定义一个类型f=&#x27;123&#x27;// f=trueconsole.log(f.split(&#x27;&#x27;));\n\n接口对象类型// 它是对行为的抽象，用于对[对象的形状(Shape)]进行描述，理解为一种约束// 接口一般首字母大写，// 定义的变量比接口少了一些属性是不允许的，不能多出其他的属性// ?表示可选属性，定义对象 ? 的属性可有可无// [propName:string]:any 任意属性和任意属性值// [propName:string]:string 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集// 可以用 readonly(瑞得令) 定义只读属性// 定义接口  interface(阴的费嘶)interface IPerson&#123;    readonly id:number,    name:string,    age:number,    sex?:string,    // [propName:string]:any,    [propName:string]:string |number | boolean&#125;let p:IPerson=&#123;    id:10,    name:&#x27;zhangsan&#x27;,    age:18,    // sex:&#x27;男&#x27;,    width:&quot;&quot; //报错&#125;// p.id=11\n数组类型// 不常用interface INewArray&#123;    [index:number]:number //任意属性，index表示数组中的下标&#125;// [1,2,3,4]  arr[0]--&gt;obj[&#x27;name&#x27;]//  0,1,2,3let arr:INewArray=[1,2,3,4]\n函数类型interface ISeacrchFunc&#123;    // (参数: 类型,....)：返回值得类型    (a: string,b: string): boolean&#125;// 参数，返回值const fun1:ISeacrchFunc=function(a:string,b:string):boolean&#123;    return a.search(b) !== -1&#125;console.log(fun1(&#x27;123&#x27;,&#x27;2&#x27;));\n\n函数函数声明和表达式// // 函数声明，命名函数// function add(a,b)&#123;//     return a+b// &#125;// // 函数表达式，匿名函数// let add2=function(a,b)&#123;//     return a+b// &#125;// ts 函数声明，命名函数 // a 和 b 都是number类型// :number 表示该函数的返回值为number类型function add(a:number,b:number):number&#123;    return a+b&#125;console.log(add(1,2));let c:number=add(1,2)console.log(c);// 函数表达式，匿名函数let add2=function(a:number,b:number):number&#123;    return a+b&#125;console.log(add2(1,2));// 函数完整的写法let add3:(a:number,b:number)=&gt;number=function(a:number,b:number):number&#123;    return a+b&#125;\n可选参数和默认参数\n可选参数 ? 必选参数不能位于可选参数后let getName=function(x:string,y?:string,z:string=&quot;你好&quot;):string&#123;    return x+y+z&#125;// console.log(getName(&#x27;zhang&#x27;));// 默认参数console.log(getName(&quot;张三&quot;));\n\n剩余参数和默认参数// 剩余参数function fn(x:string,y:string,...args:number[])&#123;    console.log(x,y,args);    &#125;fn(&#x27;&#x27;,&#x27;&#x27;,1,2,3,4,5)// 函数重载 ：函数名相同，形参不同的多个函数// 数字 相加，字符串 拼接 ... 联合类型// 函数重载声明,可以使用重载定义多个 newAdd 的函数类型function newAdd(x:string,y:string):stringfunction newAdd(x:number,y:number):number// 函数实现function newAdd(x:string|number, y:string|number):string|number &#123;    if (typeof x == &#x27;string&#x27; &amp;&amp; typeof y == &#x27;string&#x27;) &#123;        return x + y; //字符串拼接    &#125;    else if (typeof x == &#x27;number&#x27; &amp;&amp; typeof y == &#x27;number&#x27;) &#123;        return x + y; //数字相加    &#125;&#125;// 然而这样有一个缺点，就是不能够精确的表达，// 输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。console.log(newAdd(1,2));console.log(newAdd(&#x27;张&#x27;,&#x27;三&#x27;)); \n类型断言// 定义一个函数，获取到一个数组或者字符串的长度// 类型断言：可以手动指定一个类型// 两种方式// 1、变量 as 类型// 2、(&lt;类型&gt;变量)// 讲一个联合类型断言为其中一个类型function getLength(x:string|number):number&#123;    if((x as string).length)&#123;        return (&lt;string&gt;x).length    &#125;else&#123;        return x.toString().length    &#125;&#125;console.log(getLength(&#x27;123&#x27;));console.log(getLength(123));// 将任何一个类型断言为 any ,any类型是访问任何属性和方法的(window as any).a=123\n\n进阶类型别名type s=string //通过type给类型起别名type all=string|number|booleanlet str:s=&quot;!123&quot;// str=123// 常用于给联合类型起别名let a:all = 123a=&#x27;&#x27;let b:all = trueb=123\n字符串字面量类型// 用来约束取值只能是某几个字符串中的一个// 张三封，张三，张牛马type stringType=&quot;张三封&quot; | &quot;张三&quot; | &quot;张牛马&quot;let names:stringType=&quot;张三封&quot;\n元组Tuplelet arr:number[] = [1,2,3,4]// 数值和字符串// 元组(Tuple) 合并了不同类型的对象let Tarr:[number,string]=[123,&quot;123&quot;]// 添加内容的时候，需要是number或者string类型Tarr.push(456)Tarr.push(&quot;456&quot;)// Tarr.push(true) 报错\n枚举\n使用枚举类型给一组数组赋予名称\n可以通过名称去拿取值，通过值拿取名称\n枚举成员被赋值为从0开始递增的数字，同时也会对枚举值到枚举名进行反向映射// 1,2,3,4enum numberType&#123;    one=2, //手动赋值，没有赋值，第一个参数默认为0，后面的递增+1    two=1,//后面的值如果没有手动赋值，会根据前面的值进行递增+1    three,    four,&#125;// 手动赋值注意：尽量不要写一些重复的值console.log(numberType);// 枚举项有两种类型：常数项（constant member）和计算所得项（computed member）// 计算所得项需要放置在已经确定赋值的枚举项之前，后面不能存放为手动赋值的手动项enum Color&#123;    red,    blue=&quot;blue&quot;.length,    green=11&#125;// 常数枚举是使用const enum定义的枚举类型// 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含任何计算成员const enum Obj&#123;    o,    b,    j=10+101&#125;console.log(Obj.o);console.log(Obj.b);console.log(Obj.j);// 外部枚举(Ambient Enums) 是使用 declare(滴窥儿) enum 定义的枚举类型// declare 定义的类型只会用于编译时的检查，编译结果中会被删除// 声明文件declare const enum ABC&#123;    a,    b,    c&#125;console.log(ABC.a);\n\nts进阶\n类型别名\n通过type去定义，用来给一个类型起个新名字\n\n\n字符串字面量类型\n用来约束取值只能是某几个字符串中的一个\n\n\n元组Tuple(台坡)\n\n类属性和方法\n类：描述了所创建的对象共同的属性和方法// 实例化对象class Person&#123;    name:string    age:number    constructor(name:string,age:number)&#123;        this.name=name        this.age=age    &#125;    sayHi(str:string)&#123;        console.log(&#x27;hi&#x27;+str);            &#125;&#125;let p = new Person(&#x27;zs&#x27;,12) //new的时候，会执行类中构造方法constructorp.sayHi(&#x27;李四&#x27;)\n\n继承// 扩展现有的类，通过继承// 继承：类与类之间的关系// 子类继承父类class Animal&#123; //父类    name:string    age:number    constructor(name:string,age:number)&#123;        this.name=name        this.age=age    &#125;    sayHi(str:string)&#123;        console.log(&#x27;hi&#x27;+str);            &#125;&#125;// 子类class Dog extends Animal&#123;    constructor(name:string,age:number)&#123;        // 调用父类的构造函数，使用super        super(name,age)    &#125;    // 可以调用父类的方法，还可以重写父类的方法    sayHi()&#123;     console.log(&#x27;我是Dog类的sayHi方法&#x27;);        super.sayHi(&#x27;狗子&#x27;)    &#125;&#125;const a = new Animal(&#x27;小猫&#x27;,1)a.sayHi(&#x27;小猫&#x27;)const d = new Dog(&#x27;拉布拉多&#x27;,2)d.sayHi()// 总结：类与类之间存在继承关系，通过extends进行继承// 子类可以调用父类的方法，通过super// 子类还可以重写父类的方法\n存取器// 存取器，可以帮助我们控制对象成员的访问class Name&#123;    firstName:string    lastNAme:string    constructor(firstNAme:string,lastName:string)&#123;        this.firstName = firstNAme        this.lastNAme = lastName    &#125;    // 设置存取器    // 读取器--&gt;用来读取数据    get fullName()&#123;        // 姓名=姓氏+名字        return this.firstName+&#x27;-&#x27;+this.lastNAme        // return &quot;张三&quot;    &#125;    // 设置器--&gt;用来设置数据    set fullName(value)&#123;        console.log(value);        let names=value.split(&#x27;-&#x27;)        this.firstName=names[0]        this.lastNAme=names[1]            &#125;&#125;const n=new Name(&#x27;张&#x27;,&#x27;狗子&#x27;)console.log(n);n.fullName=&quot;张-三封&quot;console.log(n.fullName);\n静态方法\n静态成员\n只属于类自己的属性和方法// 静态方法// 静态属性class A&#123;    static name1:string    // constructor(name:string)&#123;    //     this.name=name    // &#125;    static sayHi()&#123;        console.log(&#x27;hi&#x27;);            &#125;&#125;const a1 = new A()console.log(A.name1);A.sayHi()// console.log(a1.name); //报错// a1.sayHi() //报错\n\n修饰符\npublic 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\nprivate(拍喂特) 修饰的属性或方法是私有的，不能在声明它的类的外部访问，包括其子类也不能，但是这个属性和方法是可以被继承的\nprotected(坡柔太克特的) 被访问的修饰的属性或方法是受保护的，它和 private类似，区别是它在子类中也是允许class B&#123;    public gender:string //公有的属性    private name1:string //私有的属性    protected age:number //受保护的属性    public constructor(name:string,age:number)&#123; //共有的方法        this.name1 = name        this.age=age    &#125;    public p()&#123;        console.log(this.name1);        console.log(this.age);                    &#125;&#125;class C extends B&#123;    constructor(name1:string,age:number)&#123;        super(name1,age)    &#125;    play()&#123;        // console.log(this.name1);        console.log(this.age);                    &#125;&#125;const b=new B(&#x27;张三&#x27;,12)const c=new C(&#x27;张三封&#x27;,13)// console.log(c.age);// console.log(b.name1);// b.p()c.play()\n\nreadonly修饰符class X&#123;    // readonly age:number  //只读属性，但是在构造函数是可以修改的    // readonly以及三个修饰符定义在参数上，那就是创建并且会初始化age参数    // constructor(readonly age:number)&#123;    // constructor(public age:number)&#123;    // constructor(private age:number)&#123;    constructor(protected age:number)&#123;        // this.age=age    &#125;    update()&#123;        // this.age=122  报错，不能被修改 ， 只读属性    &#125;&#125;const x = new X(111)console.log(x);// x.age=115\n抽象类// abstract(啊波嘶拽科特)abstract class Y&#123; //定义一个抽象类，为子类服务    abstract name:string //抽象属性    // constructor(name)&#123;    //     this.name=name    // &#125;    abstract sayHi() //不能够有具体实现&#125;// 不能够被实例化class Z extends Y&#123;    name: string    constructor(name)&#123;        super()        this.name=name    &#125;    // 在子类中去具体实现抽象类中的抽象方法    sayHi()&#123;        console.log(&#x27;hi&#x27;);            &#125;&#125;const z=new Z(&#x27;张三&#x27;)console.log(z.name);z.sayHi()\n类的类型class Car&#123;    name:string    constructor(name:string,)&#123;        this.name=name    &#125;&#125;class Ben extends Car&#123;    age:number    constructor(name)&#123;        super(name)    &#125; &#125;const car:Car=new Car(&#x27;&#x27;)const ben:Ben=new Ben(&#x27;&#x27;)\n类实现接口// implements(阴坡门(三声)呲)interface ISing&#123;    // 这个方法是没有任何的实现    sing()&#125;interface IDance&#123;    dance()&#125;class P implements ISing,IDance&#123;//人 唱歌，跳舞    sing() &#123;        console.log(&#x27;唱&#x27;);            &#125;    dance() &#123;        console.log(&#x27;跳rap&#x27;);            &#125;&#125;class An implements ISing,IDance&#123;//动物 唱歌，跳舞    sing() &#123;        console.log(&#x27;唱&#x27;);            &#125;    dance() &#123;        console.log(&#x27;跳rap&#x27;);            &#125;&#125;const p1=new P()const an=new An()p1.sing()an.sing()p1.dance()an.dance()\n接口继承接口interface IRun&#123;    run()&#125;interface ISwim&#123;     swinm()&#125;// 接口是可以继承其他多个接口的interface IActive extends IRun,ISwim&#123;&#125;// ...class I implements IActive&#123;    run() &#123;            &#125;    swinm() &#123;            &#125;&#125;\n声明合并// 函数合并--&gt;函数重载// 接口合并// 合并的属性的类型必须是唯一的// 类的合并和接口合并规则一样的interface Cat&#123;    name:&quot;栗子&quot;,    gender:&quot;女&quot;&#125;interface Cat&#123;    name:&quot;栗子&quot;    age:3&#125;const cat:Cat=&#123;    name:&quot;栗子&quot;,    age:3,    gender:&quot;女&quot;&#125;\n\n泛型泛型的简单使用// 需求：定义一个函数，传入两个参数，第一个参数是数据，第二个参数是数量// 函数的作用:根据数量产生对应个数的数据，存放在一个数组中 // (123,3)--&gt;[123,123,123]// 数值// T表示function getArr&lt;T&gt;(value:T,count:number):T[]&#123;    const arr:T[]=[]    for(let i=0;i&lt;count;i++)&#123;        arr.push(value)    &#125;    return arr&#125;// 原则上不推荐any// 使用泛型，在定义时不需要先确定类型，而是在使用的时候再去确定// 如果没有确定的话，就睡走类型推断console.log(getArr(123,3));console.log(getArr&lt;string&gt;(&#x27;123&#x27;,4));[123,&quot;&quot;,true,&#123;&#125;,[]]     \n多个泛型参数的函数// [123,&quot;123&quot;]--&gt;[&quot;123&quot;,123]function updateArr&lt;T,U&gt;(t:[T,U]):[U,T]&#123;    return [t[1],t[0]]&#125;console.log(updateArr&lt;string,number&gt;([&#x27;123&#x27;,123]));console.log(updateArr&lt;boolean,number&gt;([true,123]));\n泛型约束// 获取一个参数的长度// 泛型约束，约束这个输入的任意类型，必须要有length属性interface ILength&#123;    length:number&#125;function getLength&lt;T extends ILength&gt;(x:T):number&#123;    return x.length&#125;console.log(getLength(&quot;123&quot;));\n泛型接口// 定义一个泛型接口// interface IArr&#123;//     &lt;T&gt;(value:T,count:number):Array&lt;T&gt; // &#125;interface IArr&lt;T&gt;&#123;    (value:T,count:number):Array&lt;T&gt; &#125;let getArr1:IArr&lt;string&gt; = function &lt;T&gt;(value:T,count:number):T[]&#123;    const arr:T[]=[]    for(let i=0;i&lt;count;i++)&#123;        arr.push(value)    &#125;    return arr&#125;console.log(getArr1(&quot;123&quot;,3));interface IPerson&lt;T&gt;&#123;    name:T&#125;let p:IPerson&lt;string&gt;=&#123;    name:&quot;&quot;&#125;let p1:IPerson&lt;number&gt;=&#123;    name:123&#125;\n泛型类class Person&lt;T&gt;&#123;    name:string    age:T    constructor(name:string,age:T)&#123;        this.name=name        this.age=age    &#125;&#125;const person=new Person&lt;string&gt;(&quot;123&quot;,&quot;333&quot;)const person1=new Person&lt;number&gt;(&quot;123&quot;,111)\n\n装饰器装饰器的使用function addAge(constructor:Function)&#123;    constructor.prototype.age = 18&#125;@addAgeclass Person&#123;    name:string;    age!:number;    constructor()&#123;        this.name = &#x27;huihui&#x27;    &#125;&#125;let person = new Person();console.log(person.age);\n\n其他import 和 import type的区别import type 是用来协助进行类型检查和声明的，在运行时是完全不存在的。\n\nimport type\n在ts 3.8中import type，希望能够用一种更加清晰移动的方式来控制某个导入是否要被删除掉\n使用import type 和export type 导入和导出的类型只能在类型上下文中使用，不能作为一个值来使用\n\n\nimport \n会在编译时删掉你导入的类\n\n\n注意点class\nclass既可以代表一个类型，也可以代表一个值，他在runtime是有实际意义的，所以用import type 引入一个class的时候，不能用到它值得含义，不能 extends 这个class\n\n\n不可以同时引入默认个命名绑定使用 import type 的时候，可以引入一个默认导出的类型，也可以引入命名绑定的形式导出的类型，但是不可以同时使用两者.import type Foo,&#123;Bar,Baz&#125; from &#x27;...&#x27;// 借误!仅类型导入可以指定默认导入或命名绑定，但不能同时指定两者\nimport 和 import type有什么区别\n可以导入的内容相同，但是使用的方式不同import 和 import type 都可以导入一个类型或一个值，但是使用import type 导入的值，只能在类型上下文中使用，不能作为一个值来使用，而 import 导入的类型和值，都可以按照其原本的意义试用// type.tsexport type UnionType = string | number;export const unionValue: UnionType = &#x27;1&#x27;;// value.tsimport &#123; UnionType, unionValue &#125; from &#x27;./type&#x27;;const value1: UnionType = &#x27;value1&#x27;; // 作为类型使用const value2: typeof unionValue = &#x27;value2&#x27;; // 获取类型const value3 = unionValue; // 作为值使用// value1.tsimport type &#123; UnionType, unionValue &#125; from &#x27;./type&#x27;;const value1: UnionType = &#x27;value1&#x27;; // 作为类型使用const value2: typeof unionValue = &#x27;value2&#x27;; // 获取类型// Error: &quot;unionValue&quot; 是使用 &quot;import type&quot; 导入的，因此不能用作值const value3 = unionValue; // 作为值使用// import type导入的内容只能用在跟类型相关的地方.\n\n\n\n跟import type有关的tsconfig.json项\nimportsNotUsedAsValues跟 import type 一起在 3.8 中引入的还有一个编译项importsNotUsedAsValues来控制怎么处理在runtime阶段不会用到的import(这里控制import，所有使用import type 的都会在编一阶段被删除),这个编译项有三个值\nremove: 默认行为, 会删除那些仅作为类型出现的导入.(删除仅引用类型的import语句的默认行为。)\npreserve: 保留所有值或者类型没有被使用的导入. 这种方式会保留所有的导入和副作用.\nerror: 这种方式将保留所有的导入(跟preserve一样), 但如果导入的一个值只作为类型被使用, 则会报错.\n\n\n\ntsconfig.json常使用配置项说明&quot;target&quot;: &quot;es2016&quot; //ts最终要编译成js某个的版本&quot;outDir&quot;:&quot;./&quot; // 表示ts文件最终编译为js文件，js文件存放的位置&quot;strict&quot;:&quot;false&quot; //严格模式默认开启\n\n在一个js的rn项目改成ts的步骤\n删除babel.config.js(他俩会有冲突，因为编译时有些地方不一样)\n卸载babel-preset-expo npm uninstall babel-preset-expo\n安装typescript依赖 npm install @types&#x2F;react @types&#x2F;react-native @types&#x2F;expo typescript -D\n创建typescript配置文件 tsc –init\n创建rn-cli.config.jsmodule.exports = &#123;  getTransformModulePath() &#123;    return require.resolve(&quot;react-native-typescript-transformer&quot;);  &#125;,  getSourceExts() &#123;    return [&quot;ts&quot;, &quot;tsx&quot;];  &#125;&#125;;\n\n修改源码修改App.js为App.tsx\n运行npm run android\nRN &gt;&#x3D; 0.59metro.config.js\nmodule.exports = &#123;  transformer: &#123;    babelTransformerPath: require.resolve(&#x27;react-native-typescript-transformer&#x27;)  &#125;&#125;;\nRN &gt;&#x3D; 0.57, &lt; 0.59rn-cli.config.js\nmodule.exports = &#123;  transformer: &#123;    babelTransformerPath: require.resolve(&#x27;react-native-typescript-transformer&#x27;)  &#125;&#125;\nRN &lt; 0.57rn-cli.config.js\nmodule.exports = &#123;  getTransformModulePath() &#123;    return require.resolve(&#x27;react-native-typescript-transformer&#x27;);  &#125;,  getSourceExts() &#123;    return [&#x27;ts&#x27;, &#x27;tsx&#x27;];  &#125;&#125;","categories":["typeScript"]},{"title":"expo","url":"/2023/02/19/expo/","content":"什么是expo\nExpo是一组工具、库和服务，可以通过编写javaScript来构建本地的iOS和android应用程序。说人话就是在React Native的基础上在封装一层，让我们开发更加方便，更快\n使用expo，会比你开发一个裸的React Native快很多，而且会少踩很多坑\n没有做过移动端的朋友就更需要这个了，要不然移动端的一些隐藏的限制和坑，会很让人头疼\n\n\n\n项目搭建流程安装expo 安装expocli脚手架npm install --global expo-cli\n创建项目expo init my-project","categories":["RN"]},{"title":"http","url":"/2021/08/07/http/","content":"Js强制缓存和协商缓存\n强制缓存栗子：假如页面需要引入一个logo并且不会频繁的更改，那么就可以tongg服务端响应头中设置强制缓存来优化该请求：// 强制缓存一个月Cache-Control: public, max-age=2592000在用户第一次访问该图片之后，浏览器会将其缓存起来，并且在未过期之前不会再想服务端发送请求。这样减少了网络请求，提高页面加载速度\n协商缓存栗子：在网页中引用了一个JavaScript文件，希望文件发生变化时通知浏览器重新获取最新版本。可以通过在服务端的响应头中设置协商缓存来实现：// 设置 Last-Modified 和 ETagLast-Modified: Mon, 10 Jul 2023 12:00:00 GMTETag: &quot;abcd1234&quot;当浏览器再次发送请求时，会携带上一次请求中的Last-Modified和ETag，服务器会通过对比这些值来判断资源是否发生变化。如果资源未发生变化，服务器返回304 Not Modified，浏览器则使用缓存的版本；如果资源发生了变化，服务器会返回新的资源以及更新的响应头。// 这两个例子展示了如何使用强制缓存和协商缓存来优化网页加载性能。通过合理配置缓存策略，可以有效减少网络请求，提高用户体验。\n\n","categories":["http面试题"]},{"title":"package文件解析","url":"/2022/10/29/package/","content":"文件展示当我们搭建一个新项目时，往往脚手架就帮我们初始化好了一个 package.jaon 配置文件，它位于项目的根目录中。当使用 react 脚手架（create-react-app）初始化一个项目时，其 package.json 文件内容如下：\n&#123;  &quot;name&quot;: &quot;my-app&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;private&quot;: true,  &quot;dependencies&quot;: &#123;    &quot;@testing-library/jest-dom&quot;: &quot;^5.14.1&quot;,    &quot;@testing-library/react&quot;: &quot;^11.2.7&quot;,    &quot;@testing-library/user-event&quot;: &quot;^12.8.3&quot;,    &quot;react&quot;: &quot;^17.0.2&quot;,    &quot;react-dom&quot;: &quot;^17.0.2&quot;,    &quot;react-scripts&quot;: &quot;4.0.3&quot;,    &quot;web-vitals&quot;: &quot;^1.1.2&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  &#125;,  &quot;eslintConfig&quot;: &#123;    &quot;extends&quot;: [      &quot;react-app&quot;,      &quot;react-app/jest&quot;    ]  &#125;,  &quot;browserslist&quot;: &#123;    &quot;production&quot;: [      &quot;&gt;0.2%&quot;,      &quot;not dead&quot;,      &quot;not op_mini all&quot;    ],    &quot;development&quot;: [      &quot;last 1 chrome version&quot;,      &quot;last 1 firefox version&quot;,      &quot;last 1 safari version&quot;    ]  &#125;&#125;\n\n必须属性\nname: 项目&#x2F;模块名称，长度必须小于等于214个字符，不能以”.“(点)或者”_“(下划线)开头，不能包含大写字母。\nversion：项目版本version 字段表示该项目包的版本号，它是一个字符串。在每次项目改动后，即将发布时，都要同步的去更改项目的版本号。版本号的使用规范如下：\n版本号的命名遵循语义化版本 2.0.0 规范，格式为：「主版本号. 次版本号. 修订号」，通常情况下，修改主版本号是做了大的功能性的改动，修改次版本号是新增了新功能，修改修订号就是修复了一些 bug；\n如果某个版本的改动较大，并且不稳定，可能如法满足预期的兼容性需求，就需要发布先行版本，先行版本通过会加在版本号的后面，通过 “-” 号连接以点分隔的标识符和版本编译信息：内部版本（alpha）、公测版本（beta）和候选版本（rc，即 release candiate）// 查看最新版本npm view react version// 查看所有版本npm view react versions\n\n\n\n描述信息package.jaon 中有五个和项目包描述信息相关的配置字段，下面就分别来看看这些字段的含义。\ndescription\ndescription 字段用来描述这个项目包，它是一个字符串，可以让其他开发者在 npm 的搜索中发现我们的项目包。\n\nkeywords\nkeywords 字段是一个字符串数组，表示这个项目包的关键词。和 description 一样，都是用来增加项目包的曝光率的。下面是 eslint 包的描述和关键词：\n\n\nauthor\nauthor 顾名思义就是作者，表示该项目包的作者。它有两种形式，一种是字符串格式：&quot;author&quot;: &quot;CUGGZ &lt;xxxxx@xx.com&gt; (https://juejin.cn/user/3544481220801815)&quot; \n另一种是对象形式：&quot;author&quot;: &#123;  &quot;name&quot; : &quot;CUGGZ&quot;,  &quot;email&quot; : &quot;xxxxx@xx.com&quot;,  &quot;url&quot; : &quot;https://juejin.cn/user/3544481220801815&quot;&#125;\n\ncontributors\ncontributors 表示该项目包的贡献者，和 author 不同的是，该字段是一个数组，包含所有的贡献者，它同样有两种写法：&quot;contributors&quot;: [  &quot;liuxiaoye &lt;xxxxx@xx.com&gt; (xxxx)&quot;,  &quot;liuxiaoye &lt;xxxxx@xx.com&gt; (xxxx)&quot; ] \n&quot;contributors&quot;: [  &#123;   &quot;name&quot; : &quot;liuxiaoye&quot;,   &quot;email&quot; : &quot;xxxxx@xx.com&quot;,   &quot;url&quot; : &quot;xxxx&quot; &#125;,  &#123;   &quot;name&quot; : &quot;liuxiaoye&quot;,   &quot;email&quot; : &quot;xxxxx@xx.com&quot;,   &quot;url&quot; : &quot;xxxx&quot; &#125; ]\n\nhomepagehomepage 就是项目的主页地址了，它是一个字符串。\nrepositoryrepository 表示代码的存放仓库地址，通常有两种书写形式。第一种是字符串形式：\n&quot;repository&quot;: &quot;https://github.com/facebook/react.git&quot; \n除此之外，还可以显式地设置版本控制系统，这时就是对象的形式：\n&quot;repository&quot;: &#123;  &quot;type&quot;: &quot;git&quot;,  &quot;url&quot;: &quot;https://github.com/facebook/react.git&quot;&#125;\nbugsbugs 表示项目提交问题的地址，该字段是一个对象，可以添加一个提交问题的地址和反馈的邮箱：\n&quot;bugs&quot;: &#123;   &quot;url&quot; : &quot;https://github.com/facebook/react/issues&quot;,  &quot;email&quot; : &quot;xxxxx@xx.com&quot;&#125;\n最常见的 bugs 就是 Github 中的 issues 页面，如上就是 react 的 issues 页面地址。\n依赖配置通常情况下，我们的项目会依赖一个或者多个外部的依赖包，根据依赖包的不同用途，可以将他们配置在下面的五个属性下：dependencies、devDependencies、peerDependencies、bundledDependencies、optionalDependencies 。下面就来看看每个属性的含义。\ndependenciesdependencies 字段中声明的是项目的生产环境中所必须的依赖包。当使用 npm 或 yarn 安装 npm 包时，该 npm 包会被自动插入到此配置项中：\nnpm install &lt;PACKAGENAME&gt;yarn add &lt;PACKAGENAME&gt;\n当在安装依赖时使用 –save 参数，也会将新安装的 npm 包写入 dependencies 属性。\nnpm install --save &lt;PACKAGENAME&gt;\n该字段的值是一个对象，该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。\n&quot;dependencies&quot;: &#123;   &quot;react&quot;: &quot;^17.0.2&quot;,   &quot;react-dom&quot;: &quot;^17.0.2&quot;,   &quot;react-scripts&quot;: &quot;4.0.3&quot;,&#125;,\n\n这里每一项配置都是一个键值对（key-value）， key 表示模块名称，value 表示模块的版本号。版本号遵循「主版本号. 次版本号. 修订号」的格式规定：\n\n「固定版本：」 上面的 react-scripts 的版本 4.0.3 就是固定版本，安装时只安装这个指定的版本；\n\n「波浪号：」 比如~ 4.0.3，表示安装 4.0.x 的最新版本（不低于 4.0.3），也就是说安装时不会改变主版本号和次版本号；\n\n「插入号：」 比如上面 react 的版本 ^17.0.2，表示安装 17.x.x 的最新版本（不低于 17.0.2），也就是说安装时不会改变主版本号。如果主版本号为 0，那么插入号和波浪号的行为是一致的；\n\nlatest：安装最新的版本。\n\n\n需要注意，不要把测试或者过渡性的依赖放在 dependencies，避免生产环境出现意外的问题。\ndevDependenciesdevDependencies 中声明的是开发阶段需要的依赖包，如 Webpack、Eslint、Babel 等，用于辅助开发。它们不同于 dependencies，因为它们只需安装在开发设备上，而无需在生产环境中运行代码。当打包上线时并不需要这些包，所以可以把这些依赖添加到 devDependencies 中，这些依赖依然会在本地指定 npm install 时被安装和管理，但是不会被安装到生产环境中。\n当使用 npm 或 yarn 安装软件包时，指定以下参数后，新安装的 npm 包会被自动插入到此列表中：\nnpm install --save-dev &lt;PACKAGENAME&gt;yarn add --dev &lt;PACKAGENAME&gt;\n&quot;devDependencies&quot;: &#123;  &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,  &quot;babel-core&quot;: &quot;^6.22.1&quot;&#125;\n\npeerDependencies如果需要在找不到包或者安装包失败时，npm 仍然能够继续运行，则可以将该包放在 optionalDependencies 对象中，optionalDependencies 对象中的包会覆盖 dependencies 中同名的包，所以只需在一个地方进行设置即可。\n需要注意，由于 optionalDependencies 中的依赖可能并未安装成功，所以一定要做异常处理，否则当获取这个依赖时，如果获取不到就会报错。\nbundledDependencies上面的几个依赖相关的配置项都是一个对象，而 bundledDependencies 配置项是一个数组，数组里可以指定一些模块，这些模块将在这个包发布时被一起打包。\n需要注意，这个字段数组中的值必须是在 dependencies, devDependencies 两个里面声明过的包才行。\nengines当我们维护一些旧项目时，可能对 npm 包的版本或者 Node 版本有特殊要求，如果不满足条件就可能无法将项目跑起来。为了让项目开箱即用，可以在 engines 字段中说明具体的版本号：\n&quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=8.10.3 &lt;12.13.0&quot;,  &quot;npm&quot;: &quot;&gt;=6.9.0&quot;&#125;\n需要注意，engines 只是起一个说明的作用，即使用户安装的版本不符合要求，也不影响依赖包的安装。\n脚本配置scriptsscripts 是 package.json 中内置的脚本入口，是 key-value 键值对配置，key 为可运行的命令，可以通过 npm run 来执行命令。除了运行基本的 scripts 命令，还可以结合 pre 和 post 完成前置和后续操作。先来看一组 scripts：\n&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;node index.js&quot;,  &quot;predev&quot;: &quot;node beforeIndex.js&quot;,  &quot;postdev&quot;: &quot;node afterIndex.js&quot;&#125;\n这三个 js 文件中都有一句 console：\n// index.jsconsole.log(&quot;scripts: index.js&quot;)// beforeIndex.jsconsole.log(&quot;scripts: before index.js&quot;)// afterIndex.jsconsole.log(&quot;scripts: after index.js&quot;)复制代码\n\n当我们执行 npm run dev 命令时，输出结果如下：\nscripts: before index.jsscripts: index.jsscripts: after index.js复制代码\n可以看到，三个命令都执行了，执行顺序是 predev→dev→postdev。如果 scripts 命令存在一定的先后关系，则可以使用这三个配置项，分别配置执行命令。\n通过配置 scripts 属性，可以定义一些常见的操作命令：\n&quot;scripts&quot;: &#123;  &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,  &quot;start&quot;: &quot;npm run dev&quot;,  &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,  &quot;test&quot;: &quot;npm run unit&quot;,  &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit&quot;,  &quot;build&quot;: &quot;node build/build.js&quot;&#125;\n这些脚本是命令行应用程序。可以通过调用 npm run XXX 或 yarn XXX 来运行它们，其中 XXX 是命令的名称。例如：npm run dev。我们可以为命令使用任何的名称，脚本也可以是任何操作。\n使用好该字段可以大大的提升开发效率。\nconfigconfig 字段用来配置 scripts 运行时的配置参数，如下所示：\n&quot;config&quot;: &#123; &quot;port&quot;: 3000&#125;\n如果运行 npm run start，则 port 字段会映射到npm_package_config_port环境变量中：\nconsole.log(process.env.npm_package_config_port) // 3000\n用户可以通过npm config set foo:port 3001 命令来重写 port 的值。\n文件 &amp; 目录下面来看看 package.json 中和文件以及目录相关的属性。\nmainmain 字段用来指定加载的入口文件，在 browser 和 Node 环境中都可以使用。如果我们将项目发布为 npm 包，那么当使用 require 导入 npm 包时，返回的就是 main 字段所列出的文件的 module.exports 属性。如果不指定该字段，默认是项目根目录下的 index.js。如果没找到，就会报错。\n该字段的值是一个字符串：\n&quot;main&quot;: &quot;./src/index.js&quot;,\n\nbrowserbrowser 字段可以定义 npm 包在 browser 环境下的入口文件。如果 npm 包只在 web 端使用，并且严禁在 server 端使用，使用 browser 来定义入口文件。\n&quot;browser&quot;: &quot;./src/index.js&quot; \nmodulemodule 字段可以定义 npm 包的 ESM 规范的入口文件，browser 环境和 node 环境均可使用。如果 npm 包导出的是 ESM 规范的包，使用 module 来定义入口文件。\n&quot;module&quot;: &quot;./src/index.mjs&quot;,\n需要注意，.js 文件是使用 commonJS 规范的语法 (require(‘xxx’))，.mjs 是用 ESM 规范的语法 (import ‘xxx’)。\n上面三个的入口入口文件相关的配置是有差别的，特别是在不同的使用场景下。在 Web 环境中，如果使用 loader 加载 ESM（ES module），那么这三个配置的加载顺序是 browser→module→main，如果使用 require 加载 CommonJS 模块，则加载的顺序为 main→module→browser。\nWebpack 在进行项目构建时，有一个 target 选项，默认为 Web，即构建 Web 应用。如果需要编译一些同构项目，如 node 项目，则只需将 webpack.config.js 的 target 选项设置为 node 进行构建即可。如果在 Node 环境中加载 CommonJS 模块，或者 ESM，则只有 main 字段有效。\nbinbin 字段用来指定各个内部命令对应的可执行文件的位置：\n&quot;bin&quot;: &#123;  &quot;someTool&quot;: &quot;./bin/someTool.js&quot;&#125;\n这里，someTool 命令对应的可执行文件为 bin 目录下的 someTool.js，someTool.js 会建立符号链接 node_modules&#x2F;.bin&#x2F;someTool。由于 node_modules&#x2F;.bin &#x2F; 目录会在运行时加入系统的 PATH 变量，因此在运行 npm 时，就可以不带路径，直接通过命令来调用这些脚本。因此，下面的写法可以简写：\nscripts: &#123;    start: &#x27;./node_modules/bin/someTool.js build&#x27;&#125; // 简写scripts: &#123;    start: &#x27;someTool build&#x27;&#125;\n所有 node_modules&#x2F;.bin &#x2F; 目录下的命令，都可以用 npm run [命令] 的格式运行。\n上面的配置在 package.json 包中提供了一个映射到本地文件名的 bin 字段，之后 npm 包将链接这个文件到 prefix&#x2F;fix 里面，以便全局引入。或者链接到本地的 node_modules&#x2F;.bin &#x2F; 文件中，以便在本项目中使用。\nfilesfiles 配置是一个数组，用来描述当把 npm 包作为依赖包安装时需要说明的文件列表。当 npm 包发布时，files 指定的文件会被推送到 npm 服务器中，如果指定的是文件夹，那么该文件夹下面所有的文件都会被提交。\n&quot;files&quot;: [    &quot;LICENSE&quot;,    &quot;Readme.md&quot;,    &quot;index.js&quot;,    &quot;lib/&quot; ]\n如果有不想提交的文件，可以在项目根目录中新建一个. npmignore 文件，并在其中说明不需要提交的文件，防止垃圾文件推送到 npm 上。这个文件的形式和. gitignore 类似。写在这个文件中的文件即便被写在 files 属性里也会被排除在外。比如可以在该文件中这样写：\nnode_modules.vscode build .DS_Store\n\nmanman 命令是 Linux 中的帮助指令，通过该指令可以查看 Linux 中的指令帮助、配置文件帮助和编程帮助等信息。如果 node.js 模块是一个全局的命令行工具，在 package.json 通过 man 属性可以指定 man 命令查找的文档地址：\n&quot;man&quot;: [ &quot;./man/npm-access.1&quot;, &quot;./man/npm-audit.1&quot;]\nman 字段可以指定一个或多个文件, 当执行 man {包名} 时, 会展现给用户文档内容。需要注意\n\nman 文件必须以数字结尾，如果经过压缩，还可以使用. gz 后缀。这个数字表示文件安装到哪个 man 节中；\n如果 man 文件名称不是以模块名称开头的，安装的时候会加上模块名称前缀。对于上面的配置，可以使用以下命令来执行查看文档：man npm-accessman npm-audit\n\ndirectoriesdirectories 字段用来规范项目的目录。node.js 模块是基于 CommonJS 模块化规范实现的，需要严格遵循 CommonJS 规范。模块目录下除了必须包含包项目描述文件 package.json 以外，还需要包含以下目录：\n\nbin ：存放可执行二进制文件的目录\nlib ：存放 js 代码的目录\ndoc ：存放文档的目录\ntest ：存放单元测试用例代码的目录\n…\n\n在实际的项目目录中，我们可能没有按照这个规范进行命名，那么就可以在 directories 字段指定每个目录对应的文件路径：\n&quot;directories&quot;: &#123;    &quot;bin&quot;: &quot;./bin&quot;,    &quot;lib&quot;: &quot;./lib&quot;,    &quot;doc&quot;: &quot;./doc&quot;,    &quot;test&quot; &quot;./test&quot;,    &quot;man&quot;: &quot;./man&quot;&#125;,\n这个属性实际上没有什么实际的作用，当然不排除未来会有什么比较有意义的用处。\n发布配置npm 项目包发布相关的配置。\nprivateprivate 字段可以防止我们意外地将私有库发布到 npm 服务器。只需要将该字段设置为 true：\n&quot;private&quot;: true\npreferGlobalpreferGlobal 字段表示当用户不把该模块安装为全局模块时，如果设置为 true 就会显示警告。它并不会真正的防止用户进行局部的安装，只是对用户进行提示，防止产生误解：\n&quot;preferGlobal&quot;: true\npublishConfigpublishConfig 配置会在模块发布时生效，用于设置发布时一些配置项的集合。如果不想模块被默认标记为最新，或者不想发布到公共仓库，可以在这里配置 tag 或仓库地址。更详细的配置可以参考 npm-config[1]。\n通常情况下，publishConfig 会配合 private 来使用，如果只想让模块发布到特定 npm 仓库，就可以这样来配置：\n&quot;private&quot;: true,&quot;publishConfig&quot;: &#123;  &quot;tag&quot;: &quot;1.1.0&quot;,  &quot;registry&quot;: &quot;https://registry.npmjs.org/&quot;,  &quot;access&quot;: &quot;public&quot;&#125;\n\nosos 字段可以让我们设置该 npm 包可以在什么操作系统使用，不能再什么操作系统使用。如果我们希望开发的 npm 包只运行在 linux，为了避免出现不必要的异常，建议使用 Windows 系统的用户不要安装它，这时就可以使用 os 配置：\n&quot;os&quot; [&quot;linux&quot;]   // 适用的操作系统&quot;os&quot; [&quot;!win32&quot;]  // 禁用的操作系统\n\ncpu该配置和 OS 配置类似，用 CPU 可以更准确的限制用户的安装环境：\n&quot;cpu&quot; [&quot;x64&quot;, &quot;AMD64&quot;]   // 适用的cpu&quot;cpu&quot; [&quot;!arm&quot;, &quot;!mips&quot;]  // 禁用的cpu\n可以看到，黑名单和白名单的区别就是，黑名单在前面加了一个 “!”。\nlicenselicense 字段用于指定软件的开源协议，开源协议表述了其他人获得代码后拥有的权利，可以对代码进行何种操作，何种操作又是被禁止的。常见的协议如下：\n\nMIT ：只要用户在项目副本中包含了版权声明和许可声明，他们就可以拿你的代码做任何想做的事情，你也无需承担任何责任。\nApache ：类似于 MIT ，同时还包含了贡献者向用户提供专利授权相关的条款。\nGPL ：修改项目代码的用户再次分发源码或二进制代码时，必须公布他的相关修改。\n\n可以这样来声明该字段：\n&quot;license&quot;: &quot;MIT&quot;\n\n第三方配置typingstypings 字段用来指定 TypeScript 的入口文件：\n&quot;typings&quot;: &quot;types/index.d.ts&quot;,\n该字段的作用和 main 配置相同。\neslintConfigeslint 的配置可以写在单独的配置文件. eslintrc.json 中，也可以写在 package.json 文件的 eslintConfig 配置项中。\n&quot;eslintConfig&quot;: &#123;      &quot;root&quot;: true,      &quot;env&quot;: &#123;        &quot;node&quot;: true      &#125;,      &quot;extends&quot;: [        &quot;plugin:vue/essential&quot;,        &quot;eslint:recommended&quot;      ],      &quot;rules&quot;: &#123;&#125;,      &quot;parserOptions&quot;: &#123;        &quot;parser&quot;: &quot;babel-eslint&quot;     &#125;,&#125;\n\nbabelbabel 用来指定 Babel 的编译配置，代码如下：\n&quot;babel&quot;: &#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;], &quot;plugins&quot;: [...]&#125;\n\nunpkg使用该字段可以让 npm 上所有的文件都开启 cdn 服务，该 CND 服务由 unpkg 提供：\n&quot;unpkg&quot;: &quot;dist/vue.js&quot;\n\nlint-stagedlint-staged 是一个在 Git 暂存文件上运行 linters 的工具，配置后每次修改一个文件即可给所有文件执行一次 lint 检查，通常配合 gitHooks 一起使用。\n&quot;lint-staged&quot;: &#123; &quot;*.js&quot;: [   &quot;eslint --fix&quot;,    &quot;git add&quot;  ]&#125;\n使用 lint-staged 时，每次提交代码只会检查当前改动的文件。\ngitHooksgitHooks 用来定义一个钩子，在提交（commit）之前执行 ESlint 检查。在执行 lint 命令后，会自动修复暂存区的文件。修复之后的文件并不会存储在暂存区，所以需要用 git add 命令将修复后的文件重新加入暂存区。在执行 pre-commit 命令之后，如果没有错误，就会执行 git commit 命令：\n&quot;gitHooks&quot;: &#123; &quot;pre-commit&quot;: &quot;lint-staged&quot;&#125;\n这里就是配合上面的 lint-staged 来进行代码的检查操作。\nbrowserslistbrowserslist 字段用来告知支持哪些浏览器及版本。Babel、Autoprefixer 和其他工具会用到它，以将所需的 polyfill 和 fallback 添加到目标浏览器。比如最上面的例子中的该字段值：\n&quot;browserslist&quot;: &#123;  &quot;production&quot;: [    &quot;&gt;0.2%&quot;,    &quot;not dead&quot;,    &quot;not op_mini all&quot;  ],  &quot;development&quot;: [    &quot;last 1 chrome version&quot;,    &quot;last 1 firefox version&quot;,    &quot;last 1 safari version&quot;  ]&#125;\n这里指定了一个对象，里面定义了生产环境和开发环境的浏览器要求。上面的 development 就是指定开发环境中支持最后一个版本的 chrome、Firefox、safari 浏览器。这个属性是不同的前端工具之间共用目标浏览器和 node 版本的配置工具，被很多前端工具使用，比如 Babel、Autoprefixer 等。\n","categories":["解析"]},{"title":"npm命令","url":"/2022/05/20/npm%E5%91%BD%E4%BB%A4/","content":"删除依赖\n删除node包\nnpm uninstall  node包\n\n\n\nnpm install –global、–save、 –save-dev的区别和使用场景npm install(i) moduleName\n安装到本项目node_modules目录下\n\nnpm install –global(-g)\n全局安装\n是一些需要通用的工具类安装，比如npm、yarn\n\nnpm install –save(-S)\n是项目需要的，是项目运行必备，如：vue、element-ui等\n\nnpm install –save-dev(-D)\n是开发时需要的，但是项目运行不必须的，不需要打包到项目里的，如：webkpack、gulp等\n\n","categories":["npm"]},{"title":"react面试题","url":"/2021/09/13/react/","content":"React面试题props接受任意参，那具体使用场景都有哪些\n1.基础数组类型，复合数据类型\n2.直接传递一组件\n3.可以通过函数接收Html一个片段\n4.props.children\n5.{…obj}\n6.cakkback 子传父\n\ncontext的使用场景有哪些，分别是什么？与props的区别是什么？\n1.基础数组类型，复合数据类型\n2.直接传递一组件\n3.可以通过函数接收Html一个片段\n4.callback子传父\n5.{…obj}区别解决propse一代传一代问题，context可以跨组件数据通信\n\nReact中事件this邦定的实现方法有哪些?\n1.调用时使用this.set.bind(this)\n2.在constructor中绑定this.set&#x3D;this.set.bind(this)\n3.使用箭头函数进行绑定\n4.onClick&#x3D;{()&#x3D;&gt;{this.set()}}\n\nReact组件生命周期的阶段是什么？常用生命周期方法有哪些？挂载、更新、卸载挂载 constructor  render  componentDidMount更新componentDidUpdate render卸载componentWillUnmountconstructor 用来设置state默认值的componentDidMount ajax 请求 定时器设置的componentWillUnmount  清定时器、取消ajax请求\nstate 修改的三种方式1、this.setState(&#123;    &#x27;a&#x27;:&#x27;3&#x27;&#125;)2、this.setState((state,props)=&gt;(&#123;    a:state.a+1&#125;))3、this.setState(&#123;    obj:&#123;        ...this.state.obj,        &#x27;a&#x27;:&#x27;3&#x27;    &#125;,    obj:Object.assign(&#123;&#125;,this.state.obj,&#123;&#x27;a&#x27;:&#x27;3&#x27;&#125;)&#125;)&lt;select multiple=&#123;true&#125; value=&#123;[&#x27;B&#x27;, &#x27;C&#x27;]&#125;&gt;              &lt;option value=&quot;B&quot;&gt;葡萄柚&lt;/option&gt;              &lt;option value=&quot;C&quot;&gt;酸橙&lt;/option&gt;              &lt;option value=&quot;E&quot;&gt;酸橙&lt;/option&gt;              &lt;option value=&quot;F&quot;&gt;酸橙&lt;/option&gt;&lt;/select&gt;\n\n函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对应类组件生命周期的？props接收方式不一样render渲染方式不一样函数组件没有state函数组件也没有生命周期\n\n生命周期挂载、更新、卸载\n挂载 constructor render componentDidMount\n更新 componentDidUpdate render\n卸载componentWillUnmount\n\n\n\nuseEffectuseEffect(()=&gt;&#123;&#125;,[])componentDidMount useEffect(()=&gt;&#123;&#125;,[count])componentDidUpdate useEffect(()=&gt;&#123;return()=&gt;&#123;    &#125; componentWillUnmount  &#125;,[])\n\nreact是单向数据流，如何实现数据双向绑定通过onChange事件进行实时监听来获取value值 通过serState来实现数据双想绑定\nvue、react打包的项目自定义路径 是否可以正常使用无法正常使用需要在nginx进行url重写\n我js中会使用return false来组件默认事件，react中有合成事件想阻止默认事件以及阻止冒泡事件应该怎么做？e.preventDefault()、e.stopPropagation();\n在react开发中会涉及到多个组件交互操作，如果当前组件有ajax未请求完成，这时直接跳到另一个组件会报错，我们如何来阻止报错。在componentWillUnmount（）组件中取消或终止ajax请求\n当前组件引入一个子组件，如何在子组件中获取到这个data的值，并且使用es6进行改写this.props.data&lt;App {…data}&#x2F;&gt;\n路由中NavLink 与Link什么区别？NavLink 当前选中会增加默认一个classname 而link直接就是链接跳转\n路由传参的三种方式？params,query,statereact路由传参(3种方式)\n1、params传参(刷新页面后参数不消失，参数会在地址栏显示)上文的动态路由实现方式\n&lt;Route exact path=&quot;/ceshi&quot; component=&#123;Ceshi&#125; /&gt;&lt;Route exact path=&#123;`/ceshi/:page`&#125; component=&#123;Ceshi&#125; /&gt;&lt;Route path=&#123;`/ceshi/:page/:id`&#125; component=&#123;Ceshi&#125; /&gt;路由跳转并传递参数：链接方式：&lt;Link to=&#123;`/ceshi/tg`&#125;&gt;通过&lt;/Link&gt;或：&lt;Link to=&#123;&#123;pathname:`/ceshi/tg`&#125;&#125;&gt;通过&lt;/Link&gt;js方式：this.props.history.push(`/ceshi/tg`)或：this.props.history.push(&#123;pathname:`/ceshi/tg`&#125;)页面获取参数：this.props.match.params.pagethis.props.match.params.id//注意这里是match而非history\n\n2、query传参(刷新页面后参数消失)\n路由页面：&lt;Route path=&#x27;/ceshi&#x27; component=&#123;CeShi&#125;/&gt;  //无需配置路由跳转并传递参数：链接方式：&lt;Link to=&#123;&#123;pathname:`/ceshi`,query:&#123;id:6,url:&#x27;tg&#x27;&#125;&#125;&#125;&gt;通过&lt;/Link&gt;js方式：this.props.history.push(&#123;pathname:`/ceshi`,query:&#123;id:6,url:&#x27;tg&#x27;&#125;&#125;)---获取参数： this.props.location.query.name\n\n3、state传参( 刷新页面后参数不消失，state传的参数是加密的，比query传参好用)注：state 传参的方式只支持Browserrouter路由，不支持hashrouter\n路由页面：&lt;Route path=&#x27;/demo&#x27; component=&#123;Ceshi&#125;/&gt;  //无需配置路由跳转并传递参数：链接方式： &lt;Link to=&#123;&#123;pathname:`/ceshi`,state:&#123;id:12,url:&#x27;tg&#x27;&#125;&#125;&#125;&gt;通过&lt;/Link&gt;js方式：this.props.history.push(&#123;pathname:`/ceshi`,state:&#123;id:12,url:&#x27;tg&#x27;&#125;&#125;)---获取参数： this.props.location.state.url\n\n如何在组件更新时再发起一个ajax 请求，在更新时需要注意什么？使用if判断某个值是否改变，当此值改变后在调用ajax函数\n已知对象boj,jajx返回一个后如何合并原有对象，使用至少两种方式实现ajax(url,fn(res))&#123;  // 假设res为对象  this.setState(&#123;    obj:&#123;this.state.obj,...res&#125;  &#125;)  Object.assign(&#123;&#125;,obj,res)&#125;\n\n路由值系页面可以使用history，那非值系，隔代页面中如何使用路由相关信息withrouter\nreact是单向数据流，如何实现数据双向邦定？如何修改state自身值而使其可以累加？\n通过onChange事件进行时时监听来获取value值 通过setState来实现数据双向邦定this.setState((state,props)=&gt;(&#123;         page:state.page+1&#125;))\n\n在使用react项目开发时，你是如何与后端进行接口连调的在src中的react&#x2F;first-react&#x2F;src&#x2F;setupProxy.js配置在线接口的url，从而使用在线接口代理 到本地3000下\nprops接收任意参，那具体使用场景都有哪些？context的使用场景有哪些，分别是什么props\n\n基础数组类型，复合数据类型\n直接传递一组件\n可以通过函数接收Html一个片段\nprops.children\ncallback 子传父\n\nContext解决props一代传一代问题，context可以跨页面数据通信\n\n基础数组类型，复合数据类型\n直接传递一组件\n可以通过函数接收Html一个片段\ncallback 子传父\n\n函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对类组件生命周期的？区别：props接受方式不一样render渲染方式不一样函数没有state函数组件也没有state函数组件也没有生命周期生命周期挂载、更新、卸载挂载 constructor render componentDidMount更新 componentDidUpdate render卸载 componentWillUnmount\nuseEffect：useEffect(()&#x3D;&gt;{},[])componentDidMountuseEffect(()&#x3D;&gt;{},[count])componentDidUpdateuseEffect(()&#x3D;&gt;{return()&#x3D;&gt;{  }componentWillUnmount},[])\nMobx\n简述一下你对mobx的理解，以及你在项目中使用mobx的流程是什么(类组件与函数组件)\n\n结合react的State和setState 把moxb简单概括为三点1.定义一个observable 相当于我们的state2.想要更改observable需要使用action 相当于我们setState3.在视图中我们通过@observer 来响应数据变化项目中使用：\n\n安装\n安装mobx mobx-React\n解决@修饰符\n\n\nrouter.js\n引入 Provider\n引入store.js\n合并拆分 生成大store\nApp 外使用 Provider 并且…store\n\n\nstore.js\n包引入\noberservale\naction\n\n\n页面获取\n包引入\n@withrouter\n@inject\n@observer\n\n\nhookimport &#123;observer,MobXProviderContext&#125; from &#x27;mobx-react&#x27;;import &#123; withRouter&#125; from &#x27;react-router-dom&#x27;;function useStores(name)&#123;  return React.useContext(MobXProviderContext)[name]&#125;const &#123; tradeCfg &#125; = useStores(&#x27;FirstStore&#x27;)const &#123; name &#125; =  useStores(&#x27;SecondStore&#x27;);export default withRouter(observer(View));\n\n简述一下你对redux的理解，以及你在项目中使用redux的流程是什么（类组件与函数组件）？结合react 的State 可以把redux 简单概括为三点1、通过Store.getState()来获取整个数据源2、通过触发action 来修改State ,而修改action的唯一途径就是dispatch3、使用一个reducer 纯函数来接收state 和action 从面生成新的state,再使用createStore来创建一个Redux 的Store而在项目中使用流程是：1、安装2、router.js3、store.js4、view&#x2F;home&#x2F;redux    actions.js    actointypes.js    reducer.js    _index.js5、页面\nimport &#123;connect&#125; from &#x27;react-redux&#x27;;import &#123;actions&#125; from &#x27;./_index.js&#x27;;function mapStateToProps(state) &#123;    return &#123;        addList:state.add    &#125;&#125;const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;    return &#123;        onAddFn:()=&gt;dispatch(actions.add())    &#125;&#125;;export default connect(mapStateToProps,mapDispatchToProps)(View);this.props\n函数\nimport &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;const state = useSelector((state)=&gt;state);const add = useSelector((state)=&gt;state.add);const dispatch = useDispatch();useEffect(()=&gt;&#123;    dispatch(actions.add())&#125;,[])\n\n\nReact是什么，它的优缺点，它和vue的区别React是什么\nReact是一个JavaScript库，用于构建高效、快速的用户界面。React主要用于构建Ui\n\n它的优缺点优点\n\nReact速度快\n在React并不会直接对DOM进行操作，而是引入了一个叫虚拟DOM的概念，安插在javascript逻辑和实际的DOM之间，性能很好\n\n\n性能好&#x2F;跨浏览器兼容\n虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没有问题的\n\n\n一切都是component&#x2F;代码模块化\n代码模块化，重用代码更容易\n\n\n单向数据流\nFlux是一个用于在JavaScript应用程序中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化\n\n\n兼容性好\n比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用，它们使得那些艰难的任务不再让人望人生畏。\n\n\n同构、纯粹的JavaScript\n因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化\n\n\n\n缺点\n\nReact只是视图层的一个框架，如果需要做其他事情，需要依赖它的生态系统；比如使用路由需要用到Router，处理数据需要用到Redux\n\n学习成本高\n\n\n开发工具 react-devtool 安装⚙️ 如何手动添加一个chrome扩展\n\n解压 react-devtools.zip 到磁盘一个用来保存 chrome 扩展的文件夹中\n打开 chrome 浏览器…菜单，更多工具 &#x2F; 扩展程序\n打开开发者模式\n将 react-devtools 文件夹拖入到当前界面中，完成\n\n\n\n其他 -扩展react Hooks状态库\nahooks (阿里巴巴出品的的一个react Hooks库)\n\nredux与rtk的区别\n1、reduxjs&#x2F;tookit相对于react-redux来说比较方便，集成了redux-devtools-extension，不需要额外的配置，非常方便\n2、reduxjs&#x2F;tookit集成immutable-js的功能，不需要安装配置使用，提升了开发效率\n3、reduxjs&#x2F;tookit集成了redux-thunk的功能\n4、reduxjs&#x2F;tookit将types、actions、reducers放在一起组成了全新的slices，简化了我们的使用\n\n如何在react中使用sass\n首先安装依赖 npm install –save-dev node-sass\n\ncreate-react-app 创建的react项目默认就是支持Sass的，使用只要安装node-sass即可使用\n\n\n","categories":["react"],"tags":["jQuery","表格","表单验证"]},{"title":"从零开始react Native","url":"/2022/02/13/reactNative/","content":"\n\n\n基础expo\nexpo是什么？\nexpo是基于expo框架与react-native语法的App开发\n\n\n\n","categories":["RN"]},{"title":"seo优化","url":"/2023/08/28/seo%E4%BC%98%E5%8C%96/","content":"创建唯一且准确的网页标题 &lt;title&gt;&lt;title&gt; 标记可告诉用户和搜索引擎特定网页的主题是什么。它应放置在 HTML 文档的 &lt;head&gt; 元素中。我们应该为网站上的每个网页创建一个唯一标题，并且尽量避免与网页内容无关或使用默认或模糊的标题。如：\n&amp;lt;!-- 正确示范 --&amp;gt;&amp;lt;title&amp;gt;前端搜索引擎优化的技巧&amp;lt;/title&amp;gt;&amp;lt;!-- 错误示范 --&amp;gt;&amp;lt;title&amp;gt;我的文档&amp;lt;/title&amp;gt;\n\n使用 meta description我们可以使用 meta description 标签来准确概括总结网页内容。我们应避免内容中出现关键词的堆砌、描述过长、描述过于笼统简单，如直接拷贝关键词或正文内容、或“这是一个网页”这种没有实际性意义的描述等现象。正确示范如下：\n&amp;lt;meta name=&#x27;description&#x27; content=&#x27;本文主要介绍搜索引擎优化（SEO）的技巧，如使用title、description、keywords、语义化标签、img的alt属性等。&#x27;&amp;gt;\n\n使用 meta keywords我们可以使用 meta keywords 来提炼网页重要关键字，如：\n&amp;lt;meta name=&#x27;keywords&#x27; content=&#x27;SEO,搜索引擎优化,网页排名优化&#x27;&amp;gt;\n但有些建站者为了网页能有较好的排名，故意在这个标签中大量堆砌关键字，也就是所谓的“黑帽方法”之一。于是搜索引擎为了为用户提供优质的搜索结果，优化了它们的爬取算法——当出现大量关键字堆砌时，搜索引擎可能会降低这个网站的排名甚至将其列入黑名单。所以我们需慎用或者不用这个标签，使用的话一般设置3-4个关键词即可。\n注意： &lt;title&gt; 、 meta description 和 meta keywords 三者的权重依次减小，我们要想网页有好的排名，必须合理使用这三个标签。\n使用语义化元素在合适的位置使用合适的元素表达合适的内容，让用户和“蜘蛛”能一目了然文档结构。例如使用 &lt;h1&gt; 可以让“蜘蛛”知道这是很重要的内容。然而，值得注意的是，例如在想要表达强调时，我们不应该滥用标题元素或者 &lt;b&gt; 、 &lt;i&gt; 这种没有实际意义的标签，换而可以使用 &lt;em&gt; 或 &lt;strong&gt; 来表示强调。此外， &lt;h1&gt; 的权重比 &lt;h2&gt; 的大，我们不应该为了增大权重而去滥用 &lt;h1&gt; ，一般来说 &lt;h1&gt; 用于正文的标题。\n利用 &lt;img&gt; 中的 alt 属性alt 属性可以在图片未成功显示时候，使用文本来代替图片的呈现，使“蜘蛛”可以抓取到这个信息。此外它还可以解决浏览器禁用图像或屏幕阅读器解析等问题。\n设置 rel&#x3D;’nofollow’ 忽略跟踪如果某个 &lt;a&gt; 的链接不需要跟踪，那么添加 rel&#x3D;’nofollow’ 即可通知“蜘蛛”忽略跟踪。因为“蜘蛛”分配到每个页面的权重是一定的，为了集中网页权重并将权重分给其他必要的链接，为不必跟踪的链接添加这个属性就显得很必要了。\n提高加载速度我们应尽量让结构（HTML）、表现（CSS）及行为（JavaScript）三者分离。如果在一个 HTML 页面中，编写大量的 CSS 样式或脚本，会拖慢其加载速度，此外，如果不为 &lt;img&gt; 定义宽高，那么会引起页面重新渲染，同样也会影响加载速度。一旦加载超时，“蜘蛛”就会放弃爬取。\n扁平化网站结构一般来说，一个网站的结构层次越少，越有利于“蜘蛛”的爬取。所以目录结构一般不多于 3 级，否则“蜘蛛”很容易不愿意继续往下爬。就像用户在操作一个网页一样，层级大于 3 就很影响用户体验了，“蜘蛛”就是模仿用户的心理。\n合理安排重要内容的位置我们应该将含重要内容的 HTML 代码放在最前面，因为“蜘蛛”爬取 HTML 的顺序是从上到下，有的搜索引擎对抓取长度有限制，所以要保证重要内容被优先爬取。并且，重要内容不应该由 JavaScript 输出，因为“蜘蛛”没有办法读取 JavaScript ，同时也要少用 iframe ，因为“蜘蛛”一般不会去读取它里面的内容。\n————————原文连接：https://www.cnblogs.com/EnSnail/p/5671345.html\n","categories":["seo优化"]},{"title":"threejs","url":"/2023/10/08/threejs/","content":""},{"title":"java打包uin的app证书","url":"/2023/11/07/%E7%94%9F%E6%88%90uin%E6%89%93%E5%8C%85%E9%9C%80%E8%A6%81%E7%9A%84%E8%AF%81%E4%B9%A6/","content":"生成自有证书生成证书的命令行为：keytool -genkey -alias tt -keyalg RSA -keysize 2048 -validity 36500 -keystore tt.keystore\n注意：\n\ntt是证书别名，可修改为自己想设置的字符，建议使用英文字母和数字\ntt.keystore是证书文件名称，可修改为自己想设置的文件名称，也可以指定完整文件路径\n36500是证书的有效期，表示100年有效期，单位天，建议时间设置长一点，避免证书过期\n\n","categories":["解析"]},{"title":"webpack文件解析","url":"/2022/10/30/webpack/","content":"什么是webpackwebpack本身是，node的一个第三方模块包，用于打包代码\nwebpack执行流程\nwebpack默认只能打包.js结尾的文件，处理不了其它后缀的文件\n由于代码中包含了index.css这个文件，因此webpack默认处理不了\n当webpack发现某个文件处理不了的时候，会查找webpack.config.js这个配置文件，看module.rules数组中，是否配置了对应的loader加载器\nwebpack把index.css这个文件，先转交给最后一个loader进行处理(先转交给css-loader)。\n当css-loader处理完毕后，会把处理结果，转交给下一个loader(转交给styule-loader)\n当style-loader处理完毕后，发现没有下一个loader了，于是把处理的结果，转交给了webpack\nwebpack把style-loader的处理结果，合并到&#x2F;dist&#x2F;bundle.js中，最终生成打包好的文件。\n\nwebpack能做什么把很多文件打包整合到一起，缩小项目体积，提高加载速度栗子：\n\n打包前200MB\n打包后2MB\n\n\n其中功能：\nless&#x2F;sass -&gt;css\nES6&#x2F;7&#x2F;8 -&gt;ES5处理js兼容\n支持js模块化\n处理css兼容性\nhtml&#x2F;css&#x2F;js -&gt; 压缩合并\n\nwebpack的使用1.初始化包环境\nyarn init\n2.安装依赖包\n安装项目yarn add webpack webpack-cli -D   安装全局yarn add webpack webpack-cli -g  \n3.创建webpack.config.js跟src目录同级或packjson文件同级\n// 因为webpack是基于nodejs构建的// 所以支持commonjs规范 暴露对象使用module.exportsconst path = require(&#x27;path&#x27;) // 导出配置项module.exports= &#123;    // 指定模式伪开发者模式    mode:&#x27;development&#x27;,    // 入口    entry: &#x27;./src/index.js&#x27;,    // 出口    output:&#123;        // 打开的文件路径  打包后存放文件的位置        path :path.resolve(__dirname, &#x27;./dist&#x27;),        // 打包的文件名        filename:&#x27;tt.js&#x27;    &#125;,    module:&#123;        // 配置规则        rules:[            // 每一个对象代表一个规则            &#123;                // 匹配以css结尾的文件                test:/\\.css$/,                // 使用一个lpader处理                // loader:&#x27;css-loader&#x27;                // use:[&#x27;css-loader&#x27;],                // 使用多个loader处理                // use属性来告知webpack使用什么样的loader                // 注意：因为loader的执行顺序是从右向左(或者说从下到上，或者说从后到前的)，所以我们需要将style-loader写到css-loader的前面                use:[                    &#123;                        loader:&#x27;style-loader&#x27;                    &#125;,                    &#123;                        loader:&#x27;css-loader&#x27;,                        // loader配置                        // options:&#123;&#125;                    &#125;                ]            &#125;        ]    &#125;&#125;\n4.配置scripts(自定义命令)\nscripts: &#123;\t&quot;build&quot;: &quot;webpack&quot;&#125;\n5.运行打包命令\nyarn build或者 npm run build\n总结：src同级目录，生成默认dist目录和打包默认main.js文件，默认会打包src下的index.js\nwebpack更新打包代码变更\n\n重新打包 yarn build\n\n总结：src下开发环境，dist是打包后，分别独立总结：打包后格式压缩，变量压缩等\nwebpack配置webpack的入口和出口从哪开始打包，打包后输入到哪里\n默认出口：.&#x2F;src&#x2F;index.js默认出口：.&#x2F;dist&#x2F;main.js\nwebpack配置 - webpack.config.js(默认)\n\n新建src同级处，webpack.config.js\n填入配置项const path = require(&quot;path&quot;)module.exports = &#123;    entry: &quot;./src/main.js&quot;, // 入口    output: &#123;         path: path.join(__dirname, &quot;dist&quot;), // 出口路径        filename: &quot;bundle.js&quot; // 出口文件名    &#125;&#125;\n修改package.json，自定义打包命令 - 让 webpack使用配置文件&quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;webpack&quot;&#125;,\n打包观察效果\n\n打包流程图所有要被打包的资源都要跟入口产生直接&#x2F;间接的引用关系\n插件-自动生成html文件 html-webpack-plugin插件, 让webpack打包后生成html文件并自动引入打包后的js\n\n下载插件yarn add html-webpack-plugin  -D\nwebpack.config.js配置// 引入自动生成 html 的插件const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    // ...省略其他代码    plugins: [        new HtmlWebpackPlugin()    ]&#125;\n重新打包后观察dist下是否多出html并运行看效果  打包后的index.html自动引入打包后的js文件\n自定义打包的html模版，和输出文件名字  plugins: [  new HtmlWebpackPlugin(&#123;    template: &#x27;./public/index.html&#x27;,    filename: &#x27;index.html&#x27;  &#125;)]\n\nmode模式\nmode模式分为开发阶段和发布阶段\ndevelopment开发阶段，建议打包，打包速度快\nproduction发布阶段，打包精细，打包速度慢(不会经常production)mode: &#x27;development || production&#x27;\n\nwebpack开发服务器-为何学?文档地址: https://webpack.docschina.org/configuration/dev-server/\n栗子：每次修改代码, 都需要重新 yarn build 打包, 才能看到最新的效果, 实际工作中, 打包 yarn build 非常费时 (30s - 60s) 之间为什么费时?1.构建依赖2.磁盘读取对应的文件到内存，才能加载3.将处理完的内容，输出到磁盘指定目录\n解决方法： 起一个开发服务器, 在电脑内存中打包, 缓存一些已经打包过的内容, 只重新打包修改的文件, 最终运行加载在内存中给浏览器使用\nwebpack-dev-server启动本地服务, 可实时更新修改的代码, 打包变化代码到内存中, 然后直接提供端口和网页访问\n1.下载包\nyarn add webpack-dev-server -D\n2.配置自定义命令\nscripts: &#123;\t&quot;build&quot;: &quot;webpack&quot;,\t&quot;serve&quot;: &quot;webpack serve&quot;&#125;\n3.运行命令-启动webpack开发服务器\nyarn serve或者npm run serve \n以后更改src下的资源代码，就会直接更新到内存打包，然后反馈到浏览器上\nwebpack-dev-server配置1.package.json\n&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;webpack&quot;,  &quot;serve&quot;: &quot;webpack serve --port 8083 --open&quot;&#125;,\n2.在webpack.config.js中添加服务器配置更多配置参考这里: https://webpack.docschina.org/configuration/dev-server/#devserverafter\nmodule.exports = &#123;    // ...其他配置    devServer: &#123;      port: 3000, // 端口号      open: true    &#125;&#125;\n\n加载器 - 处理css文件问题\n新建css文件夹\n编写样式\n引入到入口文件才会被webpack打包\n执行打包命令观察效果\n\n结尾：webpack默认只能处理js类型文件\n加载器 - 处理css文件loaders加载器，可以让webpack处理其他类型的文件，打包到js中因为：webpack默认只认识js文件和json文件style-loader文档css-loader文档1.安装依赖\nyarn add style-loader css-loader -D\n2.webpack.config.js配置\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    // ...其他代码    module: &#123;         rules: [ // loader的规则          &#123;            test: /\\.css$/, // 匹配所有的css文件            // use数组里从右向左运行            // 先用 css-loader 让webpack能够识别 css 文件的内容并打包            // 再用 style-loader 将样式, 把css插入到dom中            use: [ &quot;style-loader&quot;, &quot;css-loader&quot;]          &#125;        ]    &#125;&#125;\n万物皆模块, 引到入口, 才会被webpack打包, css打包进js中, 然后被嵌入在style标签插入dom上\n加载less问题less-loader让webpack处理less文件, less模块翻译less代码less-loader文档\n\n安装less-loaderyarn add less less-loader -D\nwebpack.config.js配置module: &#123;  rules: [ // loader的规则    // ...省略其他    &#123;    \ttest: /\\.less$/,    \t// 使用less-loader, 让webpack处理less文件, 内置还会用less翻译less代码成css内容        use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, &#x27;less-loader&#x27;]    &#125;  ]&#125;\n\n加载器 - 图片问题\n定义盒子结构&lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;div class=&quot;main1&quot;&gt;&lt;/div&gt;\n通过样式设置背景图.main &#123;  width: 100px;  height: 100px;  background-image: url(../img/1.png);&#125;.main1 &#123;  width: 100px;  height: 100px;  background-image: url(../img/2.png);&#125;\n\n加载器 - 处理图片asset module文档\nasset module(超级棒)在webpack5之前要经常用到\n\nraw-loader将文件导入为字符串\nurl-loader将文件作为dataURL内联到bundle中。\nfile-loader将文件发送到输出目录。\n\n在webpack5，资源模块类型(asset module type)，通过添加4种新的模块类型，来替换了一些loader\n\nasset&#x2F;resource 发送一个单独的文件并导出URL。之前通过使用file-loader实现\nasset&#x2F;inline 导出一个资源的data URL。之前通过使用url-loader实现\nasset&#x2F;source 导出资源的代码。之前通过raw-loader实现\nasset在导出一个data URL和发送一个单独的文件之间选择。之前通过url-loader，并且配置资源体积限制实现\n\nwebpack5版本，直接可以再webpack.config.js中的rules里即可\n&#123;    test: /\\.(png|jpg|gif|jpeg)$/i,    type: &#x27;asset&#x27;&#125;\nyarn build 打包之后看效果\nwebpack4及以前的版本url-loader文档file-loader文档\n\n下载依赖包\nyarn add url-loader file-loader -D\n\n\nwebpack.config.js 配置&#123;  test: /\\.(png|jpg|gif|jpeg)$/i,  use: [    &#123;      loader: &#x27;url-loader&#x27;, // 匹配文件, 尝试转base64字符串打包到js中      // 配置limit, 超过8k, 不转, file-loader复制, 随机名, 输出文件      options: &#123;        limit: 8 * 1024,      &#125;,    &#125;,  ],&#125;\nsrc&#x2F;img&#x2F;准备2个图片\n在css&#x2F;less&#x2F;index.less - 把小图片用做背景图body&#123;    background: url(../img/1_min.png) no-repeat center;&#125;\n在src&#x2F;main.js - 把大图插入到创建的img标签上, 添加body上显示// 引入图片-使用import imgUrl from &#x27;./assets/1.gif&#x27;const theImg = document.createElement(&quot;img&quot;)theImg.src = imgUrldocument.body.appendChild(theImg)\n打包运行dist&#x2F;index.html观察2个图片区别总的说：url-loader 把文件转base64 打包进js中, 会有30%的增大, file-loader 把文件直接复制输出\n\nwebpack加载文件优缺点\n\n以8kb进行区分，小于8kb图片转成 base64 字符串\n好处就是浏览器不用发请求了，直接可以读取\n坏处就是如果图片太大，再转base64就会让图片的体积增大 30% 左右\n\n\n\n扩展—webpack4&#x2F;5对比\n// webpack4 url-loadermodule.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.(png|jpg|gif)$/i,        use: [          &#123;            loader: &#x27;url-loader&#x27;,            options: &#123;              limit: 8192,            &#125;,          &#125;,        ],      &#125;,    ],  &#125;,&#125;;\n// webpack 5 asset modulemodule.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.(png|jpg|gif)$/i,        type: &#x27;asset&#x27;,        parser: &#123;          dataurlCondition: &#123;            maxSize: 8192          &#125;        &#125;      &#125;,    ],  &#125;,&#125;;\n// webpack4 中三个loader的使用module.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.png$/i,        use: &#x27;file-loader&#x27;      &#125;,      &#123;        test: /\\.ico$/i,        use: &#x27;url-loader&#x27;      &#125;,      &#123;        test: /\\.text$/i,        use: &#x27;raw-loader&#x27;      &#125;,    ],  &#125;,&#125;;\n// webpack 5 中使用的方法module.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.png$/i,        use: &#x27;asset/resource&#x27;      &#125;,      &#123;        test: /\\.ico$/i,        use: &#x27;asset/inline&#x27;      &#125;,      &#123;        test: /\\.text$/i,        use: &#x27;asset/source&#x27;      &#125;,    ],  &#125;,&#125;;\n\n在webpack5中使用老版本的loader和asset模块时，会导致asset重复，所以你可能想阻止webpack5内置的asset模块的处理\n// 你可以通过将 asset 模块的类型设置为 ‘javascript/auto’ 来解决module.exports = &#123;  module: &#123;   rules: [      &#123;        test: /\\.(png|jpg|gif)$/i,        use: [          &#123;            loader: &#x27;url-loader&#x27;,            options: &#123;              limit: 8192,            &#125;          &#125;,        ],       type: &#x27;javascript/auto&#x27;      &#125;,   ]  &#125;,&#125;\n\n\n加载器 - 处理字体文件实现效果用asset module技术, asset&#x2F;resource直接输出到dist目录下\n\nsrc&#x2F;assets&#x2F; - 放入字体库fonts文件夹\n在main.js引入iconfont.css// 引入字体图标文件import &#x27;./assets/fonts/iconfont.css&#x27;\n在public&#x2F;index.html使用字体图标样式&lt;i class=&quot;iconfont icon-weixin&quot;&gt;&lt;/i&gt;\n\nwebpack5使用这个配置,也可以不配置\n&#123; // webpack5默认内部不认识这些文件, 所以当做静态资源直接输出即可    test: /\\.(eot|svg|ttf|woff|woff2)$/,    type: &#x27;asset/resource&#x27;,    generator: &#123;    \tfilename: &#x27;font-[name].[hash:6][ext]&#x27;    &#125;&#125;\n1.webpack4及以前使用下面的配置\n&#123; // 处理字体图标的解析    test: /\\.(eot|svg|ttf|woff|woff2)$/,        use: [            &#123;                loader: &#x27;url-loader&#x27;,                options: &#123;                    limit: 2 * 1024,                    // 配置输出的文件名                    name: &#x27;[name].[ext]&#x27;,                    // 配置输出的文件目录                    outputPath: &quot;fonts/&quot;                &#125;            &#125;        ]&#125;\n2.执行打包命令-观察打包后网页效果url-loader和file-loader 可以打包静态资源文件\n加载器 - 处理高版本js语法\n在main.js中使用箭头函数(高版本js)class App &#123;  static a = 123&#125;console.log(App.a)\n打包后观察lib&#x2F;bundle.js效果：让webpack对高版本 的js代码, 降级处理后打包\n\n高版本的js代码(箭头函数，类),打包后，直接原封不动打入js文件中，遇到一些低版本的浏览器就会报错原因：webpack 默认仅内置了 模块化的 兼容性处理 import exportbabel 的介绍 &#x3D;&gt; 用于处理高版本 js语法 的兼容性 babel官网解决: 让webpack配合babel-loader 对js语法做处理\n@babel&#x2F;core：@babel&#x2F;core是babel的核心库，所有的核心Api都在这个库里，这些Api供babel-loader调用\n@babel&#x2F;preset-env：这是一个预设的插件集合，包含了一组相关的插件，Bable中是通过各种插件来指导如何进行代码转换。该插件包含所有es6转化为es5的翻译规则\nbabel-loader文档\n\n安装包yarn add -D babel-loader @babel/core @babel/preset-env\n规则配置module: &#123;  rules: [    &#123;        test: /\\.js$/,        exclude: /(node_modules)/,        use: &#123;            loader: &#x27;babel-loader&#x27;,            options: &#123;                presets: [&#x27;@babel/preset-env&#x27;] // 预设:转码规则(用bable开发环境本来预设的)            &#125;        &#125;    &#125;  ]&#125;\n\n加载器 vue-loadervue-loader配置\n每个 vue 包的新版本发布时，一个相应版本的 vue-template-compiler 也会随之发布。编译器的版本必须和基本的 vue 包保持同步，这样 vue-loader 就会生成兼容运行时的代码。这意味着你每次升级项目中的 vue 包时，也应该匹配升级 vue-template-compiler。\nnpm install -D vue-loader vue-template-compiler\n\nvue-loader配置\n// webpack.config.jsconst &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)module.exports = &#123;  module: &#123;    rules: [      // ... 其它规则      &#123;        test: /\\.vue$/,        loader: &#x27;vue-loader&#x27;      &#125;    ]  &#125;,  plugins: [    // 请确保引入这个插件！    new VueLoaderPlugin()  ]&#125;// vue-loader是将你定义过的其他规则复制并应用到.vue文件里相应语言的快\n// webpack.config.jsconst &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)module.exports = &#123;  mode: &#x27;development&#x27;,  module: &#123;    rules: [      &#123;        test: /\\.vue$/,        loader: &#x27;vue-loader&#x27;      &#125;,      // 它会应用到普通的 `.js` 文件      // 以及 `.vue` 文件中的 `&lt;script&gt;` 块      &#123;        test: /\\.js$/,        loader: &#x27;babel-loader&#x27;      &#125;,      // 它会应用到普通的 `.css` 文件      // 以及 `.vue` 文件中的 `&lt;style&gt;` 块      &#123;        test: /\\.css$/,        use: [          &#x27;vue-style-loader&#x27;,          &#x27;css-loader&#x27;        ]      &#125;    ]  &#125;,  plugins: [    // 请确保引入这个插件来施展魔法    new VueLoaderPlugin()  ]&#125;\n其他loader\nbabel-loader 可以让webpack 对高版本js语法做降级处理后打包\n其他webpack.config.js和vue.config.js的区别\nwebpack.config.js是webpack的配置文件，所有使用webpack作为打包工具的项目都可以使用，vue的项目可以使用，react的项目也可以使用。\nvue.config.js是vue项目的配置文件，专用于vue项目。通过vue.config.js中常用功能的配置，简化了配置工作，如果需要更专业的配置工作，两者在vue项目中是可以并存的。\nvue-cli3创建的时候并不会自动创建vue.config.js，因为这个是可选项，所以一般都是修改webpack的时候才会自己创建一个vue.config.js\n然后因为你vue-cli3内部高度集成了webpack，一般来说使用者不需要再去webpack做什么，所以没有暴露webpack的配置文件，但你依然可以创建vue.config.js去修改默认的webpack。\n\n什么是gulp\n一、gulp 是一个基于node的自动化打包构建工具，前端开发者可以使用它来处理常见任务：搭建web服务器；文件保存时自动重载浏览器；使用预处理器如Sass、LESS；优化资源，比如压缩CSS、JavaScript、压缩图片；类似Gulp的工具，我们通常称之为构建工具或者叫自动化构建工具；强调的是前端开发的流程，通过配置一系列的task，定义task处理的事物，然后定义执行顺序，来让Gulp执行task，从而构建前端项目的流程，说白了就是用来打包项目；基于 node 强大的流(stream)能力，gulp 在构建过程中并不把文件立即写入磁盘，从而提高了构建速度；不管做什么功能，都有一个统一的接口进行管理，必须去注册一个任务，然后去执行，这也是它的特点之一，即“任务化”。\n\n二、基本使用\n1.创建项目目录  打开命令行工具(package.json文件为npm init -y自动生成，切勿手动创建)  使用cd命令行进入项目目录，如：cd mygulp  创建项目配置文件：npm init -y2.gulp的安装  在命令行工具，依次执行：    全局安装：npm i gulp -g    局部安装：npm i gulp -D    检测安装版本：gulp -v  注： gulp -v 命令得到两个版本号，一个全局，一个局部，代表安装成功3.gulp配置文件(src同级)  在项目中创建gulp配置文件--&gt;gulpfile.js4.定义指令  在gulpfile.js文件中定义gulp指令，使用gulp实现功能    const gulp = require(&quot;gulp&quot;); // 引入gulp模块    function testFn()&#123;            // 准备指令功能        console.log(&quot;test&quot;);    &#125;    exports.test = testFn;         // 定义指令（暴露模块）\n三、gulp常用插件以下插件使用格式为：npm（空格）i（空格）插件名（空格）-D清空文件夹：gulp-clean编译css：gulp-sass压缩图片：gulp-imagemin深度压缩图片：imagemin-pngquant压缩css：gulp-cssmincss前缀：gulp-autoprefixer压缩js：gulp-uglify\nES6转ES5：gulp-babel套件1：@babel&#x2F;core套件2：@babel&#x2F;preset-env\n压缩html：gulp-htmlmin服务器插件：gulp-webserver文件重命名：gulp-rename合并js文件：gulp-concat\n\n四、gulp常用项目流程操作及部分插件使用方法\n\n开始之前先引入将来要使用到的插件模块const gulp = require(&quot;gulp&quot;);const cssmin = require(&quot;gulp-cssmin&quot;);const autoprefixer = require(&quot;gulp-autoprefixer&quot;);const uglify = require(&quot;gulp-uglify&quot;);const babel = require(&quot;gulp-babel&quot;);const htmlmin = require(&quot;gulp-htmlmin&quot;);const webserver = require(&quot;gulp-webserver&quot;);\ncss处理方式// 处理css的指令：压缩，添加兼容前缀function cssFn()&#123;    return gulp.src(&quot;./project/css/**/*&quot;)            .pipe(autoprefixer(&quot;last 2 version&quot;,&quot;safari 5&quot;,&quot;ie 8&quot;,&quot;ie 9&quot;,&quot;opera 12.1&quot;,&quot;ios 6&quot;,&quot;android 4&quot;))            .pipe(cssmin())            .pipe(gulp.dest(&quot;./server/css&quot;))&#125;module.exports.css = cssFn;    // module.可省略\njs处理方式// 处理js的指令：ES6编译ES5，压缩function jsFn()&#123;    return gulp.src(&quot;./project/js/**/*&quot;)        .pipe(babel(&#123;            presets:[&quot;@babel/env&quot;]        &#125;))        .pipe(uglify())        .pipe(gulp.dest(&quot;./server/js&quot;))&#125;exports.js = jsFn;\nhtml处理方式// 处理html的指令：压缩function htmlFn()&#123;    return gulp.src(&quot;./project/pages/**/*&quot;)        .pipe(htmlmin(&#123;            removeEmptyAttributes:true,            collapseWhitespace:true        &#125;))        .pipe(gulp.dest(&quot;./server/pages&quot;))&#125;exports.html = htmlFn;\n处理静态资源\n\n\n\nfunction staticFn()&#123;    // 找到要处理的静态资源文件    return gulp.src(&quot;./src/static/**&quot;)            // 直接转存           .pipe(gulp.dest(&quot;./dist/static&quot;))&#125;// 暴露调用方式exports.static = staticFn;\n\n删除文件夹function cleanFn()&#123;    // 找到要删除的文件目录    return gulp.src(&quot;./ded&quot;)            // 直接删除           .pipe(clean())&#125;// 暴露调用方式exports.clean = cleanFn;\n服务器配置function serverFn()&#123;    // 找到要指定为根目录的文件夹    return gulp.src(&quot;./ded&quot;)        // 执行服务器方式，并开始配置信息        .pipe(webserver(&#123;            // 指定访问地址            host:&quot;localhost&quot;,            // 指定端口            port:3000,            // 开启自动刷新            livereload:true,            // 服务器开启后，自动打开的页面            open:&quot;./pages/index.html&quot;,            proxies:[&#123;                // 代理之后的请求地址                source:&quot;./chapters&quot;,                // 被代理的跨域地址                target:&quot;http://wanandroid.com/wxarticle/chapters/json&quot;                            &#125;]        &#125;))&#125;// 暴露调用方式exports.server = serverFn;\n开启监听function watchFn()&#123;    // 监听所有css文件    gulp.watch(&quot;./src/css/**&quot;,cssFn);    // 监听所有js文件    gulp.watch(&quot;./src/js/**&quot;,jsFn);    // 监听所有html文件    gulp.watch(&quot;./src/pages/**&quot;,htmlFn);    // 监听所有static文件    gulp.watch(&quot;./src/static/**&quot;,staticFn);&#125;// 暴露调用方式exports.watch = watchFn;\n批量执行\n注意事项：\ngulp.series()：同步执行内部命令\ngulp.parallel()：异步执行内部命令exports.all = gulp.series(    gulp.parallel(cssFn,jsFn,htmlFn,staticFn),    gulp.parallel(serverFn,watchFn));\n\n\n\n\n\n","categories":["解析"]},{"title":"vue3 学习","url":"/2022/10/20/vue3/","content":"vue3简介\n\n2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）\n耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者\ngithub上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0\n\nVue3带来了什么1.性能的提升\n打包大小减少41%\n\n初次渲染快55%, 更新渲染快133%\n\n内存减少54%\n…\n\n\n2.源码的升级\n使用Proxy代替defineProperty实现响应式\n\n重写虚拟DOM的实现和Tree-Shaking\n…\n\n\n3.拥抱TypeScript\nVue3可以更好的支持TypeScript\n\n4.新的特性\nComposition API（组合API）\nsetup配置\nref与reactive\nwatch与watchEffect\nprovide与inject\n…\n\n\n新的内置组件\nFragment\nTeleport\nSuspense\n\n\n其他改变\n新的生命周期钩子\ndata 选项应始终被声明为一个函数\n移除keyCode支持作为 v-on 的修饰符\n…\n\n\n\n创建vue3项目## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue3_study## 启动cd vue3_studynpm run serve\n\nOptions API的弊端在Vue2中，我们编写组件的方式是 OptionsAPI：\nOptions API的一大特点就是在对应的属性中编写对应的功能模块；\n比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子；\n但是这种代码有一个很大的弊端：\n当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；\n当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散；\n尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）；\n下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分：\n这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题；\n并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；\n\n\n如果我们能将同一个逻辑关注 点相关的代码收集在一起会更好。\n这就是Composition API想要做的事情，以及可以帮助我 们完成的事情。\n也有人把Vue Composition API简称为VCA。\n认识Composition API那么既然知道Composition API想要帮助我们做什么事情，接下来看一下到底是怎么做呢？\n为了开始使用Composition API，我们需要有一个可以实际使用它（编写代码）的地方；\n在Vue组件中，这个位置就是 setup 函数；\nsetup其实就是组件的另外一个选项：\n只不过这个选项强大到我们可以用它来替代之前所编写的大部分其他选项；\n比如methods、computed、watch、data、生命周期等等；\n接下来我们一起学习这个函数的使用：\n函数的参数\n函数的返回值\nsetup函数的参数我们先来研究一个setup函数的参数，它主要有两个参数：\n第一个参数：props\n第二个参数：context\nprops非常好理解，它其实就是父组件传递过来的属性会被放到props对象中，我们在setup中如果需要使用，那么就可以直接通过props参数获取：\n对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义；\n并且在template中依然是可以正常去使用props中的属性，比如message；\n如果我们在setup函数中想要使用props，那么不可以通过 this 去获取（后面我会讲到为什么）；\n因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用即可；\n另外一个参数是context，我们也称之为是一个SetupContext，它里面包含三个属性：\nattrs：所有的非prop的attribute；\nslots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）；\nemit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）；\nsetup函数的返回值setup函数的两种返回值：\n\n若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）\n若返回一个渲染函数：则可以自定义渲染内容。（了解）\n\n注意点：\n\n尽量不要与Vue2.x配置混用\nVue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。\n但在setup中不能访问到Vue2.x配置（data、methos、computed…）。\n如果有重名, setup优先。\n\n\nsetup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）\n\n另外注意：setup不可以使用this\n官方关于this有这样一段描述\n表达的含义是this并没有指向当前组件实例；\n并且在setup被调用之前，data、computed、methods等都没有被解析；\n所以无法在setup中获取this；\n\n其实在之前的这段描述是和源码有出入的：\n之前的描述大概含义是不可以使用this是因为组件实例还没有被创建出来；\n通过阅读源码发现，代码是按照如下顺序执行的：\n调用 createComponentInstance 创建组件实 例；\n调用 setupComponent 初始化component内 部的操作；\n调用 setupStatefulComponent 初始化有状态的组件；\n在 setupStatefulComponent 取出了 setup 函 数；\n通过callWithErrorHandling 的函数执行 setup；\n从上面的代码我们可以看出， 组件的instance肯定是在执行setup函数之前就创建出来了。\n\nreactive函数\n作用: 定义一个对象类型的响应式数据（基本类型不要用它，控制台会报警告，要用ref函数）\n语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象）\nreactive定义的响应式数据是“深层次的”。\n内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n\n为什么就可以变成响应式的呢？\n这是因为当我们使用reactive函数处理我们的数据之后，数据再次被使用时就会进行依赖收集；\n当数据发生改变时，所有收集到的依赖都是进行对应的响应式操作（比如更新界面）；\n事实上，我们编写的data选项，也是在内部交给了reactive函数将其变成响应式对象的；\nref函数\n作用: 定义一个响应式的数据\n\n语法:\nconst xxx = ref(initValue)\n\n\n创建一个包含响应式数据的引用对象（reference对象，简称ref对象）, 其内部的值是在ref.value属性中被维护的 。\nJS中操作数据： xxx.value\n模板中读取数据: vue自动帮我们进行解包操作，不需要.value，直接：&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;\n\n\n备注：\n\n接收的数据可以是：基本类型、也可以是对象类型。\n基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。\n对象类型的数据：内部 求助 了Vue3.0中的一个新函数—— reactive函数。\n\n\n\ntoRefs如果我们使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后无论是修改解构后的变量，还是修改reactive返回的state对象，数据都不再是响应式的：\n\n那么有没有办法让我们解构出来的属性是响应式的呢？\nVue为我们提供了一个toRefs的函数，可以将reactive返回的对象中的属性都转成ref；\n那么我们再次进行结构出来的 name 和 age 本身都是 ref的；\n\n这种做法相当于已经在state.name和ref.value之间建立了 链接，任何一个修改都会引起另外一个变化；\ntoRef如果我们只希望转换一个reactive对象中的属性为ref, 那么可以使用toRef的方法\n\n应用: 要将响应式对象中的某个属性单独提供给外部使用时。\nref的其它APIunref如果我们想要获取一个ref引用中的value，那么也可以通过unref方法：\n如果参数是一个 ref，则返回内部值，否则返回参数本身；\n这是 val &#x3D; isRef(val) ? val.value : val 的语法糖函数；\nisRef判断值是否是一个ref对象。\nshallowRef创建一个浅层的ref对象；\ntriggerRef手动触发和 shallowRef 相关联的副作用\n\nshallowRef\nshallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n什么时候使用?\n如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。\n如果有一个对象数据，后续功能不会修改该对象中的属性，而是产生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。\n\n\n\ncustomRef创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制：\n它需要一个工厂函数，该函数接受 track 和 trigger 函数作为参数；\n并且应该返回一个带有 get 和 set 的对象；\n这里我们使用一个的案例：\n对双向绑定的属性进行debounce(节流)的操作；\n&lt;template&gt;\t&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;\t&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;ref,customRef&#125; from &#x27;vue&#x27;\texport default &#123;\t\tname:&#x27;Demo&#x27;,\t\tsetup()&#123;\t\t\t// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref\t\t\t//自定义一个myRef\t\t\tfunction myRef(value,delay)&#123;\t\t\t\tlet timer\t\t\t\t//通过customRef去实现自定义\t\t\t\treturn customRef((track,trigger)=&gt;&#123;\t\t\t\t\treturn&#123;\t\t\t\t\t\tget()&#123;\t\t\t\t\t\t\ttrack() //告诉Vue这个value值是需要被“追踪”的\t\t\t\t\t\t\treturn value\t\t\t\t\t\t&#125;,\t\t\t\t\t\tset(newValue)&#123;\t\t\t\t\t\t\tclearTimeout(timer)\t\t\t\t\t\t\ttimer = setTimeout(()=&gt;&#123;\t\t\t\t\t\t\t\tvalue = newValue\t\t\t\t\t\t\t\ttrigger() //告诉Vue去更新界面\t\t\t\t\t\t\t&#125;,delay)\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;\t\t\tlet keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref\t\t\treturn &#123;\t\t\t\tkeyword\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;\n\n响应式原理vue2// vue2.x 双向数据绑定原理是通过Objcet.defineProperty来实现的// 这种方式有缺点: 数组的长度 数组的内容发生变化检测不到let obj = &#123;  name: &#x27;zs&#x27;,  age: 18,  phone: &#123;    name: &#x27;iphone&#x27;  &#125;&#125;// let obj = [1, 2, 3, 4, 5]// 视图更新的方法function render() &#123;  console.log(&#x27;视图更新了 ~&#x27;);&#125;let methods = [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;, &#x27;splice&#x27;]// 将数组的原型保存一份let arrProto = Array.prototype// 创建原型 将数组原型拷贝一份let proto = Object.create(arrProto)// 重写数组的方法methods.forEach(method =&gt; &#123;  proto[method] = function () &#123; // AOP 面向切面编程    // 改变了数组的数据    arrProto[method].call(this, ...arguments)    // 重新渲染视图    render()  &#125;&#125;)// 观察者模式 function observe(obj) &#123;  // 判断一个对象是不是数组  // if(Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;)&#123;  if (Array.isArray(obj)) &#123;    // 让观测的对象的原型和我们自己重写的原型建立关系    obj.__proto__ = proto    return;  &#125;  // 如果观察的是一个对象的话 对其属性进行响应式监听(set、get)  if (Object.prototype.toString.call(obj) === &#x27;[object Object]&#x27;) &#123;    // 取出对象中的每一个键和值    for (let key in obj) &#123;      // 调用响应式处理函数      defineReactive(obj, key, obj[key])    &#125;  &#125;&#125;// 观察obj对象observe(obj)// 响应式处理// Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。function defineReactive(obj, key, val) &#123;  // 检测对象的属性值是否还是对象  observe(val)  Object.defineProperty(obj, key, &#123;    // 获取    get() &#123;      return val    &#125;,    // 设置    set(newVal) &#123;      // 检测设置的值是不是对象      observe(newVal)      // 新值和旧值不相等的时候      if (newVal !== val) &#123;        // 覆盖掉原来的val值        val = newVal        // 通知render函数重新渲染视图        render()      &#125;    &#125;  &#125;)&#125;// obj.name = &#x27;lisi&#x27;// obj.age = 20// console.log(obj.name, obj.age);// 至此 基本可以实现数据发生变化 视图更新的效果// 但是 如果数据有多层呢 也就是属性对应的值也是对象?// obj.phone.name = &#x27;huawei&#x27;// console.log(obj.phone.name);// 修改的值和原来的值一样 不需要重新渲染视图// obj.phone.name = &#x27;iphone&#x27;// 如果重新为对象obj的phone赋值一个新的对象呢? 视图要重新渲染// obj.phone = &#123;name: &#x27;huawei&#x27;&#125;// 并且当修改新的对象的属性值时 视图也要重新渲染// obj.phone.name = &#x27;zs&#x27;// 为对象新增属性值呢? 也是没有办法监测到的// obj.sex = &#x27;man&#x27;// $set来解决这个function $myset(obj, key, val)&#123;  if(Array.isArray(obj))&#123;    return obj.splice(key, val)  &#125;  defineReactive(obj, key, val)&#125;// $myset(obj, &#x27;sex&#x27;, &#x27;man&#x27;)// 修改新增的属性值 视图也能更新// obj.sex = &#x27;woman&#x27;// obj.phone = Object.assign(obj.phone, &#123;price: &#x27;666&#x27;&#125;)// obj.phone.price = 888// obj.phone = &#123;...obj.phone, ...&#123;price: &#x27;666&#x27;&#125;&#125;// obj.phone.price = &#x27;888&#x27;// 以后vue涉及到给data中的对象新增属性时 有三种方式// 1、this.$set() || Vue.set()// 2、obj = Object.assign(原对象, 新对象(新增的属性:值))// 2、obj = &#123;...原对象, ...新对象(新增的属性:值)&#125;// =================== 数组 ======================// 数组的响应式数据处理依赖的并不是Object.defineProperty 而是对数组的能够引起数据变化的方法进行重写// obj.push(6)// obj.length ++ // obj[0] = 88// $myset(obj, &#x27;0&#x27;, 66)\n\nvue3// vue3响应式原理利用了es6提供的proxy Api// 可以直接监听到对象和数组内容及长度的变化// 缺点: 兼容性差 支持就用proxy 不支持就用Objcet.definePropertylet obj = &#123;  name: &#x27;zs&#x27;,  girlFriend: &#123; name: &#x27;刘亦菲&#x27; &#125;,  arr: [1, 2, 3]&#125;function render() &#123;  console.log(&#x27;视图重新渲染 ~&#x27;);&#125;let handler = &#123;  get(target, key) &#123;    // Reflect.get(target, propertyKey[, receiver])    // 获取对象身上某个属性的值，类似于 target[name]。    // 如果属性的值是一个对象的话 则重新进行代理 设置set&amp;get    if(typeof target[key] == &#x27;object&#x27; &amp;&amp; target[key] != null)&#123;      return new Proxy(target[key], handler)    &#125;    return Reflect.get(target, key)  &#125;,  set(target, key, val) &#123;    // if(target[key] == &#x27;length&#x27;) return true    Reflect.set(target, key, val)    render()    // return true表示赋值成功 如果不返回true 在严格模式下可能会报TypeError    return true  &#125;&#125;let proxy = new Proxy(obj, handler)// 使用代理后的对象// console.log(proxy.name);// console.log(proxy.grilFriend);// proxy.name = &#x27;lisi&#x27;// 修改深层次的对象的属性 无法监听到// proxy.grilFriend.name = &#x27;黄圣依&#x27;// console.log(proxy.name);// console.log(proxy.grilFriend);// console.log(obj.name);// console.log(obj.grilFriend);proxy.arr[0] = &#x27;11&#x27;proxy.arr.length ++// console.log(proxy.arr.length);console.log(obj.arr.length);\n\nref &amp; reactive\n从定义数据角度对比：\nref用来定义：基本类型数据。\nreactive用来定义：对象（或数组）类型数据。\n备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。\n\n\n从原理角度对比：\nref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。\nreactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。\n\n\n从使用角度对比：\nref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\nreactive定义的数据：操作数据与读取数据：均不需要.value。\n\n\n\nreadonly我们通过reactive或者ref可以获取到一个响应式的对象，但是某些情况下，我们传入给其他地方（组件）**的这个 响应式对象希望**在另外一个地方（组件）被使用**，但是不能被修改，这个时候如何防止这种情况的出现**呢？\nVue3为我们提供了readonly的方法；\nreadonly会返回原生对象的只读代理（也就是它依然是一个Proxy，这是一个proxy的set方法被劫持，并且不 能对其进行修改）；\n在开发中常见的readonly方法会传入三个类型的参数：\n类型一：普通对象；\n类型二：reactive返回的对象；\n类型三：ref的对象；\n在readonly的使用过程中，有如下规则：\nreadonly返回的对象都是不允许修改的；\n但是经过readonly处理的原来的对象是允许被修改的；\n比如 const info &#x3D; readonly(obj)，info对象是不允许被修改的；\n当obj被修改时，readonly返回的info对象也会被修改；\n但是我们不能去修改readonly返回的对象info；\n其实本质上就是readonly返回的对象的setter方法被劫持了而已；\n应用场景：在我们传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用readonly了；\nreactive 判断的APIisProxy检查对象是否是由 reactive 或 readonly创建的 proxy。\nisReactive检查对象是否是由 reactive创建的响应式代理：\n如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true；\nisReadonly检查对象是否是由 readonly 创建的只读代理。\ntoRaw返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）。\nshallowReactive创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)。\nshallowReadonly创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）。\n只处理对象最外层属性的响应式（浅响应式）。\n深度监听存在的问题： 如果数据量比较大，非常消耗性能。 有些时候我们并不需要对数据进行深度监听。 这个时候就没有必要使用ref和reactive\n其它 Composition APItoRaw &amp; markRaw\ntoRaw：\n作用：将一个由reactive生成的响应式对象转为普通对象。\n使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\n\n\nmarkRaw：\n作用：标记一个对象，使其永远不会再成为响应式对象。\n应用场景:\n有些值不应被设置为响应式的，例如复杂的第三方类库等。\n当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\n\n\n\n\n&lt;template&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;h3&gt;&#123;&#123; oldObj &#125;&#125;&lt;/h3&gt;    &lt;button @click=&quot;changeInfo&quot;&gt;修改&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; toRaw, reactive, markRaw &#125; from &quot;vue&quot;;export default &#123;  setup() &#123;        // let obj = reactive(&#123;    //   name: &#x27;zs&#x27;    // &#125;)        // 获取 reactive 或 readonly 代理的原始对象    // let oldObj = toRaw(obj)    // console.log(oldObj);    // ======= markRaw ========    let obj = &#123;      name: &#x27;zs&#x27;    &#125;    // 标记一个对象，使其永远不会再成为响应式对象。    let oldObj = markRaw(obj)    console.log(oldObj);    // 设置响应式失效    oldObj = reactive(oldObj)    function changeInfo()&#123;      oldObj.name = &#x27;lisi&#x27;      // 数据发生变化 =&gt; 视图没有更新      console.log(oldObj.name );    &#125;        return &#123;      oldObj,      changeInfo    &#125;  &#125;&#125;&lt;/script&gt;\n\nprovide 与 inject\n\n作用：实现祖与后代组件间通信\n\n套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n具体写法：\n\n祖组件中：\nsetup()&#123;\t......    let car = reactive(&#123;name:&#x27;奔驰&#x27;,price:&#x27;40万&#x27;&#125;)    provide(&#x27;car&#x27;,car)    ......&#125;\n\n后代组件中：\nsetup(props,context)&#123;\t......    const car = inject(&#x27;car&#x27;)    return &#123;car&#125;\t......&#125;\n\n计算属性与监视computed&lt;template&gt;  &lt;div&gt;    姓名: &#123;&#123; fullName &#125;&#125;&lt;br&gt;    修改姓名: &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt;&lt;br&gt;    姓:&lt;input type=&quot;text&quot; v-model=&quot;stu.firstName&quot;&gt;&lt;br&gt;    名:&lt;input type=&quot;text&quot; v-model=&quot;stu.lastName&quot;&gt;&lt;br&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; reactive, computed &#125; from &#x27;vue&#x27;;export default &#123;  // vue2的computed简单写法  // computed: &#123;  //   fullName() &#123;  //     return this.stu.firstName + &#x27;-&#x27; + this.stu.lastName  //   &#125;  // &#125;,  // vue2的computed完整写法  // computed: &#123;  //   fullName: &#123;  //     get()&#123;  //       return this.stu.firstName + &#x27;-&#x27; + this.stu.lastName  //     &#125;,  //     set()&#123;  //       console.log(111);  //     &#125;  //   &#125;  // &#125;,   setup() &#123;    let stu = reactive(&#123;      firstName: &#x27;张&#x27;,      lastName: &#x27;三&#x27;    &#125;)    // vu3 computed 简写 =&gt; 修改报警告需要提供setter    // let fullName = computed(()=&gt;&#123;    //   return stu.firstName + &#x27;-&#x27; + stu.lastName    // &#125;)    // 挂载到stu上    // stu.fullName = computed(()=&gt;&#123;    //   return stu.firstName + &#x27;-&#x27; + stu.lastName    // &#125;)    // vue3 computed 完整写法 =&gt; 可读可写    let fullName = computed(&#123;      get() &#123;        return stu.firstName + &#x27;-&#x27; + stu.lastName      &#125;,      set(val)&#123;        let arr = val.split(&#x27;-&#x27;)        stu.firstName = arr[0]        stu.lastName = arr[1]      &#125;    &#125;)    return &#123;      stu,      fullName    &#125;  &#125;&#125;&lt;/script&gt;\n\nwatch\n与Vue2.x中watch配置功能一致\n两个小“坑”：\n监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。\n监视reactive定义的响应式数据中某个属性时：deep配置有效。\n\n\n\n//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据   若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！   若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive定义的对象中的某个属性，所以deep配置有效\n\n在前面的Options API中，我们可以通过watch选项来侦听data或者props的数据变化，当数据变化时执行某一些 操作。\n而在Composition API中，我们可以使用watchEffect和watch来完成响应式数据的侦听；\nwatchEffect用于自动收集响应式数据的依赖；\nwatch需要手动指定侦听的数据源；\nwatchEffect\nwatch的套路是：既要指明监视的属性，也要指明监视的回调。\nwatchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。watchEffect 是默认会执行一次。\nwatchEffect有点像computed：\n但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n\n\nwatchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123;    const x1 = sum.value    const x2 = person.age    console.log(&#x27;watchEffect配置的回调执行了&#x27;)&#125;)\n\nwatchEffect 停止侦听setup() &#123;    // ref定义的响应式数据    let num = ref(0)    let stu = reactive(&#123;      name: &#x27;zs&#x27;,      friend: &#123;        name: &#x27;lisi&#x27;      &#125;    &#125;)    let addNum = () =&gt; &#123;      ++num.value      if (num.value &gt; 5) &#123;        // 停止侦听        stop()      &#125;    &#125;    // 首先，watchEffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖；    // 其次，只有收集的依赖发生变化时，watchEffect传入的函数才会再次执行；    let stop = watchEffect((onInvalidate) =&gt; &#123;      // 没有所谓的深度监视      // console.log(num.value, stu.friend.name);      console.log(num.value);      onInvalidate(()=&gt;&#123;        console.log(&#x27;取消上一次请求~&#x27;);        clearTimeout(timeId)      &#125;)      const timeId = setTimeout(()=&gt;&#123;        console.log(&#x27;发起请求~&#x27;);      &#125;, 2000)    &#125;)    return &#123;      num,      addNum,      ...toRefs(stu)    &#125;  &#125;\n\nwatchEffect 清除副作用什么是清除副作用呢？\n比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器， 或者侦听器侦听函数被再次执行了。\n那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用；\n在我们给watchEffect传入的函数被回调时，其实可以获取到一个参数：onInvalidate\n当副作用即将重新执行 或者 侦听器被停止 时会执行该函数传入的回调函数；\n我们可以在传入的回调函数中，执行一些清除工作；\n代码参上\n\nsetup中使用ref在讲解 watchEffect执行时机之前，我们先补充一个知识：在setup中如何使用ref获取元素或者组件？\n其实非常简单，我们只需要定义一个ref对象，绑定到元素或者组件的ref属性上即可；\n&lt;template&gt;  &lt;div&gt;    &lt;h3 ref=&quot;title&quot;&gt;&lt;/h3&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;;export default &#123;  setup() &#123;    // vue2中的ref是用来获取dom元素或者组件实例的    // vue3中没有 this 获取不到    // console.log(this.$refs.title);    let title = ref(null)    watchEffect(()=&gt; &#123;      console.log(title.value);    &#125;, &#123;      flush: &#x27;post&#x27;    &#125;)    return &#123;        title    &#125;  &#125;&#125;&lt;/script&gt;\n\nwatchEffect的执行时机默认情况下，组件的更新会在副作用函数执行之前：\n如果我们希望在副作用函数中获取到元素，是否可行呢？\n如上代码我们会发现打印结果打印了两次：\n这是因为setup函数在执行时就会立即执行传入的副作用函数，这个时候DOM并没有挂载，所以打印为null；\n而当DOM挂载时，会给title的ref对象赋值新的值，副作用函数会再次执行，打印出来对应的元素；\n调整watchEffect的执行时机如果我们希望在第一次的时候就打印出来对应的元素呢？\n这个时候我们需要改变副作用函数的执行时机；\n它的默认值是pre，它会在元素 挂载 或者 更新 之前执行；\n所以我们会先打印出来一个空的，当依赖的title发生改变时，就会再次执行一次，打印出元素；\nflush 选项还接受 sync，这将强制效果始终同步触发。然而，这是低效的，应该很少需要。\nwatch函数\n与Vue2.x中watch配置功能一致\n\n两个小“坑”：\n\n监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。\n监视reactive定义的响应式数据中某个属性时：deep配置有效。\n\n与watchEffect的比较，watch允许我们：\n懒执行副作用（第一次不会直接执行）；\n更具体的说明当哪些状态发生变化时，触发侦听器的执行；\n访问侦听状态变化前后的值；\n//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据   若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！   若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive定义的对象中的某个属性，所以deep配置有效\n\n生命周期函数\nVue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：\nbeforeDestroy改名为 beforeUnmount\ndestroyed改名为 unmounted\n\n\nVue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：\nbeforeCreate&#x3D;&#x3D;&#x3D;&gt;setup()\ncreated&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;setup()\nbeforeMount &#x3D;&#x3D;&#x3D;&gt;onBeforeMount\nmounted&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onMounted\nbeforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdate\nupdated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUpdated\nbeforeUnmount &#x3D;&#x3D;&gt;onBeforeUnmount\nunmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUnmounted\n\n\n\n\n自定义hook函数\n什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。\n类似于vue2.x中的mixin。\n自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。\n\nuseCounter\nimport &#123;ref, computed&#125; from &#x27;vue&#x27;export default function () &#123;  let count = ref(0)  const increment = () =&gt; &#123;    count.value ++   &#125;  const decrement = () =&gt; &#123;    count.value --   &#125;  const doubleCount = computed(()=&gt;&#123;    return count.value * 2  &#125;)  return &#123;    count,    doubleCount,    increment,    decrement  &#125;&#125;\n\nuseTitle\nimport &#123;ref, reactive, watch&#125; from &#x27;vue&#x27;export default function(title=&#x27;默认title&#x27;)&#123;  let titleRef = ref(title)  watch(titleRef, ()=&gt;&#123;    document.title = titleRef.value  &#125;)  return titleRef&#125;\n\nApp.vue\n&lt;template&gt;  &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;  &lt;p&gt;&#123;&#123; doubleCount &#125;&#125;&lt;/p&gt;  &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;  &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import useCounter from &#x27;./hooks/useCounter&#x27;import useTitle from &#x27;./hooks/useTitle&#x27;import &#123; toRefs, reactive &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    let counter = reactive(useCounter())    useTitle().value = &#x27;使用hooks&#x27;    return &#123;      ...toRefs(counter)    &#125;  &#125;&#125;&lt;/script&gt;\n\nsetup的顶层编写方式\n博客：https://blog.csdn.net/weixin_43931876/article/details/120058286\n官网：https://v3.cn.vuejs.org/api/sfc-spec.html#script-setup\n\n新的组件Fragment\n在Vue2中: 组件必须有一个根标签\n在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中\n好处: 减少标签层级, 减小内存占用\n\nTeleport\n什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术\nApp.vue\n&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    App组件    &lt;Father&gt;&lt;/Father&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Father from &#x27;./components/Father.vue&#x27;export default &#123;  components: &#123;    Father,  &#125;,  setup() &#123;  &#125;&#125;&lt;/script&gt;&lt;style&gt;.app &#123;  padding: 40px;  background-color: hotpink;&#125;&lt;/style&gt;\n\nFather.vue\n&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    Father组件    &lt;Son&gt;&lt;/Son&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son from &#x27;./Son.vue&#x27;export default &#123;  components: &#123;    Son  &#125;,  setup(props) &#123;  &#125;&#125;&lt;/script&gt;&lt;style&gt;.father &#123;  padding: 40px;  background-color: skyblue;&#125;&lt;/style&gt;\n\nSon.vue\n&lt;template&gt;  &lt;div class=&quot;son&quot;&gt;    Son组件    &lt;button @click=&quot;isShow = true&quot;&gt;显示弹窗&lt;/button&gt;    &lt;teleport to=&quot;body&quot;&gt;      &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;        &lt;div class=&quot;dialog&quot;&gt;          &lt;h3&gt;我是一个弹窗&lt;/h3&gt;          &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/teleport&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    let isShow = ref(false)    return &#123;      isShow    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.son &#123;  padding: 40px;  background-color: yellow;&#125;body &#123;  position: relative;&#125;.dialog &#123;  width: 300px;  height: 300px;  position: absolute;  left: 50%;  top: 50%;  transform: translate(-50%, -50%);  background-color: azure;  text-align: center;&#125;.mask &#123;  width: 100%;  height: 100%;  background: rgba(0, 0, 0, .5);&#125;&lt;/style&gt;\n\nSuspense\n等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n使用步骤：\nApp.vue\n&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    App组件    &lt;Suspense&gt;      &lt;template v-slot:default&gt;        &lt;Father&gt;&lt;/Father&gt;      &lt;/template&gt;      &lt;template v-slot:fallback&gt;        &lt;h3&gt;精彩内容正在加载中 ...&lt;/h3&gt;      &lt;/template&gt;    &lt;/Suspense&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 静态加载 同步// import Father from &#x27;./components/Father.vue&#x27;// 异步加载import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const Father = defineAsyncComponent(()=&gt;import(&#x27;./components/Father.vue&#x27;))export default &#123;  components: &#123;    Father,  &#125;,  setup() &#123;  &#125;,  &#125;&lt;/script&gt;&lt;style&gt;.app &#123;  padding: 40px;  background-color: hotpink;&#125;&lt;/style&gt;\n\nFather.vue\n&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    Father组件    &#123;&#123; num &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123;  async setup(props) &#123;    let num = ref(0)    // return new Promise((resolve, rejects)=&gt; &#123;    //   setTimeout(function()&#123;    //     resolve(&#123;num&#125;)    //   &#125;, 3000)    // &#125;)    let res = await new Promise((resolve, rejects) =&gt; &#123;      setTimeout(function () &#123;        resolve(&#123; num &#125;)      &#125;, 3000)    &#125;)    return res  &#125;&#125;&lt;/script&gt;&lt;style&gt;.father &#123;  padding: 40px;  background-color: skyblue;&#125;&lt;/style&gt;\n\n其它全局API的转移Vue 2.x 有许多全局 API 和配置。\n\n例如：注册全局组件、注册全局指令等。\n\n//注册全局组件Vue.component(&#x27;MyButton&#x27;, &#123;  data: () =&gt; (&#123;    count: 0  &#125;),  template: &#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;&#125;)//注册全局指令Vue.directive(&#x27;focus&#x27;, &#123;  inserted: el =&gt; el.focus()&#125;\n\nVue3.0中对这些API做出了调整：\n\n将全局的API，即：Vue.xxx调整到应用实例（app）上\n\n\n\n2.x 全局 API（Vue）\n3.x 实例 API (app)\n\n\n\nVue.config.xxxx\napp.config.xxxx\n\n\nVue.config.productionTip\n移除\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use\n\n\nVue.prototype\napp.config.globalProperties\n\n\n\n\n其它改变\ndata选项应始终被声明为一个函数。\n\n过度类名的更改：\n\nVue2.x写法\n.v-enter,.v-leave-to &#123;  opacity: 0;&#125;.v-leave,.v-enter-to &#123;  opacity: 1;&#125;\n\nVue3.x写法\n.v-enter-from,.v-leave-to &#123;  opacity: 0;&#125;.v-leave-from,.v-enter-to &#123;  opacity: 1;&#125;\n\n\n移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes\n\n移除v-on.native修饰符\n\n父组件中绑定事件\n&lt;my-component  v-on:close=&quot;handleComponentEvent&quot;  v-on:click=&quot;handleNativeClickEvent&quot;/&gt;\n\n子组件中声明自定义事件\n&lt;script&gt;  export default &#123;    emits: [&#x27;close&#x27;]  &#125;&lt;/script&gt;\n\n\n移除过滤器（filter）\n\n过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。\n\n\n…\n\n\nh函数Vue推荐在绝大数情况下使用模板来创建你的HTML，然而一些特殊的场景，你真的需要Javascript的完全编程的能力，这个时候你可以使用渲染函数 ，它比模板更接近编译器；\n前面我们讲解过VNode和VDOM的改变：\nVue在生成真实的DOM之前，会将我们的节点转换成VNode，而VNode组合在一起形成一颗树结构，就是虚拟DOM（VDOM）；\n事实上，我们之前编写的 template 中的HTML 最终也是使用渲染函数生成对应的VNode；\n那么，如果你想充分的利用JavaScript的编程能力，我们可以自己来编写 createVNode 函数，生成对应的 VNode；\n那么我们应该怎么来做呢？使用h()函数\nh() 函数是一个用于创建 vnode 的一个函数；\n其实更准确的命名是 createVNode() 函数，但是为了简便在Vue将之简化为 h() 函数；\n如何使用？\n注意事项：\n如果没有props，那么通常可以将children作为第二个参数传入；\n如果会产生歧义，可以将null作为第二个参数传入，将children作为第三个参数传入；\n&lt;script&gt;import &#123; h &#125; from &#x27;vue&#x27;export default&#123;  render()&#123;    return h(&#x27;h4&#x27;, &#123;class: &#x27;title&#x27;&#125;, &quot;hello h函数&quot;)  &#125;&#125;&lt;/script&gt;\n\n实现计数器&lt;script&gt;import &#123; h, ref &#125; from &#x27;vue&#x27;export default &#123;  // data()&#123;  //   return &#123;  //     count: 0  //   &#125;  // &#125;,  setup() &#123;    let count = ref(0)    // return &#123; count &#125;    return () =&gt; &#123;      return h(&#x27;div&#x27;, &#123; class: &#x27;counter&#x27; &#125;, [        h(&#x27;h4&#x27;, null, `当前计数为:$&#123;count.value&#125;`),        h(&#x27;button&#x27;, &#123;          onClick: () =&gt; count.value++        &#125;, &#x27;++&#x27;),        h(&#x27;button&#x27;, &#123;          onClick: () =&gt; count.value--        &#125;, &#x27;--&#x27;)      ])    &#125;  &#125;,  // render()&#123;  //   return h(&#x27;div&#x27;, &#123;class: &#x27;counter&#x27;&#125;, [  //     h(&#x27;h4&#x27;, null, `当前计数为:$&#123;this.count&#125;`),  //     h(&#x27;button&#x27;, &#123;  //       onClick: () =&gt; this.count ++  //     &#125;, &#x27;++&#x27;),  //     h(&#x27;button&#x27;, &#123;  //       onClick: () =&gt; this.count --  //     &#125;, &#x27;--&#x27;)  //   ])  // &#125;&#125;&lt;/script&gt;\n\n渲染插槽\n先了解下插槽的用法，可参照setup顶层编写方式内的博客网址\n\nApp.vue\n&lt;script&gt;import &#123; h &#125; from &#x27;vue&#x27;import Hi from &#x27;./05-Hi&#x27;export default &#123;  setup() &#123;    return () =&gt; &#123;      return h(Hi, null, &#123;        default: props =&gt; h(&#x27;h4&#x27;, null, `05-render函数渲染插槽$&#123;props.title&#125;`)      &#125;)    &#125;  &#125;,&#125;&lt;/script&gt;\n\nHi.vue\n&lt;script&gt;import &#123; h &#125; from &#x27;vue&#x27;  export default &#123;    render() &#123;      return h(&#x27;h4&#x27;, &#123;class: &#x27;title&#x27;&#125;, [        h(&#x27;h2&#x27;,null, &quot;hi ~~&quot;),        this.$slots.default ?         this.$slots.default(&#123;title: &quot;--本手俗手妙手无从下手&quot;&#125;) : h(&#x27;span&#x27;, null, &#x27;Hi组件默认插槽内容&#x27;)      ])    &#125;  &#125;&lt;/script&gt;\n\njsx如果我们希望在项目中使用jsx，那么我们需要添加对jsx的支持：\njsx我们通常会通过Babel来进行转换（React编写的jsx就是通过babel转换的）；\n对于Vue来说，我们只需要在Babel中配置对应的插件即可；\n安装Babel支持Vue的jsx插件：\nnpm install @vue/babel-plugin-jsx -D\n\n在babel.config.js配置文件中配置插件（现在好像不需要配置了）\nmodule.exports = &#123;  presets: [    &#x27;@vue/cli-plugin-babel/preset&#x27;  ],  plugins: [    &quot;@vue/babel-plugin-jsx&quot;  ]&#125;\n\n实现计数器&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123;  data() &#123;    return &#123;      count: 0    &#125;  &#125;,  render() &#123;    const increment = () =&gt; this.count++    const decrement = () =&gt; this.count--    return (      &lt;div&gt;        &lt;h4&gt;当前计数: &#123;this.count&#125;&lt;/h4&gt;        &lt;button onClick=&#123;increment&#125;&gt;++&lt;/button&gt;        &lt;button onClick=&#123;decrement&#125;&gt;--&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;&lt;/script&gt;\n\n组件使用Hi.vue\n&lt;script&gt;export default &#123;  render(h) &#123;    return (      &lt;div&gt;        &lt;h3&gt;Hi组件&lt;/h3&gt;        &#123;this.$slots.default ? this.$slots.default() : &lt;span&gt;哇咔咔&lt;/span&gt;&#125;      &lt;/div&gt;    )  &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\nApp.vue\n&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;import Hi from &#x27;./06-Hi.vue&#x27;export default &#123;  data() &#123;    return &#123;      count: 0    &#125;  &#125;,  render() &#123;    const increment = () =&gt; this.count++    const decrement = () =&gt; this.count--    return (      &lt;div&gt;        &lt;h4&gt;当前计数: &#123;this.count&#125;&lt;/h4&gt;        &lt;button onClick=&#123;increment&#125;&gt;++&lt;/button&gt;        &lt;button onClick=&#123;decrement&#125;&gt;--&lt;/button&gt;        &lt;Hi&gt;          &#123;&#123;default: props =&gt; &lt;button&gt;我是按钮&lt;/button&gt;&#125;&#125;        &lt;/Hi&gt;      &lt;/div&gt;    )  &#125;&#125;&lt;/script&gt;\n\nsetup写法\n&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;import Hi from &#x27;./06-Hi.vue&#x27;export default &#123;  setup() &#123;    let count = ref(0)    const increment = () =&gt; count.value++    const decrement = () =&gt; count.value--    const getVal = (num) =&gt; &#123;      console.log(num)      // vue3需要使用高阶函数来获取到e      return (e)=&gt; &#123;          console.log(e.target.checked)      &#125;    &#125;    return ()=&gt; &#123;      return (        &lt;div&gt;          &lt;input type=&quot;checkbox&quot; checked onChange=&#123; getVal(1) &#125;/&gt;          &lt;h4&gt;当前计数: &#123;count.value&#125;&lt;/h4&gt;          &lt;button onClick=&#123;increment&#125;&gt;++&lt;/button&gt;          &lt;button onClick=&#123;decrement&#125;&gt;--&lt;/button&gt;        &lt;/div&gt;      )    &#125;  &#125;&lt;/script&gt;\n\n自定义指令在Vue的模板语法中我们学习过各种各样的指令：v-show、v-for、v-model等等，除了使用这些指令之外，Vue也允许我们来自定义自己的指令\n注意：在Vue中，代码的复用和抽象主要还是通过组件；\n通常在某些情况下，你需要对DOM元素进行底层操作，这个时候就会用到自定义指令；\n自定义指令分为两种：\n自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用；\n自定义全局指令：app的 directive 方法，可以在任意组件中被使用；\n比如我们来做一个非常简单的案例：当某个元素挂载完成后可以自定获取焦点\n实现方式一：如果我们使用默认的实现方式；\n实现方式二：自定义一个 v-focus 的局部指令；\n实现方式三：自定义一个 v-focus 的全局指令；\n聚焦实现&lt;template&gt;  &lt;input type=&quot;text&quot; ref=&quot;iptRef&quot; v-focus&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, nextTick, onMounted, directives &#125; from &#x27;vue&#x27;export default &#123;  // directives选项  // directives: &#123;  //   focus: &#123;  //     // 指令的生命周期 不是 vue3的生命周期  //     mounted(el) &#123;  //       el.focus()  //     &#125;,  //   &#125;  // &#125;,  setup() &#123;    const iptRef = ref(null)    // nextTick(()=&gt;&#123;    //   iptRef.value.focus()    // &#125;)    // onMounted(()=&gt; &#123;    //   iptRef.value.focus()    // &#125;)    return &#123;      iptRef    &#125;  &#125;&#125;&lt;/script&gt;\n\n局部自定义指令自定义一个 v-focus 的局部指令\n这个自定义指令实现非常简单，我们只需要在组件选项中使用 directives 即可；\n它是一个对象，在对象中编写我们自定义指令的名称（注意：这里不需要加v-）；\n自定义指令有一个生命周期，是在组件挂载后调用的 mounted，我们可以在其中完成操作；\n&lt;template&gt;  &lt;input type=&quot;text&quot; ref=&quot;iptRef&quot; v-focus&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, directives &#125; from &#x27;vue&#x27;export default &#123;  // directives选项  directives: &#123;    focus: &#123;      // 指令的生命周期 不是 vue3的生命周期      mounted(el) &#123;        el.focus()      &#125;,    &#125;  &#125;,&#125;&lt;/script&gt;\n\n全局自定义指令// 全局自定义指令 =&gt; 放在mount之前app.directive(&quot;focus&quot;, &#123;  mounted(el) &#123;    el.focus()  &#125;&#125;)\n\n指令的生命周期一个指令定义的对象，Vue提供了如下的几个钩子函数：\ncreated：在绑定元素的 attribute 或事件监听器被应用之前调用；\nbeforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用；\nmounted：在绑定元素的父组件被挂载后调用；\nbeforeUpdate：在更新包含组件的 VNode 之前调用；\nupdated：在包含组件的 VNode 及其子组件的 VNode 更新后调用；\nbeforeUnmount：在卸载绑定元素的父组件之前调用；\nunmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次；\n指令的参数和修饰符如果我们指令需要接受一些参数或者修饰符应该如何操作呢？\ninfo是参数的名称；\naaa-bbb是修饰符的名称；\n后面是传入的具体的值；\n在我们的生命周期中，我们可以通过 bindings 获取到对应的内容：\n&lt;template&gt;  &lt;input type=&quot;text&quot; v-myDir.aaa.bbb=&quot;&#123;name:&#x27;zs&#x27;&#125;&quot; v-if=&quot;count &lt; 5&quot;&gt;  &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt;  &lt;button @click=&quot;increment&quot;&gt;++&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, directives &#125; from &#x27;vue&#x27;export default &#123;  directives: &#123;    myDir: &#123;      created() &#123;        console.log(&#x27;created&#x27;)      &#125;,      beforeMount() &#123;        console.log(&#x27;beforeMount&#x27;)      &#125;,      mounted(el, binding) &#123;        console.log(binding)      &#125;,      beforeUpdate() &#123;        console.log(&#x27;beforeUpdate&#x27;)      &#125;,      updated() &#123;        console.log(&#x27;updated&#x27;)      &#125;,      beforeUnmount() &#123;        console.log(&#x27;beforeUnmount&#x27;)      &#125;,      unmounted() &#123;        console.log(&#x27;unmounted&#x27;)      &#125;,    &#125;  &#125;,  setup() &#123;    let count = ref(0)    const increment = ()=&gt; &#123;      count.value ++    &#125;    return &#123;      count,      increment    &#125;  &#125;&#125;&lt;/script&gt;\n\n自定义指令练习自定义指令案例：时间戳的显示需求：\n在开发中，大多数情况下从服务器获取到的都是时间戳；\n我们需要将时间戳转换成具体格式化的时间来展示；\n在Vue2中我们可以通过过滤器来完成；\n在Vue3中我们可以通过 计算属性（computed） 或者 自定义一个方法（methods） 来完成；\n其实我们还可以通过一个自定义的指令来完成；\n我们来实现一个可以自动对时间格式化的指令v-format-time：\n这里我封装了一个函数，在首页中我们只需要调用这个函数并且传入app即可；\nformat-time.js\nimport dayjs from &#x27;dayjs&#x27;export default (app) =&gt; &#123;  // 挂载全局自定义指令  app.directive(&#x27;format-time&#x27;, &#123;    mounted(el, binding) &#123;      // 获取到用户指定的格式      let formatStr = binding.value      // 如果用户没有传格式      if(!binding.value)&#123;        // 给个默认的格式        formatStr = &#x27;YYYY-MM-DD hh:mm:ss&#x27;      &#125;      // 拿到组件标签上的时间戳      let timeStamp = el.textContent      if(timeStamp.length == 10)&#123;        // 秒 =&gt; 毫秒        timeStamp = timeStamp * 1000      &#125;      el.textContent = dayjs(parseInt(timeStamp)).format(formatStr)    &#125;,  &#125;)&#125;// main.js 引入自定义指令 import &#123; formatTime &#125; from &#x27;./directives&#x27;formatTime(app)\n\nTime.vue\n&lt;template&gt;  &lt;h3 v-format-time=&quot;&#x27;YYYY/MM/DD&#x27;&quot; &gt; 1654766827786 &lt;/h3&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    let count = ref(0)    const increment = ()=&gt; &#123;      count.value ++    &#125;    return &#123;      count,      increment    &#125;  &#125;&#125;&lt;/script&gt;\n\nplugins通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式：\n对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行；\n函数类型：一个function，这个函数会在安装插件时自动执行；\n插件可以完成的功能没有限制，比如下面的几种都是可以的：\n添加全局方法或者 property，通过把它们添加到 config.globalProperties 上实现；\n添加全局资源：指令&#x2F;过滤器&#x2F;过渡等；\n通过全局 mixin 来添加一些组件选项；\n一个库，提供自己的 API，同时提供上面提到的一个或多个功能；\nApp.vue\n&lt;template&gt;  &lt;h3&gt;哥们 你这睡眠质量不行呀 我一般都8小时后才发现&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;export default &#123;  // mounted()&#123;  //   console.log(this.$msg)  // &#125;  setup()&#123;    // console.log(this.$msg)    // setup中没有this指向 所以不能像vue2获取原型上的数据    // 需要按照下面的方式    let instance = getCurrentInstance()    console.log(instance.appContext.config.globalProperties.$msg)  &#125;&#125;&lt;/script&gt;// main.js引入插件import msgPluginObject from &#x27;./plugins/msgPlugin-object&#x27;import msgPluginFunction from &#x27;./plugins/msgPlugin-function&#x27;// 使用插件// app.use(msgPluginObject)// use相当于 msgPlugin.install(app)app.use(msgPluginFunction)\n\n函数写法export default (app) =&gt; &#123;  app.config.globalProperties.$msg = &quot;听说高考数学卷很难 刚刚试了下 两小时后才发现试卷拿反了&quot;&#125;\n\n对象写法export default &#123;  install(app)&#123;    // 往app原型上添加属性    app.config.globalProperties.$msg = &quot;听说高考数学卷很难 刚刚试了下 两小时后才发现试卷拿反了&quot;  &#125;&#125;\n\n路由待更新 ~\nVuex待更新 ~\nPiniaVuex 作为一个老牌 Vue 状态管理库，大家都很熟悉了\nPinia 是 Vue.js 团队成员专门为 Vue 开发的一个全新的状态管理库，并且已经被纳入官方 github\n为什么有 Vuex 了还要再开发一个 Pinia ？\n先来一张图，看下当时对于** Vuex5 的提案**，就是下一代 Vuex5 应该是什么样子的\n\nPinia 就是完整的符合了他当时 Vuex5 提案所提到的功能点，所以可以说 Pinia 就是 Vuex5 也不为过，因为它的作者就是官方的开发人员，并且已经被官方接管了，只是目前 Vuex 和 Pinia 还是两个独立的仓库，以后可能会合并，也可能独立发展，只是官方肯定推荐的是 Pinia\n因为在 Vue3 中使用 Vuex 的话需要使用 Vuex4，并且还只能作为一个过渡的选择，存在很大缺陷，所以在 Componsition API 诞生之后，也就设计了全新的状态管理 Pinia\nPinia 特性\nPinia 没有 Mutations\nActions 支持同步和异步\n没有模块的嵌套结构\n\nPinia 通过设计提供扁平结构，就是说每个 store 都是互相独立的，谁也不属于谁，也就是扁平化了，更好的代码分割且没有命名空间。当然你也可以通过在一个模块中导入另一个模块来隐式嵌套 store，甚至可以拥有 store 的循环依赖关系\n\n\n更好的 TypeScript 支持\n\n不需要再创建自定义的复杂包装器来支持 TypeScript 所有内容都类型化，并且 API 的设计方式也尽可能的使用 TS 类型推断\n\n\n不需要注入、导入函数、调用它们，享受自动补全，让我们开发更加方便\n无需手动添加 store，它的模块默认情况下创建就自动注册的\nVue2 和 Vue3 都支持\n\n除了初始化安装和SSR配置之外，两者使用上的API都是相同的\n\n\n支持 Vue DevTools\n\n跟踪 actions, mutations 的时间线\n在使用了模块的组件中就可以观察到模块本身\n支持 time-travel 更容易调试\n在 Vue2 中 Pinia 会使用 Vuex 的所有接口，所以它俩不能一起使用\n但是针对 Vue3 的调试工具支持还不够完美，比如还没有 time-travel 功能\n\n\n模块热更新\n\n无需重新加载页面就可以修改模块\n热更新的时候会保持任何现有状态\n\n\n支持使用插件扩展 Pinia 功能\n支持服务端渲染\n\nPinia 和 Vuex上面的也算 ~\n核心区别\nVuex： State、Gettes、Mutations(同步)、Actions(异步)\nPinia： State、Gettes、Actions(同步异步都支持)\n版本支持\nVuex 当前最新版是 4.x\n\nVuex4 用于 Vue3\nVuex3 用于 Vue2\n\nPinia 当前最新版是 2.x\n\n即支持 Vue2 也支持 Vue3\n\n使用场景个人感觉：，由于Pinea是轻量级的，体积很小，它适合于中小型应用。它也适用于低复杂度的Vue.js项目，因为一些调试功能，如时间旅行和编辑仍然不被支持。将 Vuex 用于中小型 Vue.js 项目是过度的，因为它重量级的，对性能降低有很大影响。因此，Vuex 适用于大规模、高复杂度的 Vue.js 项目\npinia使用准备工作想要学习pinia，最好有Vue3的基础，明白组合式API是什么。如果你还不会Vue3，建议先去学习Vue3。\n本篇全部基于Vue3来讲解pinia，至于Vue2中如何使用pinia，大家可以自行去pinia官网学习，毕竟Vue2中使用pinia的还是少数。\n项目搭建我们这里搭建一个最新的Vue3 + TS + Vite项目。\n执行命令：vue create vue-pinia 选择babel、vue3、ts，创建完毕，清空项目，启动项目 ~\n安装pinia执行命令：npm install pinia\n使用pinia安装完成后我们需要将pinia挂载到Vue应用中，也就是我们需要创建一个根存储传递给应用程序，简单来说就是创建一个存储数据的数据桶，放到应用程序中去。\n修改main.js，引入pinia提供的createPinia方法，创建根存储。\n// main.tsimport &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &#123; createPinia &#125; from &quot;pinia&quot;;const pinia = createPinia();const app = createApp(App);app.use(pinia);app.mount(&quot;#app&quot;);\n\n在 store 目录下创建一个 user.ts 为例，我们先定义并导出一个名为 user 的模块\nimport &#123; defineStore &#125; from &#x27;pinia&#x27;export const userStore = defineStore(&#x27;user&#x27;, &#123;    state: () =&gt; &#123;        return &#123;             count: 1,            arr: []        &#125;    &#125;,    getters: &#123; ... &#125;,    actions: &#123; ... &#125;&#125;)\n\ndefineStore 接收两个参数\n第一个参数就是模块的名称，必须是唯一的，多个模块不能重名，Pinia 会把所有的模块都挂载到根容器上第二个参数是一个对象，里面的选项和 Vuex 差不多\n\n其中 state 用来存储全局状态，它必须是箭头函数，为了在服务端渲染的时候避免交叉请求导致的数据状态污染所以只能是函数，而必须用箭头函数则为了更好的 TS 类型推导\ngetters 就是用来封装计算属性，它有缓存的功能\nactions 就是用来封装业务逻辑，修改 state\n\n访问 state比如我们要在页面中访问 state 里的属性 count\n由于 defineStore 会返回一个函数，所以要先调用拿到数据对象，然后就可以在模板中直接使用了\n&lt;template&gt;    &lt;div&gt;&#123;&#123; user_store.count &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; userStore &#125; from &#x27;../store&#x27;const user_store = userStore()// 解构// const &#123; count &#125; = userStore()&lt;/script&gt;\n\n比如像注释中的解构出来使用，是完全没有问题的，只是注意了，这样拿到的数据不是响应式的，如果要解构还保持响应式就要用到一个方法 storeToRefs()，示例如下\n&lt;template&gt;    &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;import &#123; userStore &#125; from &#x27;../store&#x27;const &#123; count &#125; = storeToRefs(userStore)&lt;/script&gt;\n\n原因就是 Pinia 其实是把 state 数据都做了 reactive 处理，和 Vue3 的 reactive 同理，解构出来的也不是响应式，所以需要再做 ref 响应式代理\ngetters这个和 Vuex 的 getters 一样，也有缓存功能。如下在页面中多次使用，第一次会调用 getters，数据没有改变的情况下之后会读取缓存\n&lt;template&gt;    &lt;div&gt;&#123;&#123; myCount &#125;&#125;&lt;/div&gt;    &lt;div&gt;&#123;&#123; myCount &#125;&#125;&lt;/div&gt;    &lt;div&gt;&#123;&#123; myCount &#125;&#125;&lt;/div&gt;&lt;/template&gt;\n\n注意两种方法的区别，写在注释里了\ngetters: &#123;    // 方法一，接收一个可选参数 state    myCount(state)&#123;        console.log(&#x27;调用了&#x27;) // 页面中使用了三次，这里只会执行一次，然后缓存起来了        return state.count + 1    &#125;,    // 方法二，不传参数，使用 this    // 但是必须指定函数返回值的类型，否则类型推导不出来    myCount(): number&#123;        return this.count + 1    &#125;&#125;\n\nactions更新 state 里的数据有四种方法，我们先看三种简单的更新，说明都写在注释里了\n&lt;template&gt;    &lt;div&gt;&#123;&#123; user_store.count &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;handleClick&quot;&gt;按钮&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; userStore &#125; from &#x27;../store&#x27;const user_store = userStore()const handleClick = () =&gt; &#123;    // 方法一    user_store.count++        // 方法二，需要修改多个数据，建议用 $patch 批量更新，传入一个对象    user_store.$patch(&#123;        count: user_store.count1++,        // arr: user_store.arr.push(1) // 错误        arr: [ ...user_store.arr, 1 ] // 可以，但是还得把整个数组都拿出来解构，就没必要    &#125;)        // 使用 $patch 性能更优，因为多个数据更新只会更新一次视图        // 方法三，还是$patch，传入函数，第一个参数就是 state    user_store.$patch( state =&gt; &#123;        state.count++        state.arr.push(1)    &#125;)&#125;&lt;/script&gt;\n\n第四种方法就是当逻辑比较多或者请求的时候，我们就可以封装到示例中 store&#x2F;user.ts 里的 actions 里\n可以传参数，也可以通过 this.xx 可以直接获取到 state 里的数据，需要注意的是不能用箭头函数定义 actions，不然就会绑定外部的 this 了\nactions: &#123;    changeState(num: number)&#123; // 不能用箭头函数        this.count += num    &#125;&#125;\n\n调用\nconst handleClick = () =&gt; &#123;    user_store.changeState(1)&#125;\n\n支持 VueDevtools打开开发者工具的 Vue Devtools 就会发现 Pinia，而且可以手动修改数据调试，非常方便\n模拟调用接口示例：\n我们先定义示例接口 api&#x2F;user.ts\n// 接口数据类型export interface userListType&#123;    id: number    name: string    age: number&#125;// 模拟请求接口返回的数据const userList = [    &#123; id: 1, name: &#x27;张三&#x27;, age: 18 &#125;,    &#123; id: 2, name: &#x27;李四&#x27;, age: 19 &#125;,]// 封装模拟异步效果的定时器async function wait(delay: number)&#123;    return new Promise((resolve) =&gt; setTimeout(resolve, delay))&#125;// 接口export const getUserList = async () =&gt; &#123;    await wait(100) // 延迟100毫秒返回    return userList&#125;\n\n然后在 store&#x2F;user.ts 里的 actions 封装调用接口\nimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; getUserList, userListType &#125; from &#x27;../api/user&#x27;export const userStore = defineStore(&#x27;user&#x27;, &#123;    state: () =&gt; &#123;        return &#123;            // 用户列表            list: [] as userListType // 类型转换成 userListType        &#125;    &#125;,    actions: &#123;         async loadUserList()&#123;            const list = await getUserList()            this.list = list        &#125;    &#125;&#125;)\n\n页面中调用 actions 发起请求\n&lt;template&gt;    &lt;ul&gt;        &lt;li v-for=&quot;item in user_store.list&quot;&gt; ... &lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; userStore &#125; from &#x27;../store&#x27;const user_store = userStore()user_store.loadUserList() // 加载所有数据&lt;/script&gt;\n\n跨模块修改数据在一个模块的 actions 里需要修改另一个模块的 state 数据\n示例：比如在 chat 模块里修改 user 模块里某个用户的名称\n// chat.tsimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; userStore &#125; from &#x27;./user&#x27;export const chatStore = defineStore(&#x27;chat&#x27;, &#123;    actions: &#123;         someMethod(userItem)&#123;            userItem.name = &#x27;新的名字&#x27;            const user_store = userStore()            user_store.updateUserName(userItem)        &#125;    &#125;&#125;)\n\nuser 模块里\n// user.tsimport &#123; defineStore &#125; from &#x27;pinia&#x27;export const userStore = defineStore(&#x27;user&#x27;, &#123;    state: () =&gt; &#123;        return &#123;            list: []        &#125;    &#125;,    actions: &#123;         updateUserName(userItem)&#123;            const user = this.list.find(item =&gt; item.id === userItem.id)            if(user)&#123;                user.name = userItem.name            &#125;        &#125;    &#125;&#125;)\n\n————————————— The End —————————————\n","categories":["vue"]},{"title":"VUe","url":"/2021/07/20/vue/","content":"\n\n\"># VUE.js框架是什么？为什么要学它- vue作为国人开发的一款前端框架，不仅有强大的社区支持，很多API都是中文的，学习难度相对较小- 接收用户输入的同时，很可能要及时更新视图，比如用户输入不同的内容，页面就会相对应进行更新，点击不同的选项，显示不同的状态等交互效果。（用vue更便捷）## 视图层视图数据混在一起冗繁复杂，把html中的dom与其他部分独立开来划分出一个层次，这个层次就叫做视图层，vue的核心库只关注视图层## BTW——API- 例：电脑需要调用手机里的信息，用数据线进行连接，电脑和手机连接数据线的接口就是API### API与上述例子类似又不尽相同- 定义：应用程序接口，是一些预先定义的接口（如函数，http接口），或软件系统不同组成部分衔接的约定）- 应用场景：    - 接口：前后端交互    - 提供应用程序与开发人员基于某软件或硬件得以访问的一组历程，而又无需访问源码    例：程序员B想调用A中的部分功能又不想从头看一遍A的源码和功能实现过程，这时候把A需要的功能打包好，写成一个函数！！！按照B说的流程把函数放在B中就可以直接使用功能了# vue是什么？- 定义：以数据驱动视图的MVVM渐进式框架    - 数据：对象    - 视图：dom标签 --&gt; 虚拟dom    - MVVM：M model模型，V view视图。就是一种框架架构，model-view view-model， 这样的结构，主要优势在于监控者数据双向绑定的特性，vue和model之间是双向数据传递的。视图改变数据就可以改变，数据改变视图就可以改变。    - 渐进式：轻量级框架，可以选择性的，只使用vue中很少的一部分，而不是必须使用全部## BTW——MVC和MVVM- MVVM有两个方向：    1. 将model（模型）转化成 view（视图），即后端传递的数据转化成所看到的页面。实现方式为数据绑定    2. 将view（视图）转化成 model（模型），即将所看的页面转化成后端的数据。实现方式为dom监听事件- 什么是mvc?    - MVC是model-view-controller的缩写，即模型——视图——控制器。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。- 区别：    - MVC和MVVM的区别并不是VM完全取代了C，只是在MVC的基础上增加了一层VM，只不过是弱化了C的概念，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。    - View更新的时候，必须要通过Controller去更新一遍Model；同样的Model更新的时候，也要去更新一遍视图。[!MVVM优点]:实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。## vue.js核心？- 官方定义：通过尽可能简单的API实现响应的数据绑定和组合的视图组件## 数据驱动- 传统js手动改变DOM来改变视图，vue.js只需要改变数据就会自动改变视图，就是MVVM思想的实现## 视图组件化- 定义：把网页拆分一个个区块，每个区块我们可以看成一个组件。网页由多个组件拼接或嵌套组成## vue的特点- 响应式编程：编写代码基于对变化的反应- 组件化### 组件和模块- 组件：把重复代码提取出来合并成为一个组件，组件最重要的是复用，位于框架最底层，其他功能依赖于组件，可供不同功能使用，独立性强- 模块：分属同一功能/业务的代码进行隔离（分装）成独立的模块，可以独立运行，以页面、功能或其他不同粒度划分程度不同的模块。位于业务框架层，模块间通过接口调用，目的是降低模块间的耦合，由之前的主应用与模块耦合，变为主应用与接口耦合，接口与模块耦合[比喻]模块就像有多个USB插口的充电宝，可以和多部手机充电，接口可以随意插拔。复用性很强，可以独立管理。- 组件化模块化区别？    - 1. 组件相当于库，把一些能在项目里或者不同类型项目中可复用的代码进行封装    - 2. 而模块相当于业务逻辑模块，把同一类型项目里的功能逻辑进行需求性的封装- 为什么要用组件和模块    - 开发和调式效率高    - 可维护性强    - 避免阻断    - 版本管理更容易## vue的优缺点？- 优点：轻量级框架，数据双向绑定，组件化，虚拟dom，运行速度快- 缺点：    - 不支持ie678    - 生态环境差不如angular和react    - 社区不大    - 无高阶书籍    - 首屏加载速度满，加载时，将所有的css,js文件进行加载### BTW——首屏加载慢解决方式- 减少入口文件体积- UI框架按需引入- 静态资源本地缓存- 图片资源压缩- 组件重复打包- 使用SSR（通过对文件、目录、进程、注册表和服务的强制访问控制，有效的制约和分散了原有系统管理员的权限）### BTW——粒度和耦合- 粒度：计算机中常指系统内存扩展增量的最小值。粒度问题是设计数据仓库的一个最重要方面。粒度是指数据仓库的数据单位中保存数据的细化或综合程度的级别。细化程度越高，粒度级就越小；相反，细化程度越低，粒度级就越大。数据的粒度一直是一个设计问题。- 耦合：两个东西通过某种作用连接在了一起# vue核心的底层原理- Object.defineProperty数据劫持的API- Object.defineProperty定义新属性或修改原有的属性，vue的数据双向绑定原理就是Object.defineProperty，里面定义了setter和getter方法，通过观察者模式(发布订阅模式)来监听数据变化，从而做相应的逻辑处理- 监听对象属性变化，只关心数据不关心视图- 三个参数- 三个参数Object.defineProperty(object,propName,descriptor)    - object 对象=&gt;给谁加    - propName 属性名=&gt;需要加的属性的名字[类型:String]    - descriptor 属性描述=&gt;加的这个属性有什么特性[类型：Object]    - 方法就是直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象- 属性描述符    - configurable: true 配置可删除，默认false        - 两个作用：            1. 目标属性是否可以使用delete删除            2. 目标属性是否可以再次设置特性    - writable：true 配置可修改，默认false    - enumerable:true 可枚举，使用(for...in或Object,keys())默认false    - value属性对应的值，可以是任意类型的值，默认undefined    - 缺点：数组的长度### 语法```js    // writable应用        let Person = &#123;&#125;        Object.defineProperty(Person,&#x27;name&#x27;,&#123;value:&#x27;Jack&#x27;,            // writable:true // 加上这个就可以输出&#123;name:&#x27;Rose&#x27;&#125;        &#125;)        console.log(Person) // &#123;name:&#x27;Jack&#x27;&#125;        Person.name = &#x27;Rose&#x27;        console.log(Person) //undefined,因为writable默认false    // enumerable应用        var user=&#123;name:&#x27;小五&#x27;,age:&#x27;24&#x27;&#125;;        // es6            var keys = Object.keys(user)            console.log(keys) // [&#x27;name&#x27;,&#x27;age&#x27;]        // es5            var Key = []            for(key in user) &#123;                Key.push(Key)            &#125;            console.log(Key) // [&#x27;name&#x27;,&#x27;age&#x27;]    // configurable应用        var human=&#123;name:&#x27;李白&#x27;,age:&#x27;不详&#x27;&#125;；        // 定义一个性别，不可被删除和重新定义特性            Object.defineProperty(human,&#x27;gender&#x27;,&#123;                value:&#x27;男&#x27;,                enumerable:true,                configurable:false            &#125;)        // 删除一下            delete human.gender            console.log(human)//&#123;name:&quot;李白&quot;,age:&quot;不详&quot;,gender:&quot;男&quot;&#125; 并没有删除        // 重新定义特性            Object.defineProperty(human,&#x27;gender&#x27;,&#123;                value:&#x27;男&#x27;,                enumerable:true,                configurable:true            &#125;)            delete human.gender;            console.log(human) // &#123;name:&quot;李白&quot;,age:&quot;不详&quot;&#125;\n\n存取描述符  get  一个给属性提供 getter 的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。getter就是获取属性值  set  一个给属性提供 setter 的方法，如果没有setter则为undefined。该方法将接收唯一参数，并将该参数的新值分配给属性。默认为undefined。setter就是设置属性值\n\n[!注意]：1. 当使用getter或setter方法，不允许使用writable和value这两个属性        2. get或set不是必须成对出现，任写其一就行。如果不设置方法，get和set默认undefined\n语法var username = &#123;name:&quot;不想起名了&quot;&#125;;var num = 12// 定义一个age获取值时返回定义好的变量    Object.defineProperty(username,&#x27;age&#x27;,&#123;        get:function() &#123;            return num        &#125;    &#125;)    console.log(username.age);//12// 定义一个age获取值时返回定义好的变量num    Object.defineProperty(username,&#x27;age&#x27;,&#123;        get:function() &#123;            return num        &#125;        set:function(newVal) &#123;            num = newVal        &#125;    &#125;)    console.log(username.age);// 12    username.age = 145    console.log(username.age); // 145    console.log(num); // 145\n\n兼容性：IE8以下不行\n使用Object.defineProperty的优点\n减少代码（少了dom,不需要写很多dom）\n开发速度快\n\n\n\nBTW——数据劫持\n定义：修改或访问对象的属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果\n\nvue环境搭建\n环境需要:nodejs 检测cmd:node-v\n安装全局脚手架:npm i -g @vue/cli 检测：vue-Vyarn global add @vue/cli\n脚手架网站:cli.vuejs.org\nvue官网: vuejs.org\n\n创建vue项目【注意】:项目名称不能是中文，不能是大写字母，不能用vue做名字\n命令运行方式vue create name\ngui图形化方式vue ui\nvue脚手架\n定义:vue的cli脚手架底层是webpack,也就是基于webpack封装的  [官网]（http://cli.vuejs.org）\n\nBTW——是脚手架？\n什么是脚手架？\n构建基于数据库的应用，进行增、删、改、查数据库的操作\n\n\nVue-CLi是什么？\n是vuejs脚手架工具，就是自动帮你生成好项目目录，配置好webpack，以及各种依赖包工具\n为什么要用？可以帮助你快速开启一个vue项目，给你一套文件结构，包含基础的依赖库，只需要npm install 一下就可以安装，不需要为编译或其他琐碎事而浪费时间，而且不会限制到你发挥\n\n\n\n脚手架配置\nvue.config.js文件是脚手架配置文件，该文件必须放在项目的根目录里\n\n请求代理【跨域方案】脚手架-&gt;webpack-&gt;nodejs【后端】使用后端转发请求【注意】只能在开发环境中使用【使用场景】在公司里和后端的测试接口进行接口调式使用\n语法module.exports=&#123;    devServer:&#123;        // 浏览器自动打开        open:true,        // 代理        proxy:&#123;            &quot;/api&quot;:&#123;                target:&quot;http://xx.com&quot;,                changeOrigin:true,                pathRewrite:&#123;                    &quot;^/api&quot;:&quot;&quot;,                &#125;,            &#125;,        &#125;,    &#125;&#125;\n关闭源码映射【性能优化】\nproductionSourceMap:false  打包的时候，每一个js文件对应生成一个map源码映射文件，它在生产环境中时没有用的。它会增加打包时间，浪费磁盘空间，以及容易造成代码泄漏等问题，因此需要在生产环境中关闭，只允许开发环境中开启\n\n关闭eslint代码校验\nlintOnSave:false\n\nAIA：脚手架配置有哪些？\n代码校验\n代码映射的开启与关闭\n请求代理vue.config.js\n\nvue项目结构运行命令\n项目根目录里有一个package.json文件，该文件有一个script对象，里面就是自定义运行命令。（是这三个里唯一一个可以删的）\nserve开发环境，写代码时的环境\nbuild生产环境，打包发布时的环境\n\n结构\n\nnode_modules它是项目运行时必须依赖\n\n\npublic公共目录，存放着唯一的html模板\nsrc【核心-源码】项目所有代码\n.gitignore过滤掉git仓库里不需要的文件清单\nbabel.config.js把es6转成es5\npackage.lock.json(可以删但一般留着)，锁定依赖版本号\npackage.json【核心】依赖包管理文件\nREADME.md说明书\n\nsrc源码结构\nassets存放静态资源：图片，css,js脚本\ncomponent放组件\nApp.vue根组件，第一个被加载的组件\nmain.js入口文件，第一个被执行的文件\n\n模块化开发【vue核心亮点】把一切重复使用的资源，无论是图片，样式还是js代码抽离出来，作为单独的’模块’进行复用\n\n模块包含：vue 组件，图片，js 脚本，css 样式，字体等都可以是模块。\n\nvue里的模块化组件开发\n\n组件必须使用import引入到当前组件\n\n\n\n当前组件的components必须挂载引入的组件\n\n\n\n在当前组件的template里用标签的形式使用挂载的组件\n\n\n\n插值\n渲染文本\n写在两个大括号中间\n\n插值语法可以写哪些值\n对象、字符串、数字、数组、布尔值、三元表达式、自执行函数等，凡是具有返回值的都可以，全部变成文本渲染出来\n\nBTW——自执行函数和快速删除文件自执行函数后面+（）&#123;function()&#123;return 1000()&#125;&#125;\n为什么用自执行函数而不是函数用函数也可以，只不过返回时function(){return 1000},而不是1000\n插值语法的作用\n四则运算 100+(200*300)&#x2F;2\n插值里存放变量 (详情请找baseVue.html)\n\nnpkill和rimraf快速删除node_modules包\n全局安装npm i -g npkill\n进入想清理的文件夹\ncd文件路径\n输入npkill\n会自动查找文件中node_modules\n光标上下移动来选择要清理的目录，释放宝贵的空间\n按空格删除\n\n内置方法$set添加或修改对象和数组添加&#x2F;修改对象的属性 $set(obj,&#39;name&#39;,1)添加或修改数组成员$set(arr,index,val)\n$delete删除对象和数组\n删除对象属性$delete(obj,name)\n删除数组成员$delete(arr,index)\n\n$emit派发一个动作向上级通信$mount手动挂载方法属性绑定\nprops接收上游绑定的属性\n\n语法\n数组：[&#39;list&#39;]\n对象:props:&#123;    list:&#123;        type:Array,        // 针对数组或对象需要函数        default:() =&gt; [] //default是没有任何值的时候默认的值，保证你需要该属性的时候不是undefined    &#125;&#125;\n父组件要正向地向子组件传递数据或参数，子组件收到后，根据传递过来的数据不同，渲染不同的页面内容，或者执行操作。这个正向传递数据的过程是通过props来实现的。子组件使用props来声明需要从父组件接收的数据[!注意]：\n\n\n不应该在一个子组件内部改变 prop，这样会破坏单向的数据绑定，导致数据流难以理解。如果有这样的需要，可以通过 data 属性接收或使用 computed 属性进行转换。\n\n如果 props 传递的是引用类型(对象或者数组)，在子组件中改变这个对象或数组，父组件的状态会也会做相应的更新，利用这一点就能够实现父子组件数据的“双向绑定”，虽然这样实现能够节省代码，但会牺牲数据流向的简洁性，令人难以理解，最好不要这样去做。\n\nprop只读不可修改\n\n想要实现父子组件的数据“双向绑定”，可以使用 v-model 或 .sync\n\n\n两种常见的试图变更一个prop的情形\n这个prop用来传递一个初始值这个子组件接下来希望将其作为一个本地的prop数据来使用。在这种情况下，最好定义一个本地的data property并将这个prop用作其初始值\n这个prop以一种原始的值传入且需要转换。在这种情况下，最好使用这个prop的值来定义一个计算属性\n\nscss动态生成类名（待写11.26scss动态生成类名.vue）例如：有一p标签，起一个class名为m-l-10     \nv-指令什么是指令？是带有v-前缀的特殊属性，通过属性来操作元素\nv-model\n因为vue是单向数据流，所以v-model在input上只是语法糖而已&lt;!-- 第一行代码是第二行的语法糖 --&gt;&lt;input v-model=&quot;sth&quot;/&gt;&lt;input v-bind:value=&quot;sth&quot; v-on:input=&quot;sth=$event.target.value&quot;/&gt;&lt;!-- 理解上述代码    input本身有个oninput事件，这是h5新增，类似onchange,每当输入框内容发生变化的时候，就会触发oninput，把最新的value传递给sth--&gt;&lt;!-- 所以在给&lt;input/&gt;元素添加v-model属性时，默认会把value作为元素的属性，然后把&#x27;input&#x27;事件作为实时传递value的触发事件 --&gt;\n用在组件上 给组件加v-model，默认会把value作为组件的属性，然后把’input’值作为给组件绑定事件的事件名\n\n语法 &lt;Cur-input v-model=&quot;price&quot;&gt;&lt;/Cur-input&gt;  &lt;input ref=&quot;input&quot; :value=&quot;value&quot; @input=&quot;$emit(&#x27;input&#x27;)$event.target.value&quot;&gt;export default &#123;    data:&#123;price:100&#125;,    props:[&#x27;value&#x27;]&lt;!-- 这里为什么用value？--&gt;&#125;【问题解答】：&lt;Cur-input :value=&quot;price&quot; @input=&quot;price=arguments[0]&quot;&gt;&lt;/Cur-input&gt;\nv-model缺点及解决办法\n在创建类似复选框或单选框这种常见的组件时，v-model就不好用了。因为不需要value属性而是checked属性，并且当你点击这个单选框的时候不会触发oninput事件，它只会触发onchange事件。[解决办法]:&lt;!-- input上 --&gt;    &lt;input type=&quot;checkbox&quot; :checked=&quot;status&quot; @change=&quot;status=$event.target.checked&quot;/&gt;&lt;!-- 组件上 --&gt;    &lt;input type=&quot;checkbox&quot; @change=&quot;$emit(&#x27;suibian&#x27;,$event.target.checked)&quot;    :checked=&quot;value&quot;    /&gt;    props:[&#x27;checked&#x27;][!注意]v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。应通过 JavaScript 在组件的 data 选项中声明初始值。\n\n表单的使用——专用指令:v-modelv-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：\n\ntext 和 textarea 元素使用 value 属性和 input 事件；（默认）\nradio单选框\ncheckbox 和 radio 使用 checked 属性和 change 事件；(单个复选框，绑定到布尔值，多个复选框，绑定到同一个数组：)\n语法：&lt;input type=&#39;radio&#39; v-model=&#39;radio&#39; value=&#39;1&#39;/&gt;\n\n\nselect下拉菜单\nselect 字段将 value 作为 prop 并将 change 作为事件。\n语法&lt;select v-model=&#x27;selected&#x27;&gt;    &lt;option value=&#x27;1000&#x27;&gt;北京&lt;/option&gt;&lt;/select&gt;\n\n\n\nBTW——语法糖 onchange @input\n语法糖：用更简练的言语表达较复杂的含义\nonchange事件\n定义：事件会在域的内容改变时发生\n可用于单选框与复选框改变后触发的事件\n语法:input type&#x3D;”text” onchange&#x3D;”myFunction()\n\n\n@input一般用于监听事件，只要输入的值变化了就会触发input，而@click是事件触发事件\n\nv-show\n控制元素显示与隐藏，但是元素的dom节点一直存在页面中的，他的底层原理是控制css的display属性\n当频繁切换元素显示隐藏的时候，优先使用v-show&lt;template&gt;    &lt;!-- 条件渲染v-show    控制css display样式，dom节点是存在于页面中的 --&gt;    &lt;div&gt;        &lt;p @click=&quot;flag()&quot;&gt;&lt;/p&gt;        &lt;h1 v-show=&quot;see&quot;&gt;我可以被显示吗&lt;/h1&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        data:&#123;            return &#123;                see:false                &#125;            &#125;,        methods:&#123;            flag() &#123;                this.see =! this.see            &#125;        &#125;    &#125;&lt;/script&gt;\n\nv-if\n它是控制元素的加载(渲染)和销毁，底层是删除或者加载出dom\n它还有v-else-if和v-else但是后面两个不能单独使用\n它是条件控制语句，它只要有一个符合条件，则后面的v-else-if和v-else就不执行判断\n适合用于多条件判断渲染&lt;template&gt;    &lt;div&gt;        &lt;!-- 多条件切换的时候使用 v-if --&gt;        &lt;button v-on:click=&quot;index=1&quot;&gt;首页&lt;/button&gt;        &lt;button v-on:click=&quot;index=2&quot;&gt;新闻&lt;/button&gt;        &lt;button v-on:click=&quot;index=3&quot;&gt;关于&lt;/button&gt;        &lt;!-- 面板 --&gt;        &lt;h1 v-if=&quot;index==1&quot;&gt;我是首页&lt;/h1&gt;        &lt;h1 v-else-if=&quot;index==2&quot;&gt;我是新闻&lt;/h1&gt;        &lt;h1 v-else&gt;我是关于&lt;/h1&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        data()&#123;            return&#123;                //1.首页 2.新闻 3.关于                index:1,            &#125;;        &#125;,    &#125;&lt;/script&gt;\n\nv-bind\n定义：绑定属性的，可以绑定原生属性和自定义属性\n缩写:\n修饰符\nprop把标签上的属性隐藏\nsync把数据变成为双向绑定(与v-model类似，v-model只能用于对象否则会警告，这个可以解决基本数据类型不是双向绑定问题)\n\n\n\n &lt;p v-bind:title=&quot;doc.title&quot; v-on:update:title=&quot;doc.title=$event&quot;&gt;&lt;/p&gt;&lt;!-- 上述代码用.sync可以写为 --&gt;&lt;p v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/p&gt;&lt;!-- 在子组件中，可以通过下面代码实现对prop重新赋值 --&gt;this.$emit(&#x27;update:title&#x27;,newTitle)\n[AIA]\n\n父组件使用 sync 修饰绑定的属性  v-bind:prop.sync=data\n子组件使用固定语法  $emit(&#39;update:prop&#39;,value)\n\nBTW——$emit $mount\n$emit  派发一个动作向上级通信\n\n$mount 手动挂载方法\n\n语法\n\n绑定样式  &lt;div :class=&quot;&#123;&#123;name:true|false&#125;&#125;&quot;&gt;&lt;/div&gt;\n绑定自定义  &lt;Son :data=&quot;data&quot;&gt;&lt;/Son&gt;\n\n\n样例\n&lt;template&gt;    &lt;div&gt;        &lt;!-- v-bind:绑定属性的指令 --&gt;        &lt;img v-bind:src=&quot;logo&quot; kkk=&quot;hahah&quot;/&gt;        &lt;!--             img标签?dom元素=dom对象            src 对于img原始的属性            kkk 对于img，自定义属性            v-bind:既可以绑定原始和自定义属性             --&gt;        &lt;!-- 绑定背景图 --&gt;        &lt;div style=&quot;height:500px;border:1px solid red&quot; v-bind:style=&quot;&#123;background:`url($&#123;logo&#125;)`&#125;&quot;&gt;        &lt;/div&gt;        &lt;!-- 绑定class类名        v-on:click=&#x27;回调函数/表达式&#x27; --&gt;        &lt;button v-bind:class=&#x27;&#123;active:n&#125;&#x27; v-on:click=&#x27;n=n ? false :1&#x27;&gt;点我&lt;/button&gt;            &lt;!-- 用对象包着是因为，对象里可以绑定很多class名 --&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//引入图片import src from &#x27;../../assets/logo.png&#x27;// console.log(src)//若引入很多张图片 脚手架-&gt;基于webpack-&gt;基于nodejs 所以可以使用nodejs里的requirevar img= require(&#x27;../../assets/logo.png&#x27;);// 直接在export中输出require(&#x27;../../assets/logo.png&#x27;)不用写这个export default &#123;    data() &#123;        // 任何文件都是模块        return &#123;            n:false,//true是绑定，false是不要            // logo:&#x27;../../assets/logo.pn&#x27;,这个卸载这里出不来放到import中，这里logosrc            logo:src,// 对应import            logo:require(&#x27;../../assets/logo.pn&#x27;)        &#125;    &#125;&#125;&lt;/script&gt;&lt;style&gt;    /* 高亮颜色 */    .active&#123;        background:red;        color:white;    &#125;&lt;/style&gt;\n\nv-on\n定义：事件绑定指令，可以绑定原生事件和自定义事件\n缩写：@\n语法：v-on:click=&#39;callBack&#39;\n修饰符：\n.stop 清除事件冒泡\n.prevent 阻止默认行为\n.once 绑定一次函数\n.native 绑定原始事件\n.passive 告诉浏览器不想阻止默认行为\n\n\nevent事件对象\ntarget 事件触发的元素\ncurrentTarget 事件绑定的元素\n\n\n\n自定义事件\n由程序决定触发时机的自定义事件\n语法:绑定：@myEvent=&#39;callBack&#39;调用：$emit(&#39;callBack&#39;,参数)\n应用场景：父子组件通信的时候\n\nv-text\n底层是innerText\n定义：渲染文本内容，无论写入什么值，最后都被渲染成文本内容\n和插值&#123;&#123;&#125;&#125;基本一致\n为什么有v-text还要有插值语法？v-text覆盖内容，插值语法就是个占位符，用插值偏多\n\nv-html\n定义：用于渲染dom片段的\n底层：innerHTML二者区别：v-html可以转义标签和渲染数据，v-text不能转义标签只能渲染数据  v-html 你好  v-text $lth2$gt你好$lt&#x2F;h2$gt\n\nv-for循环渲染\n基础语法:v-for=&#39;val in data&#39; key=&#39;val&#39;\n获取下标:v-for=&#39;(val,index) in data&#39; :key=&#39;index&#39;\n遍历对象：v-for=(val,key,index) in obj\n[!注意]key一定不可以是随机数，时间戳，因为值不固定，随时发生改变，key的值必须唯一。随机数时间戳不固定，刷新一次改变一次\ndata:对象，数组，数字，字符串\nkey&#x3D;’值必须唯一’当前元素的身份，标识，用来优化diff算法进行dom修改\n虚拟dom和diff算法\n虚拟dom是js动态生成的，是js根据算法得出的\ndiff算法，执行规则：同层对比，新旧dom对比，当发现有不同之处，直接用新的dom替换旧的dom部分，diff算法超级快\n\n\n\nv-slot(详情搜索插槽)\n绑定插槽的指令\n作用域插槽、具名插槽和默认插槽\n缩写：#\n\nv-once永远只显示第一次渲染的值，让数据失去双向响应。它会让被绑定的元素不再进入diff对比，不更新。从而节省了虚拟dom的计算\nv-pre原格式输出内容，不会让元素内的内容解析\nv-clock防止插值语法的闪烁问题，插值里的数据如果默认是空的，需要等接口返回才显示的话，页面内容的高随着内容撑开导致页面抖动\n&lt;div&gt;    &lt;p v-clock&gt;&#123;message&#125;&lt;/p&gt;&lt;/div&gt;&lt;style&gt;    [v-clock] &#123;display:none;&#125;&lt;/style&gt;\n\n生命周期定义\n广义：事物发展的阶段\n具体例子：人的生老病死\n页面加载的过程：初始化，渲染，更新，销毁\n官方定义：钩子函数(生命周期就等于钩子函数)\n\n页面加载的过程：初始化，渲染，更新，销毁诞生：入口函数，当页面完全加载出来，才执行\n    window.onload\n去世：当页面被关闭的时候执行，卸载\n    window.onunload\n更新：重新加载，页面要发生变化\n    window.onreload\n\n生命周期作用是什么？Vue 所有的功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。\nvue生命周期创建阶段预加载资源，骨架屏，上传日志等操作\n创建前 beforeCreate\nvue对象创建之前触发的函数\n此阶段为实例化初始后，this指向创建的实例，数据观察，数据监听事件机制都未形成，不能获dom节点。data，computed，watch，methods上的方法和数据都不能访问\n因为data和methods数据都还未初始化\n\n创建后 created\nvue对象创建完成触发的函数\n实例初始化之后，data，props，computed导入完成\n要调用methods方法，或者操作data的数据最早只能在created中操作\n可以访问watch、methods、computed、data上的数据和方法\n\n挂载阶段\n挂载前 beforeMount\nvue对象开始挂载数据的时候触发的函数\n这个阶段是过渡性的，一般一个项目只能用到一两次。\n\n挂载后 mounted\nvue对象挂载完成的时候触发的函数\n完成创建vm.$el，和双向绑定只要执行完mounted,就表示整个Vue实例已经初始化完成了，此时组件已经脱离里了创建阶段， 进入到了运行阶段。\n这个时候dom在页面呈现了，你可以获取dom，一般用于ajax自动发起请求数据\n\n更新阶段更新前还可以对数据进行二次修改，更新后只能是观察数据变化。当data或者props更新或者上游组件更新的时候触发\n更新前 beforeUpdate\nvue对象中的data数据发生改变之前触发的函数\n当执行beforeUpdate的时候，页面中显示的数据还是旧的，此时date数据是最新的，页面尚未和最新数据数据保持同步。但是DOM中的数据会改变，这是vue双向数据绑定的作用，可在更新前访问现有的DOM，如手动移出添加的事件监听器。\n\n更新后 updated\nvue对象中的data数据发生改变完成触发的函数\nUpdated执行时数据已经保持同步了，都是最新的，完成虚拟DOM的重新渲染和打补丁。\n组件DOM已完成更新，可执行依赖的DOM操作。\n不要在此函数中操作数据（修改属性），否则就会陷入死循环。\n\n销毁阶段主要用于销毁常驻内存的垃圾，比如定时器，或者全局变量\n销毁前 beforeDestroy\nvue对象销毁之前触发的函数\n该组件还存在\n当执行beforeDestroy的时候，Vue实例就已经从运行阶段进入到销毁阶段了。实例上的所有date和methods以及过滤器和指令都是处于可用状态，此时还没有真正的执行销毁过程。\n\n销毁后 destroyed\nvue对象销毁完成触发的函数\n指令解绑和事件解绑以及子组件销毁完毕\n\nerrorCaptured捕获后代组件错误\n当组件发生错误时，会被该函数捕获\n该函数有三个参数，第一个错误本身信息，第二个是发生错误的组件实例对象，第三个是发生错误的触发信息\n该函数如果写return false则阻止错误继续向上传递\n\n插槽\n什么是插槽？vue为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽\n更高级的组件复用方式。接收dom片段或内容，加工处理后返回显示\n\nVue插槽的作用vue插槽是vue中常见的一种组件间的相互通信方式，作用是子组件中某个位置插入父组件的自定义html结构和data数据，在要接收数据的组件页面通过标签来表示。简单来说，就是通过此标签来起到占位的作用，而要插入的内容也会对应到标签所在的位置三种插槽的定义默认插槽（匿名插槽）\n定义：默认插槽是将父组件的结构和数据插入子组件中，默认插槽只有一个插入位置，要插入的html结构和data数据必须在父组件中，不过css可以在子组件中\n特点： 父组件决定结构和数据\n\n// 父组件    &lt;template&gt;        &lt;Child&gt;             &#123;/* Child为子组件标签             插槽内容，可以是template标签也可以是其他标签,比如&lt;img src=&quot;图片地址&quot; /&gt;  */&#125;            &lt;template&gt;要插入的html内容&lt;/template&gt;        &lt;/Child&gt;    &lt;/template&gt;// 子组件    &lt;template&gt;        &lt;div&gt;            &#123;/* 插槽位置            插槽通俗的说就是：挖个坑，等组件的使用者进行填充 */&#125;            &lt;slot&gt;这里可以写默认值，当使用者没有传递具体结构时，会显示此内容&lt;/slot&gt;        &lt;/div&gt;    &lt;/template&gt;\n\n具名插槽\n定义：简单地说就是具有名字的插槽，只是默认插槽只有一个插入位置，具名插槽可以有多个插入位置，根据名字来识别对应的插槽\n特点： 父组件决定结构和数据\n\n// 父组件&lt;template&gt;    &lt;Child&gt;         &#123;/* Child为子组件标签        插槽内容 */&#125;       &lt;template v-slot:one&gt;        &lt;testchart&gt;&lt;/testchart&gt;        //这是为了验证，子组件中的插槽可以填充任何结构的内容，所以在one插槽中插入一个组件        &lt;/template&gt;        &lt;template v-slot:two&gt;            我是要给two插槽的信息        &lt;/template&gt;    &lt;/Child&gt;&lt;/template&gt;export default&#123;    components:&#123;        testchart,        child    &#125;&#125;// 子组件&lt;div&gt;    &lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt;    &lt;slot name=&quot;two&quot;&gt;&lt;/slot&gt;&lt;/div&gt;\n\n作用域插槽\n定义：作用域插槽的data数据固定写在子组件中，数据的html结构根据父组件传入的html结构来决定\n简述： 根据父组件中不同的html结构解析data中的数据\n特点： 子组件决定数据，父组件决定结构\n父组件中的插槽模版template里，其作用域属于插槽组件&lt;slot :自定义name&#x3D;data中的属性或者对象&gt;\n\n  // 父组件  &lt;template&gt;      &lt;Child&gt;            &#123;/* Child为子组件标签           插槽内容，作用域插槽必须要写template   */&#125;          &lt;template slot=&quot;header&quot;&gt;              &lt;span v-for=&quot;m in data.msg&quot; :key=&quot;m&quot;&gt;&lt;/span&gt;          &lt;/template&gt;          &lt;template slot=&quot;center&quot;&gt;              &lt;div v-for=&quot;m in data.msg&quot; :key=&quot;m&quot;&gt;&lt;/div&gt;          &lt;/template&gt;          &lt;template slot=&quot;footer&quot;&gt;              &lt;label v-for=&quot;m in data.msg&quot; :key=&quot;m&quot;&gt;&lt;/label&gt;          &lt;/template&gt;      &lt;/Child&gt;  &lt;/template&gt;  // 子组件  &lt;template&gt;   &lt;div&gt;&#123;/* 插槽位置 插槽的结构是由使用者决定的 */&#125;&lt;slot :msg=&quot;msg&quot;&gt;插槽未被调用时会显示此内容&lt;/slot&gt;   &lt;/div&gt;  &lt;/template&gt;  &lt;script&gt;      export default &#123;          name: &#x27;Child&#x27;,          // 公用数据          data() &#123;              return &#123;                  msg: [&quot;火锅&quot;, &quot;红烧肉&quot;, &quot;烤羊腿&quot;]              &#125;          &#125;      &#125;  &lt;/script&gt;\n\n父传子：父组件使用v-bind 向插槽组件传参\n子传父：插槽组件在slot组件上使用v-bind 反向传参父组件使用v-slot=&#39;参数&#39; 接收数据[AIA]一句话概括就是v-slot:后边是插槽名称，&#x3D;后边是组件内部绑定作用域值的映射\n\nvue组件\n凡是以.vue做文件后缀的都是组件\n\n局部组件\n作用域只限于当前使用该组件的环境中生效\n\n语法// App.vueimport Com from &quot;./Com.vue&quot;components:&#123;    Com&#125;&lt;Com&gt;&lt;/Com&gt;\n\n全局组件\n该组件生效环境为整个项目，任何组件内使用都可以直接使用该组件，且不用单独导入\n\n语法 // main.jsimport MySon from &quot;./MySon.vue&quot;;Vue.component(&quot;my-son&quot;,MySon);// 每次只能挂载一个\n\n全局组件局部组件对比\n全局组件在使用上比局部组件更简单，更快，更省代码\n全局组件可能会污染全局环境，比如命名重复，被替换覆盖等问题，并且造成代码冗余，后期维护不方便\n所以要合理的使用全局组件，当一个组件被重复使用3次及以上则考虑全局组件\n\n组件通信\n定义：两个组件及以上进行数据交互，叫做组件通信\n分为两类\n\n\n父子之间通信\n非父子之间的通信\n\n父传子\n父组件使用 v-bind 给子组件绑定属性\n子组件使用 $emit接收父组件给的属性\n\n子传父\n父组件使用 v-on 给子组件绑定自定义事件函数\n子组件使用 $emit调用父组件传递的函数\n\n&lt;!-- 父组件 --&gt;    &lt;template&gt;        &lt;child :msg=&quot;articleList&quot; @changeMsg=&quot;changeMsg&quot;&gt;&lt;/child&gt;    &lt;/template&gt;    &lt;script&gt;        import child from &#x27;./child.vue&#x27;        export default &#123;            data() &#123;                return &#123;                    msg:&#x27;巧克力&#x27;                &#125;            &#125;,            methods:&#123;                changeMsg() &#123;                    this.msg = msg                &#125;            &#125;        &#125;    &lt;/script&gt;\n\n&lt;!-- 子组件 --&gt;    &lt;template&gt;        &lt;div&gt;            &lt;!-- 这里两个大括号中间放msg --&gt;            &lt;button @click=&quot;change&quot;&gt;改变字符串&lt;/button&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default &#123;            props:&#123;                msg:&#x27;&#x27;            &#125;,            methods:&#123;                change() &#123;                    this.$emit(&#x27;changeMsg&#x27;,&#x27;蛋挞&#x27;)                &#125;            &#125;        &#125;    &lt;/script&gt;\n兄弟\n使用父组件作为媒介，父组件充当中转站\n\n$parent和$children(不可控不推荐)\n通过$parent和$children可以访问组件实例，拿到实例代表什么？代表可以访问此组件的所有方法和data\nparent 获取直接父组件实例对象\nchildren 获取所有渲染的(必须要渲染在template里才能获取到)子组件集合\n\n&lt;!-- 父组件 --&gt;    &lt;template&gt;        &lt;div&gt;            &lt;!-- 这里两个大括号中间放msg --&gt;            &lt;button @click=&quot;changeA&quot;&gt;&lt;/button&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default &#123;            data() &#123;                return &#123;                    msg:&#x27;Welcome&#x27;                &#125;            &#125;,            methods:&#123;                changeA() &#123;                    // 获取到子组件A                    this.$children[0].messageA = &#x27;this is a new value&#x27;                &#125;            &#125;        &#125;    &lt;/script&gt;\n&lt;!-- 子组件 --&gt;    &lt;template&gt;        &lt;div&gt;            &lt;span&gt;两个大括号中间写messageA&lt;/span&gt;            &lt;p&gt;获取父组件的值为:两个大括号中间写parentVal&lt;/p&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default &#123;            data() &#123;                return &#123;                    messageA:&#x27;this is old&#x27;                &#125;            &#125;,            computed:&#123;                parentVal() &#123;                    return this.$parent.msg;                &#125;            &#125;        &#125;    &lt;/script&gt;\n\n[!注意]：注意边界，如果在#app上拿$parent得到的是new Vue()的实例，在这实例上再拿$parent得到的是undefined，而在最底层的子组件拿$children是个空数组。也要注意得到parent和parent和parent和children的值不一样，$children 的值是数组，而$parent是个对象。$children获取到的实例不保证顺序，因此当有多个子组件时可能获取到的不是自己想要的那一个。当组件嵌套多级时，可能会出现$parent.$parent.$parent…的情况，对于后续维护不友好。\n\nprops $emit 、 $parent $children两种方式用于父子组件之间的通信， 而使用props进行父子组件通信更加普遍，二者皆不能用于非父子组件之间的通信。\n\n跨层级$attrs 跨层级传递数据\n通过v-bind&#x3D;”$attrs”传入内部组件——在创建高级别的组件时非常有用\n$attrs可以收集父组件中的所有传过来的属性除了那些在组件中没有通过props定义的。不包括样式class 和 style。【Tip】什么时候用它以及为什么用它？我们如果使用props的话，最里面的组件想要获取最外层组件的数据，就要通过中间的组件的props来传递，但是这个props对于中间的这个组件没啥用处，它就是做了一个桥梁而已。所以就有了这个$attrs来帮助我们，不必在中间组件中写props就可以让最里面的组件拿到最外面组件传进来的数据。\n具体使用\n\n//grandfather    import father from &#x27;./father&#x27;    export default &#123;        components: &#123;            father        &#125;,    data()&#123;        return&#123;            time: new Date().getTime()        &#125;    &#125;&#125;\n&lt;!-- father --&gt;&lt;div style=&quot;background: red&quot;&gt;    child in father    &lt;div&gt;      &lt;span&gt;father age:&lt;/span&gt;      &lt;!-- 两个大括号包着fatherAge --&gt;    &lt;/div&gt;    &lt;child v-bind=&quot;$attrs&quot;&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt;    import child from &#x27;./child&#x27;    export default &#123;    components: &#123;        child    &#125;,    props: &#123;        fatherAge: &#123;            type: Number,            default: 0        &#125;    &#125;    &#125;&lt;/script&gt;\n&lt;!-- child --&gt;&lt;div style=&quot;background: green&quot;&gt;    &lt;div&gt;child&lt;/div&gt;    &lt;div&gt;time:         &lt;!-- 双括号中包着childTime --&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    export default &#123;        props: &#123;            childTime: &#123;            type: String,            default: &#x27;&#x27;            &#125;        &#125;    &#125;&lt;/script&gt;\n\n$listeners跨层级传递事件vue1.0以前，没有vuex，想全局管理共享的数据，需要使用“黑魔法”，单独的new一个vue实例对象，基于该对象做数据通信\n\n通过v-on&#x3D;”$listeners”传入内部组件时非常有用\n它是一个对象，里面包含了作用在这个组件上的所有监听器\n适用场景用.native修饰符可以把”focus”这个原生事件绑定在这个组件上。如果组件的根元素不能使用focus事件时，这个绑定会失效。比如:input 所以为了在input元素上绑定”focus”这个事件，必须在input上用v-on绑定原生事件\n\ninheritAttr默认情况下被父作用域的不被认作props的特性绑定，将会“回退”且作为普通的HTML特性应用在子组件的根元素上\n\n当设置inheritAttrs: true（默认）时，子组件的顶层标签元素中会渲染出父组件传递过来的属性\n不管inheritAttrs为true或者false，子组件中都能通过$attrs属性获取到父组件中传递过来的属性。\n\nbus中央事件总线$on和$event\n$on是事件派发\n$event事件监听\nbus无论是嵌套还是兄弟，他们都可以互相通信  A -&gt; A1  B和A1通信\n\n步骤\n全局定义bus:新建src&#x2F;eventBus.js文件// main.jsimport Vue from &#x27;vue&#x27;export const EventBus= new Vue()\n在组件中引入bus的引用import eventBus from &#x27;./bus/eventBus&#x27;Vue.prototype.$eventBus = eventBus\n通过$emit触发事件传值，在另一个组件中的mounted中用on监听事件从而获取值// 组件1var Event = new Vue()// 准备一个空的实例对象，相当于又new了一个vue实例，Event中含有vue的全部办法Event.$emit(&#x27;msg&#x27;,this.msg);// 发送数据，触发当前实例上的事件，要传递的数据会传递给监听器。第一个参数是发送数据名称，接收时还用这个名字接收，第二个参数是这个数据现在的位置// 组件2mounted:&#123;    Event.$on(&#x27;msg&#x27;,function(msg)&#123;// 接收数据，第一个参数是数据的名字，与发送时的名字对应，第二个参数是一个方法，要对数据进行操作    &#125;)&#125;\n\n[AIA]\n\nvue原型挂载总线Vue.prototype.bus &#x3D; new Vue()\n子组件发送数据this.bus.$emit(“change”,data)\n子组件接收数据this.bus.$on(“change”,function(data){})\n\nref&#x2F;$refs\nref:如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据，被用来给元素或子组件注册信息，引用信息将会注册在父组件的 $refs 对象上。\n适用场景：当使用element-ui组件时，可用于调用组件方法，例如el-table组件的选择表格项，排序等等。// 子组件export default &#123;    data() &#123;        return &#123;            name:&#x27;vue.js&#x27;        &#125;    &#125;,    methods:&#123;        sayHello:() &#123;            console.log(&#x27;hello&#x27;)        &#125;    &#125;&#125;\n\n&lt;!-- 父组件 app.vue --&gt;&lt;template&gt;    &lt;component ref=&quot;comA&quot;&gt;&lt;/component&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        mounted() &#123;            const comA = this.$ref.comA;            console.log(comA.name);//vue.js            comA.sayHello(); //hello        &#125;    &#125;&lt;/script&gt;\n\nref 这种方式，就是获取子组件的实例，然后可以直接子组件的方法和访问操作data的数据，就是父组件控制子组件的一种方式，子组件想向父组件传参或操作，只能通过其他的方式了\nprovide&#x2F;inject\n官方描述：选项需一起使用，允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效\n父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量\n\n应用provide\n\n一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。inject\n一个字符串数组\n一个对象\n\n//祖先组件 提供foo// 第一种export default &#123;    name:&quot;father&quot;,    provide() &#123;        return &#123;            foo:&#x27;hello&#x27;        &#125;    &#125;&#125;// 第二种export default &#123;    name:&quot;father&quot;,    provide:&#123;        foo:&#x27;hello~&#x27;    &#125;&#125;// 后代组件注入foo,直接当作this.foo来用export default &#123;    inject:[&#x27;foo&#x27;]&#125;/*    第一二种区别在哪儿？        如果需要this对象属性的值，        例如：            provide() &#123;                return &#123;                    test:this.msg                &#125;            &#125;        那么第二种是传不了的，后代组件拿不到数据。所以建议只写第一种 */\n[注意]一旦注入了某个数据，比如上面示例中的 foo，那这个组件中就不能再声明 foo 这个数据了，因为它已经被父级占有。\nprovide 和 inject 绑定并不是可响应的这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。因为对象是引用类型。\n\n先来个值类型的数据（也就是字符串）例子，不会响应\n\n    provide() &#123;        return &#123;            test:this.msg        &#125;    &#125;,    data() &#123;        return &#123;            msg:&quot;Welcome to Your Vue.js App&quot;        &#125;    &#125;,    mounted() &#123;        setTimeout(() =&gt; &#123;            this.msg = &quot;hello world&quot;            console.log(this._provided.msg) //Welcome to Your Vue.js App        &#125;,3000)    &#125;// 这样做是不行的，打印出来的 _provided 中的数据并没有改，子组件取得值也没变。若直接给 this._provided.msg 赋值，但是即使是_provided.msg 里面的值改变了，子组件的取值，依然没有变。\n\n\n但参数如果是对象，就可以响应了provide() &#123;    return &#123;        test:this.activeData    &#125;&#125;,data() &#123;    return &#123;        activeData:&#123;name:&#x27;xxxx&#x27;&#125;    &#125;&#125;,mounted() &#123;    setTimeout(() =&gt; &#123;        this.activeData.name = &#x27;aaaa&#x27;    &#125;,3000)&#125;\n\n用project与inject实现全局变量\n将其绑定到最顶层的组件app.vue，所有后代都接收到了，就是当做全局变量来用了。\n\n// app.vueexport default &#123;    name:&#x27;App&#x27;,    provide() &#123;        return &#123;            app:this        &#125;    &#125;,    data() &#123;        return &#123;            text:&quot;weiweiwei&quot;        &#125;    &#125;,    methods:&#123;        say() &#123;            console.log(&quot;enenen&quot;)        &#125;    &#125;&#125;// 其他所有子组件，需要全局变量的，只需按需注入app即可export default &#123;    inject:[&#x27;foo&#x27;,&#x27;app&#x27;],    mounted() &#123;        console.log(this.app.text);// 获取app中的变量        this.app.say();// 可以执行app中的方法，变身为全局方法    &#125;&#125;\n\nprovide&#x2F;inject实现页面刷新，不闪烁\n用vue-router重新路由到当前页面，页面是不进行刷新的\n采用window.reload()，或者router.go(0)刷新时，整个浏览器进行了重新加载，闪烁，体验不好上述办法都太行，那怎么办？\n\n\n控制路由的组件中写一个函数（使用v-if控制router-view的显示隐藏），然后把这个函数传递给后代，然后在后代组件中调用这个方法即可刷新路由啦。\n\n&lt;!-- app.vue --&gt;&lt;router-view v-if=&quot;isShowRouter&quot;/&gt;&lt;script&gt;export default &#123;    name:&#x27;App&#x27;,    provide() &#123;        return &#123;            reload:this.reload        &#125;    &#125;,    data() &#123;        return &#123;            isShowRouter:false        &#125;    &#125;,    methods:&#123;        reload() &#123;            this.isShowRouter = false            this.$nextTick(() =&gt; &#123;                this.isShowRouter = true            &#125;)        &#125;    &#125;&#125;// 后代组件export default &#123;    inject:[&#x27;reload&#x27;]&#125;//这里 provide 使用了函数传递给后代，然后后代调用这个函数，这种思路，也是可以做子后代向父组件传参通讯的思路了。这里的原理，和 event 事件订阅发布就很像了&lt;/script&gt;\n\n内置组件\n定义：除了原生标签是纯小写以外，非自定义组件纯小写标签都是内置组件\n\ntemplatevue内置模板组件，它不会渲染成任何真实的dom\nslot插槽组件，它也不会渲染成任何真实的dom,只是用于接收渲染插入的内容\nkeep-alive缓存状态组件，不会渲染成真实dom，只是将被包裹的自定义组件的状态缓存到内存中\n\n多用与缓存表单填写的组件\n它不能缓存v-for循环渲染出来的组件\n如果它包含多个子元素的话，需要使用v-if控制显示一个子元素【props】\ninclude 该属性控制keep-alive只缓存被指定的组件，不被指定的不缓存\nexclude 该属性控制keep-alive不缓存被指定的组件，不被指定的组件缓存\nmax 数字，限制keep-alive缓存组件的最大个数【生命周期】被keep-alive包裹的组件，才拥有该生命周期\nactivated被keep-alive激活的生命周期\ndeactivated被keep-alive销毁时候的生命周期\n\nkeep-alive使用\n几种常见用法\n&lt;script&gt;    export default &#123;        name:&#x27;test-keep-alive&#x27;,        data() &#123;            return &#123;                includedComponents:&quot;test-keep-alive&quot;            &#125;        &#125;    &#125;&lt;/script&gt;&lt;!-- 第一种 将缓存name为test-keep-alive的组件 --&gt;    &lt;keep-alive include=&quot;test-keep-alive&quot;&gt;        &lt;component&gt;&lt;/component&gt;    &lt;/keep-alive&gt;&lt;!-- 第二种 将缓存name为a或b的组件，结合动态组件使用 --&gt;    &lt;keep-alive include=&quot;a,b&quot;&gt;        &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;&lt;!-- 第三种 使用正则表达式，需使用v-bind --&gt;    &lt;keep-alive :include=&quot;/a|b/&quot;&gt;        &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;&lt;!-- 第四种 动态判断 --&gt;    &lt;keep-alive :include=&quot;includeComponents&quot;&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;&lt;!-- 第五种 将不缓存name为test-keep-alive的组件 --&gt;    &lt;keep-alive exclude=&quot;test-keep-alive&quot;&gt;        &lt;component&gt;&lt;/component&gt;    &lt;/keep-alive&gt;\n\n结合router，缓存部分页面[使用$route.meta的keepAlive属性]\n\n\n&lt;keep-alive&gt;    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;script&gt;    // router/index.js    export default new Router(&#123;        routes:[            &#123;                path:&#x27;/&#x27;,                name:&#x27;Hello&#x27;,                component:Hello,                meta:&#123;                    keepAlive:false // 不需要缓存                &#125;            &#125;,            &#123;                path:&#x27;/page1&#x27;,                name:&#x27;Page1&#x27;,                component:Page1,                meta:&#123;                    keepAlive:true // 需要被缓存                &#125;            &#125;        ]    &#125;)&lt;/script&gt;&lt;!-- page1页面 --&gt;&lt;template&gt;    &lt;div class=&quot;hello&quot;&gt;        &lt;h1&gt;Vue&lt;/h1&gt;        &lt;h2&gt;两个大括号包着msg&lt;/h2&gt;        &lt;input placeholder=&quot;输入框&quot;/&gt;    &lt;/div&gt;&lt;/template&gt;&lt;!-- hello页面 --&gt; &lt;template&gt;    &lt;div class=&quot;hello&quot;&gt;        &lt;h1&gt;两个大括号包着msg&lt;/h1&gt;    &lt;/div&gt;&lt;/template&gt;&lt;!--     结果：在page1页面输入框输入sss,然后手动跳转到hello页面，回到page1页面之前输入的sss依然保留，说明页面信息成功保存在内存中 --&gt;\n\n或者也可以通过动态设置route.meta的keepAlive属性来实现其他需求【要求】：首页是A页面 B页面跳转到A，A页面需要缓存，C页面跳转到A，A页面不需要被缓存 [思路]：思路是在每个路由的beforeRouteLeave(to, from, next)钩子中设置to.meta.keepAlive：\n\nto:Route 即将要进入目标路由对象\nfrom:Route 当前导航正要离开的路由\nnext：Function 一定要调用该方法来resolve这个钩子。执行效果依赖 next 方法的调用参数\nnext() 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed(确认的)\nnext(false) 中断当前的导航。如果浏览器的URL改变了(可能是用户手动或者浏览器后退按钮)，那么URL地址会重置到from路由对应的地址\nnext(‘&#x2F;‘) 或者next({path:’&#x2F;‘}):跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航\nnext(error) 如果传入next的参数是一个error实例，则导航会被终止且该错误会被传递给router.onError()注册过的回调\n\n\n\n // A的路由&#123;    path:&#x27;/&#x27;,    name:&#x27;A&#x27;,    component:A,    meta:&#123;        keepAlive:true // 需要缓存    &#125;&#125;export default &#123;    beforeRouteLeave(to,from,next) &#123;        // 设置下一个路由的meta        to.meta.keepAlive = true; //B跳转到A时，让A缓存，即不刷新        next()    &#125;&#125;export default &#123;    beforeRouteLeave(to,from,next) &#123;        // 设置下一个路由的meta        to.meta.keepAlive = false; // C 跳转到 A 时让A不缓存，即刷新        next();    &#125;&#125; \n\ncomponent动态加载组件\n特点\n必须使用动态绑定的is属性来加载组件\nis属性值必须是components里注册组件的名字\n让代码更简洁，更可控\n它的工作形式和v-if一致，使组件加载与销毁\n\n\n实现两个子组件动态切换&lt;!-- son1 --&gt;&lt;div&gt;    &lt;h1&gt;我是子组件1&lt;/h1&gt;    &lt;slot&gt;子组件1的默认内容&lt;/slot&gt;&lt;/div&gt;&lt;!-- son2 --&gt;&lt;div&gt;    &lt;h1&gt;我是子组件2&lt;/h1&gt;    &lt;slot&gt;子组件2的默认内容&lt;/slot&gt;&lt;/div&gt;&lt;!-- 父组件 --&gt;&lt;button @click=&quot;change1&quot;&gt;son1&lt;/button&gt;&lt;button @click=&quot;change2&quot;&gt;son2&lt;/button&gt;&lt;component :is=&#x27;state&#x27;&gt;&lt;/component&gt;&lt;script&gt;    data() &#123;        return &#123;state:&#x27;son1&#x27;&#125;    &#125;,    methods:&#123;        change1() &#123;this.state=&#x27;son1&#x27;&#125;,        change2() &#123;this.state=&#x27;son2&#x27;&#125;    &#125;,    components:&#123;        son1,son2    &#125;&lt;/script&gt;\n\n【Tip】\n\nson1,son2切换时，另一组件被销毁，所以，当两个组件进行动态切换时，组件的状态是：不断创建与销毁的过程\n如果想把组件缓存下来，可以在动态组件上使用vue另一个内置组件keep-alive \n     \n \n\n父子组件执行顺序的问题：\n问：我们在父组件和子组件son中分别定义个生命周期钩子mounted，页面加载到完成，父组件先渲染完成还是子组件先渲染完成呢？\n答：结果是父组件挂载完成前提：需等到子组件挂载完成后\n问：子组件先挂载完成，父组件才能挂载完成，下边代码我们在父组件中获取子组件的dom元素\n\n&lt;div id=&quot;app&quot;&gt;    &lt;son ref=&#x27;son&#x27;&gt;&lt;/son&gt;&lt;/div&gt;&lt;script&gt;    // 子组件    var son = &#123;        template:        &lt;div&gt;            &lt;h1&gt;双括号里包着name&lt;/h1&gt;        &lt;/div&gt;        ,        data() &#123;            return &#123;name:&#x27;hhh&#x27;&#125;        &#125;,        mounted() &#123;            this.name = &#x27;lll&#x27;        &#125;    &#125;    // 父组件(根实例)    var vm = new Vue(&#123;        el:&quot;#app&quot;,        mounted() &#123;            console.log(this.$refs.son.$el.innerText)        &#125;,        components:&#123;son&#125;    &#125;)&lt;/script&gt;&lt;!-- 上边代码，在子组件的mounted中我们修改了原来data对象中的数据，页面渲染完全没问题，但是在父组件mouted中输出子组件dom元素的内容时，不是新数据 &quot;lll&quot;，而是原来的数据 &quot;hhh&quot;  --&gt;\n\n【结论】子组件生命周期钩子mounted和父组件的mounted都是同步执行的，但是子组件渲染却是异步渲染的，所以在父组件的mounted中获取dom元素是原来的子组件数据！！[解决上述bug] 用vm.$nextTick中去获取dom元素\n// 子组件    .......// 父组件(根实例)var vm = new Vue(&#123;    el:&quot;#app&quot;,    mounted() &#123;        this.$nextTick(function() &#123;            console.log(this.$refs.son.$el.innerText)        &#125;)    &#125;,    components:&#123;son&#125;&#125;)\nBTW——el和$el\nel是Vue实例的挂载目标，实例挂载后，元素可以用xx.$el访问。挂载阶段还没开始的时候,$el属性是不可见的。vue生命周期mounted阶段，el被新创建的xx.$el替换，这个时候Vue实例的挂载目标确定，DOM渲染完毕\n\ntransition动画组件组件出现过度&#x2F;动画效果的原因【当插入或删除包含在transition组件中的元素时，Vue将会做以下处理】：\n\n自动嗅探目标元素是否应用里css过度或动画，如果是，在恰当的时机添加&#x2F;删除css类名\n如果过度组件提供了JS钩子函数，这些钩子函数将在恰当时机被调用\n如果没有找到JS钩子函数也没有检测到css过渡&#x2F;动画，DOM操作(插入&#x2F;删除)在下一帧中立即执行。(注意：此浏览器逐帧动画机制，和Vue的nextTick概念不同)\n\ntransition组件在什么情况下可以生成动画效果？【Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入&#x2F;离开过渡动画效果】\n\n条件渲染(使用v-if)，可以使用key代替v-if\n条件展示(使用v-show)\n动态组件 \n组件根节点 transition&#x2F;transition-group作为跟组件，形成可服用动态组件\n\ntransition组件生成动画效果的方式【Vue在插入、更新或者移除DOM 时，提供了以下不同方式的应用过渡效果】：\n\n在css过渡和动画中自动应用class\n可以配合使用第三方css动画库，如animate.css\n在过渡钩子函数中使用javascript 直接操作 dom\n可以配合使用第三方 JavaScript 动画库，如 Velocity.js\n\n分别详细介绍\n【css过渡】：常用的过渡都是使用 CSS 过渡，也就是 组件和css3属性transition连用\n\napi\nname 指定自己写的动画类名前缀\nv-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。\nenter-class-active 进入动画的类名\nleave-class-active 离开动画的类名\nduration 设置动画执行的间隔时间\nv-enter-active: 定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition&#x2F;animation 完成之后移除。 这个类可以被用来定义过渡的过程时间，延迟和曲线函数。\nv-enter-to: 定义进入过渡的结束状态。在元素被插入一帧后生效（于此同时 v-enter 被删除），在 transition&#x2F;animation 完成之后移除。\nv-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。\nv-leave-active: 定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition&#x2F;animation 完成之后移除。 这个类可以被用来定义过渡的过程时间，延迟和曲线函数。\nv-leave-to: 定义离开过渡的结束状态。在离开过渡被触发一帧后生效（于此同时 v-leave 被删除），在transition&#x2F;animation 完成之后移除。\n\n&lt;div id=&quot;app4&quot;&gt;    &lt;button @click=&quot;show = !show&quot;&gt;        toggle coustom class    &lt;/button&gt;    &lt;transition         name=&quot;bounce&quot;        enter-active-class=&quot;animated tada&quot;        leave-active-class=&quot;animated bounceOutRight&quot;&gt;        &lt;p v-if=&quot;show&quot;&gt;自定义过渡类名&lt;/p&gt;    &lt;/transition&gt;&lt;/div&gt;&lt;!-- 样式如此设置，只需要控制show是false还是true，即可有淡入淡出效果 --&gt;&lt;style&gt;    .fade-enter-active,.fade-leave-active&#123;        transition: opacity 0.5s;           &#125;    .fade-enter,.fade-leave-to&#123;        opacity:0    &#125;&lt;/style&gt;&lt;script&gt;    data:&#123;        return &#123;            show:true        &#125;    &#125;&lt;/script&gt;&lt;!-- 对于这些enter/leave过渡中切换的类名，v-是这些类名的前缀。使用使用&lt;transition name=&quot;my-transition&quot; 可以重置前缀，比如 v-enter 替换为 my-transition-enter。 --&gt;\n\n\n【过渡可以和其他第三方 CSS 动画库连用】\n\n&lt;transition     name=&quot;bounce&quot;    enter-active-class=&quot;animated tada&quot;    leave-active-class=&quot;animated bounceOutRight&quot;&gt;    &lt;p v-if=&quot;show&quot;&gt;自定义过渡类名&lt;/p&gt;&lt;/transition&gt;export default&#123;    data:&#123;        show:true    &#125;&#125; // 不需要设置样式，只需要控制show是false还是true，即可有动画效果\n\n\n【CSS 动画】\n\n\nCSS 动画是transition组件和css3属性animation连用，用法和 CSS 过渡相同\n区别是：在动画中 v-enter 类名在节点插入DOM后不会立即删除，而是在 animationend 事件触发时删除。\n\n&lt;transition name=&quot;bounce&quot;&gt;     &lt;p v-if=&quot;show&quot;&gt;使用animation做动画效果&lt;/p&gt;&lt;/transition&gt;&lt;style&gt;     .bounce-enter-active&#123;animation:bounce-in 0.5s&#125;    .bounce-leave-active&#123;animation:bounce-in 0.5s reverse&#125;    @keyframes bounce-in&#123;        0%&#123;transform:scale(0)&#125;        50%&#123;transform:scale(1.5)&#125;        100%&#123;transform:scale(1)&#125;    &#125;&lt;/style&gt;\n\n\n【transition组件和JavaScript 钩子连用】\n\n\n当只用js过渡的时候，在enter和leave中必须使用done进行回调。否则，它们将被同步调用，过渡会立即完成\n推荐对于仅使用JS过渡的元素v-bind:css&#x3D;”false”,Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。\n\n&lt;transition    @before-enter=&quot;beforeEnter&quot;    @enter=&quot;enter&quot;    @after-enter=&quot;afterEnter&quot;    v-on:before-leave=&quot;beforeLeave&quot;    v-on:leave=&quot;leave&quot;    v-on:after-leave=&quot;afterLeave&quot; &gt;&lt;div id=&quot;ball&quot; v-show=&quot;show&quot;&gt;hello&lt;/div&gt;    &lt;/transition&gt;&lt;script&gt;    data:&#123;show:true&#125;    methods:&#123;    //el 即操作的元素对象    beforeEnter(el)&#123;        el.style.transform=&#x27;translate(80px,80px)&#x27;;    &#125;    enter(el,done)&#123;        // 必须下面加下面一行，否则不会出现应有的效果        el.offsetWidth;//这里可以理解成强制浏览器刷新，也可以写成el.offsetHeight        el.style.transition=&#x27;all 1.5s ease&#x27;        el.style.transform=&#x27;translate(0,0)&#x27;;        done()    &#125;,    afterEnter(el)&#123;        cnosole.log(&#x27;afterEnter&#x27;)        // this.flag=false;//隐藏小球    &#125;,    beforeLeave:function(el)&#123;        el.style.transform=&#x27;translate(0,0)&#x27;    &#125;,    // 当与CSS结合时    // 回调函数done是可选的    leave:function(el,done)&#123;        el.offsetWidth;//这里可以理解成强制浏览器刷新，也可以写el.offsetHeight        el.style.transition=&#x27;all 3s ease&#x27;        el.style.transform=&#x27;translate(80px 80px)&#x27;        // 这是直接调用done的话由于会立即删除元素导致动画不执行        done()        // 解决办法        方法1：不调用done可以进行动画，但是元素依旧存在，并且afterLeave函数钩子不执行        方法2：        //setTimeout可以解决这个问题，让done不立即执行，过几秒后再执行setTimeout(done,3000);//时间根据自己设定的动画时间确定    &#125;,    afterLeave:function(el)&#123;        console.log(&#x27;afterLeave&#x27;)    &#125;&#125;&lt;/script&gt; \n\n[注意]：在leave函数钩子中，直接调用done函数，会立即删除元素导致动画不执行\n\n和JS动画库Velocity一起使用// &lt;div id=&quot;app5&quot;&gt;//     &lt;button @click=&quot;show = !show&quot;&gt;toggle hook&lt;/button&gt;//     &lt;transition @before-enter=&quot;beforeEnter&quot;//                 @enter=&quot;enter&quot;//                 @leave=&quot;leave&quot;//                 :css=&quot;false&quot;&gt;//             &lt;p v-if=&quot;show&quot;&gt;javascript 钩子使用&lt;/p&gt;//     &lt;/transition&gt;// &lt;/div&gt;    methods:&#123;        beforeEnter:function (el) &#123;            console.log(el);            alert(&quot;beforeEnter&quot;);            el.style.opacity = 0            el.style.transformOrigin = &#x27;left&#x27;        &#125;,        enter:function (el, done) &#123;            alert(&quot;enter&quot;);        //    console.log(done);            Velocity(el, &#123;opacity:1, fontSize:&#x27;1.4em&#x27;&#125;, &#123;duration:300&#125;);            Velocity(el, &#123;fontSize:&#x27;1em&#x27;&#125;, &#123;complete:done&#125;);            Velocity(el,&quot;reverse&quot;, &#123; duration: 6000 &#125;);            Velocity(el,&#123;                        borderBottomWidth: [ &quot;2px&quot;, &quot;spring&quot; ], // Uses &quot;spring&quot;                    width: [ &quot;100px&quot;, [ 250, 15 ] ], // Uses custom spring physics                        height: &quot;100px&quot; // Defaults to easeInSine, the call&#x27;s default easing                    &#125;, &#123;                            easing: &quot;easeInSine&quot; // Default easing                    &#125;);        &#125;,        leave:function (el, done) &#123;            Velocity(el, &#123;translateX:&#x27;15px&#x27;, rotateZ:&#x27;50deg&#x27;&#125;, &#123;duration:600&#125;)            Velocity(el, &#123;rotateZ:&#x27;100deg&#x27;&#125;, &#123;loop:2&#125;)            Velocity(el,&#123;                rotateZ:&#x27;45deg&#x27;,                translateY:&#x27;30px&#x27;,                translateX:&#x27;30px&#x27;,                opacity:0            &#125;, &#123;complete:done&#125;)        &#125;       &#125;\n\n\n【组件间切换的动态效果实现】组件的过渡-不需要使用key attribute。使用动态组件component，进行切换\n【元素间切换的动态效果实现】\n\n\n6.1原生标签可以使用 v-if&#x2F;v-else \n    \n      Save\n    \n    \n      Edit\n    \n  \n\n[注意]：当有相同标签名的元素切换时(比如两个div元素)，必须通过 key attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容（也就是不会有动画效果）。\n\n6.2设置key代替v-if&#x2F;v-else\n  \n    \n    双括号中间包着isEdting ? 'Save':'Edit'\n    \n  \n\n6.3两种过渡模式多个元素间的过度动画（一个元素离开，一个元素进入），是同时生效的。这种情形不能满足所有要求，所以 Vue 提供了过渡模式。\n\nin-out：新元素先进行过渡，完成之后当前元素过渡离开。\nout-in：当前元素先进行过渡，完成之后新元素过渡进入  \n  \n  \n\n\n\n\n【可复用过渡组件】过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将  或者  作为根组件，然后将任何子组件放置在其中就可以了。\n\n    Vue.component(&#x27;my-special-transition&#x27;, &#123;        template: &#x27;\\ name=&quot;very-special-transition&quot;\\        mode=&quot;out-in&quot;\\        v-on:before-enter=&quot;beforeEnter&quot;\\        v-on:after-enter=&quot;afterEnter&quot;\\    &gt;\\\\\\&#x27;,methods: &#123;beforeEnter: function (el) &#123;// ...                        &#125;,afterEnter: function (el) &#123;// ...                        &#125;    &#125;&#125;)函数组件更适合完成这个任务：Vue.component(&#x27;my-special-transition&#x27;, &#123;functional: true,render: function (createElement, context) &#123;var data = &#123;    props: &#123;    name: &#x27;very-special-transition&#x27;    mode: &#x27;out-in&#x27;&#125;,on: &#123;beforeEnter: function (el) &#123;// ...                            &#125;,afterEnter: function (el) &#123;// ...                            &#125;    &#125;&#125;    return createElement(&#x27;transition&#x27;, data, context.children)    &#125;&#125;)\nBTW——当内置组件混合使用时的嵌套顺序transition&gt;keep-alive&gt;component\n递归组件用不同的输入参数一次又一次地执行相同的代码块，直到达到结束点[注意点]\n\n数据源必须来自上游\n递归组件必须要有”name”属性，且值与组件文件名一致\n必须要有v-if的终止渲染条件v-if &#x3D;”activeld” &amp;&amp; datalist[activeld].children即需要 datalist[activeId] 存在 &amp;&amp; datalist[activeId] &lt;!-- 假设我们在windows中绑定了一个arr --&gt;&lt;div v-if=&quot;arr.length&gt;0||arr!=null&quot;&gt;hhh&lt;/div&gt;&lt;div v-else&gt;xxx&lt;/div&gt;&lt;!-- 报错出现在我们的前半条判断中，在我们判断数组的长度是否大于零的时候，需要先判断我们是否有数组，如果没有数组的话，那么这条数据就会发生报错 --&gt;\n\nBTW——自定义组件要么首字母大写，要么用中划线的方式\nnextTick\n等所有dom更新完毕后触发(执行其指定的回调)，因为vue中dom更新是异步的才有这个东西\n语法    this.$nextTick(() =&gt; &#123;        // 获取更新后的dom内容    &#125;)    this.$nextTick().then(() =&gt; &#123;\t// 获取更新后的dom内容&#125;);\n应用场景\n\n\ncreated()进行DOM操作一定要放在Vue.nextTick()的回调函数\n在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中\n\n过滤器在不修改原始数据的情况下，对数据进行计算并返回新数据，该方法只能用在插值语法中\n\n双大括号插值和v-bind 表达式（后者从2.1.0+开始支持）\n\n过滤器函数总接收表达式的值作为第一个参数   \n两个大括号中间写着 message |\n\n\n在上述例子汇总，filter过滤器函数将会收到message的值作为第一个参数\n\n过滤器可以串联\n两个大括号中间写着 message | filterA | filterB在这个例子中，filterA被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将filterA的结果传递到filterB中\n\n过滤器是javascript 函数可以接收参数\n两个大括号中间写着 message | filterA(‘arg1’,arg2filterA被定义为接收三个参数的过滤器函数。其中message的值作为第一个参数，普通字符串’arg1’作为第二个参数，表达式arg2作为第三个参数\n\n全局过滤器filter 每次只能写一个\nVue.filter(&quot;prefix&quot;,(n) =&gt; &quot;¥&quot;+n)\n使用| 叫管道符号\n\n语法：Vue.filter(filterName,() =&gt; &#123;return //数据处理结果&#125;)\n实际开发使用\nstep1 用在数据修饰上，通常我们把函数抽离出去，统一放在个.js文件中\n\n// filter.jslet filterPrice=(value) =&gt; &#123;    return &#x27;已收款&#x27; + value.&#x27;元&#x27;&#125;let filterDate=(value) =&gt; &#123;    return value + &#x27;天&#x27;&#125;export default&#123;filterPrice,filterDate&#125;\n\nstep2 在main.js中导入上边filter.js文件，也可以在任何组件中导入filter.js这个文件，但对于全局过滤器来说，最好是在main.js中定义，导入的是一个对象，所以使用Object.keys()方法，得到一个由key组成的数组，遍历数组，让key作为全局过滤器的名字，后面的是key对应的处理函数，这样在任何一个组件中都可以使用全局过滤器了\n\n// main.js    // 两种导入方式 推荐第一种    import * as filters from &#x27;./filter&#x27;    import &#123;filterPrice,filterDate&#125; from &#x27;./filter&#x27;    Object.keys(filters.default).forEach((item) =&gt; &#123;        Vue.filter(item,filters.default[item])    &#125;)    new Vue(&#123;        router,        store,        render:h =&gt; h(App)    &#125;).$mount(&#x27;#app&#x27;)\n\nstep3在组件中使用 全局过滤器\n\n&lt;template&gt;    &lt;div&gt;        &lt;input type=&quot;text&quot; v-model=&quot;filterCount&quot;&gt;        &lt;div&gt;两个大括号中间写 filterCount | filterPrice&lt;/div&gt;        &lt;div&gt;两个大括号中间写 filterCount | filterDate&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        data() &#123;            return &#123;                filterCount:1500            &#125;        &#125;    &#125;&lt;/script&gt;\n\n组件过滤器filters可以写很多个\nfilters:&#123;n1(n)&#123;    return n+2&#125;&#125;\n样例&lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;filterCount&quot; /&gt;    &lt;div class=&quot;filter&quot;&gt;两个大括号中间写 filterCount | changeCapitalLetter&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    export default &#123;        data() &#123;            return &#123;                filterCount:&#x27;hello&#x27;            &#125;        &#125;,    filters:&#123;        changeCapitalLetter(value) &#123;            // value是输入框的内容也是要显示的            if(value) &#123;                let str = value.toString();                // 获取英文，以空格分组把字符串转为数组，遍历每一项第一项转为大写字母                let newArr = str.split(&quot;&quot;).map(ele =&gt; &#123;                    return ele.charAt(0).toUppeCase()+ele.slice(1)                &#125;);                return newArr.join(&quot;&quot;) // 数组转字符串以空格输出                &#125;            &#125;        &#125;    &#125;&lt;/script&gt;\n\n常见使用场景：格式日期(时间)，金钱单位，保留小数位\n\n模块化\n定义:[简单来说]就是模块化就是将变量和函数,放入不同的文件中\n\n模块的优点?\n可维护性强:因为模块独立，代码依赖小，自己可以独立更新和改进\n命名空间:一般一个变量在最顶级的函数外声明，可以全局使用，易出现命名冲突的情况。使用模块化开发来封装变量，可以避免全局污染\n重用代码：通过模块引用的方式，来复用代码\n\nCommonJS AMD&#x2F;CMD\n定义：CommonJS是一种规范语法，内容有很多种，nodejs是这种规范的实现【扩展】：1.SeaJS是模块加载器，是用CMD规范    2.AMD&#x2F;CMD是从 CommonJS 讨论中诞生的    3.RequireJS 遵循 AMD（异步模块定义）规范    4.Sea.js 遵循 CMD （通用模块定义）规范  规范的不同，导致了两者 API 不同。  [AMD] 提前执行：提前异步并行加载      优点：尽早执行依赖可以尽早发现错误      缺点：易产生浪费  [CMD] 延迟执行：延迟按需加载      优点：减少资源浪费      缺点：等待时间长、出错时间延后\n\n// CMD 依赖就近 define(function(require,exports,module)&#123;// 定义模块    var demo=require(&#x27;demo&#x27;)    var x=demo.demo()    var web=&#123;        add:function(x)&#123;            return x+y        &#125;    &#125;;    return &#123;        web:web    &#125;;&#125;);\n[RequireJS] 前端模块化管理工库\n        详解：通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新函数(模块)，我们所有关于新模块的业务代码都在这个函数内部操作，其内部也可以无限制的使用已经加载进来的模块\n\n// main.jsrequire.config(&#123;    abc:&#123;        &#x27;boostrap&#x27;:&#123;            deps:[&#x27;jquery&#x27;],            exports:&#x27;boostrap&#x27;        &#125;    &#125;,    paths:&#123;        &quot;jquery&quot;:&quot;路径&quot;,        &quot;boostrap&quot;:&quot;路径&quot;,        &quot;index&quot;:&quot;index&quot;    &#125;&#125;);require([&#x27;jquery&#x27;,&#x27;boostrap&#x27;,&#x27;index&#x27;],function($,bootstrap,index)&#123;    console.log(index.web.add(11));    $(&quot;.p1&quot;).text(index.web.add(11))&#125;)\nES6模块\n导入导出var name = &#x27;AI&#x27;;var phone = &#x27;3571678&#x27;var hobby = &#x27;购物&#x27;;// 普通导出导入    export &#123;name, phone, hobby&#125;;    // 导入    import &#123;name, phone, hobby&#125; from &#x27;./views/moduleA&#x27; // 导出export别名    export &#123; name as v1, age as v2, hobby as v3&#125;;    // 导入    import &#123;v1, v2, v3&#125; from &#x27;./views/moduleA&#x27;;//导出export default仅有一个    export default &#123;name:&#x27;lll&#x27;,hobby:&#x27;games&#x27;&#125;    // 导入    import obj from &#x27;./views/moduleD&#x27;// 定义公共数据    // 性别    export const sexData=[        &#123;key:&#x27;man&#x27;,value:&#x27;男&#x27;&#125;,        &#123;key:&#x27;woman&#x27;,value:&#x27;女&#x27;&#125;    ]    //用户    export const userData = [        &#123;id:&#x27;1&#x27;,value:&#x27;name1&#x27;&#125;,        &#123;id:&#x27;2&#x27;,value:&#x27;name2&#x27;&#125;     ];    // 导入    import &#123;sexData,userData&#125; from &#x27;./views/moduleB&#x27; \n图片的导入// 1.直接导入 &lt;img src=&#x27;&#x27;&gt;// 2.通过import    import img1 from &#x27;./assets/img/1.jpg&#x27; //导入图片    &lt;img :src=&quot;img1&quot; /&gt;&lt;/div&gt; // 3.通过require的方式   data()&#123;       return&#123;           img:[               require(&quot;@/assets/img/1.jpg&quot;),               require(&quot;@/assets/img/2.jpg&quot;)           ]       &#125;   &#125;\n\ncommon.js和es6模块的区别？node使用的是commonjs 在使用模块的时候是运行时同步加载的，拷贝模块中的对象，模块可以多次加载，但只会在第一次加载，之后会被缓存，引入的是缓存中的值\n\ncommonjs输出的是一个值的拷贝，而es6输出的是值的引用\ncommonjs是运行时加载，es6是编译时输出接口\n\n混入mixins\n定义：将多个组件内重复使用的js部分抽离出来，作为混入文件，哪里复用插哪里\n\n语法// mixins.js    export default &#123;      // ...组件内所有的配置，这里都有        data()&#123;&#125;,        props:[],        methods:&#123;&#125;,        // 生命周期        mixins:[],        components:&#123;&#125;,    &#125;\n// App.vue    import mixins from &quot;./mixins&quot;;    export default&#123;        mixins:[mixins,p,p]//为什么要写成数组形式？因为这里面有顺序,若函数有重复会依次合并，    &#125;\n为了复用代码，复用js，三个组件，每个组件内都有同一个业务，同一个事件，并且事件的处理内容都一样\n特点只能复用js，且组成部分与vue组件中的script完全一致\n混入的优缺点优点节省代码量，让代码高复用，降低了代码的重复率。让vue组件’瘦身’\n缺点容易冲突，不好控制，后期维护成本高\n执行顺序及特性执行顺序是先执行混入文件后执行组件。如果mixins里有多个混入的话，会按照顺序依次执行\n特性\n数据、函数，如果组件内和混入里的命名重复了则使用组件内的覆盖混入里的\n如果混入里和组件内有相同的生命周期，则两个生命周期都会执行，先执行混入后执行组件\n\nextends扩展扩展执行表现形式和混入完全一样\nextends和mixins区别\n扩展只能挂载一个\n而混入可以使用数组的方式挂载很多个混入\n\n数据监听方法一：利用keyup事件来实现 // 定义一个getFullName函数        // &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot; @keyup =&quot;getFullName&quot;&gt; +        // &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot; @keyup=&quot;getFullName&quot;&gt; =        // &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot; @keyup=&quot;getFullName&quot;&gt; // 在vm中定义方法    el:&quot;#app&quot;,    data() &#123;        lastname:&#x27;&#x27;,        firstname:&#x27;&#x27;,        fullname:&#x27;&#x27;    &#125;,    methods:&#123;        getFullName() &#123;            this.fullname = this.lastname+&#x27;-&#x27;+this.firstname        &#125;    &#125;\nwatch侦听器\n专门用于监听数据变化的  使用这个属性，可以监视data中指定数据的变化，然后触发这个watch中对应的function可以不用绑定事件\n\n特性\n在watch中可以对另外一个数据修改\n可以对监听的数据进行固定值赋值，因为watch会新旧值对比，发现一致则不会再触发监听了\n监听数据，赋值如果是递增或递减则会报错\n默认只能是监听基本数据类型和数组的值\n如果监听的是对象，则需要对象写法\n不需要返回值\n它可以执行异步操作：定时器、ajax\n\nwatch–监听数据变化 &lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; +    &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; =    &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt;&lt;script&gt;    el:&quot;#app&quot;,    data()&#123;        lastname:&#x27;&#x27;,        firstname:&#x27;&#x27;,        fullname:&#x27;&#x27;    &#125;,    methods:&#123;&#125;,    watch:&#123;        &#x27;lastname&#x27;:function(newVal)&#123;            this.fullname=newVal+&#x27;-&#x27;+this.firstname        &#125;        &#x27;firstname&#x27;:function(newVal)&#123;            this.fullname=newVal+&#x27;-&#x27;+this.lastname        &#125;    &#125;&lt;/script&gt;\n三个选项\nhandler 平时的写法，就默认写的是handler\nimmediate\n默认false，在进入页面，第一次绑定值，不会立刻执行监听，只有数据发生改变才会执行handler中的操作\n为true时，handler在第一次绑定值时就触发\n\n\ndeep 用来进行深度监听，监听到对象属性的变化\n\n语法格式// 1.监听基本数据类型watch:&#123;    name(val,oldVal) &#123;         // val是新值，oldVal是旧值    &#125;,    // 等价于    name:function() &#123;&#125;,    // 不能写箭头函数，因为箭头函数中的this值的是函数定义时所在的对象而不是函数运行时所在的对象    // name: () =&gt; &#123;&#125; // error xxx// 2. 监听对象watch:&#123;    obj:&#123;        // 深度监听        deep:true,        // 执行函数        handler(val) &#123;&#125;,        // 自动执行一次        immediate:true    &#125;&#125;// 只监听对象中的某一个属性值// 点语法只限于对象使用，数组不可以    &#x27;obj.age&#x27;(val,old)&#123;&#125;    &#x27;obj.age&#x27;:function()&#123;&#125;&#125;\n\nwatch–监听路由变化&lt;router-link to=&quot;/login&quot;&gt;登陆&lt;/router-link&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;script&gt;    watch:&#123;        &#x27;$route.path&#x27;:function(val,oldVal)&#123;            if(newVal===&#x27;/login&#x27;) &#123;                console.log(&#x27;欢迎进入login&#x27;)            &#125;else if(newVal===&#x27;/register&#x27;) &#123;                console.log(&#x27;欢迎进入register&#x27;)            &#125;        &#125;    &#125;    // router/index.js    const router = new VueRouter(&#123;        routes:[            &#123;path:&#x27;/&#x27;,redirect:&#x27;/login&#x27;&#125;,            &#123;path:&#x27;login&#x27;,component:login&#125;,            &#123;path:&#x27;register&#x27;,component:register&#125;        ]    &#125;)&lt;/script&gt;\n\ncomputed计算属性\n定义：监听一个值返回一个新值，且新值必须使用才能监听成功\n\n特性\n由于计算属性需要立即返回新值，因此不能处理异步操作\n计算属性不受数据类型限制，任何数据都可以被监听\n默认计算属性的值是只读的，不可以直接修改\n如果要修改计算属性，则需要使用对象写法\n计算属性可以监听多个值\n有缓存，提高渲染性能\n如果在页面上需要用到 对现有的数据进行加工得到新数据，则是要使用计算属性\n想要给计算属性赋值，则需要使用set方法\n计算属性和data一样，都需要设置return，当没有输出结果时，需要排查是不是return漏掉了\n\n&lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; +    &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; =    &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt;&lt;script&gt;    data()&#123;        lastname:&#x27;&#x27;,        firstname:&#x27;&#x27;    &#125;,    computed:&#123;        &#x27;fullname&#x27;:function()&#123;            return this.lastname+&#x27;-&#x27;+this.firstname        &#125;    &#125;&lt;/script&gt;\n\n[!注意]\n\nfullname没有在data中定义，在computed定义fullname后直接return出去就好\n计算属性的求值结果，会被缓存起来，方便下次直接使用\n不会因为页面中调用几次函数去执行几次，只会根据函数执行来调用函数(比如页面放入很多插值,例如fullname，在function中console.log(ok),刷新页面时，后台只会出现一个OK和初始就在的OK)\n\n语法格式computed:&#123;    // 基础使用    newStr() &#123;        return this.str+&#x27;xxx&#x27;    &#125;,    // 修改写法    myData:&#123;        get() &#123;            return this.my        &#125;,        set(value) &#123;            this.my = value        &#125;    &#125;&#125;\n\nwatch computed methods 对比\ncomputed属性结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用\nmethods 方法表示一个具体的操作，主要书写业务逻辑\nwatch一个对象，键时需要观察的表达式，值对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体\n\nwatch computed 区别\nwatch不支持缓存，computed有缓存\nwatch支持异步，computed不支持异步\nwatch不需要返回新值，computed需要返回新值\nwatch只能监听一个属性，computed能监听多个属性\nwatch只能监听基本数据类型和数组的值，computed不受数据类型限制\n\n自定义指令扩展了vue没有的操作dom的指令，比如登录页的用户名输入框自动获取焦点，根据用户权限控制某些元素的是否可见等。\n组件内directives\n&lt;script&gt;    // 声明    directives:&#123;        focus:&#123;            // 绑定的时候初始化            bind(el,binding)&#123;&#125;,            // 元素的父集已经呈现，用于指令的操作            inserted(el,binding)&#123;&#125;,            // 更新：自己更新，不能保证子元素更新完            update(el,binding)&#123;&#125;,             // 等待当前组件的所有元素全部更新完毕            componentUpdate(el,binding)&#123;&#125;            // 指令解绑，当组件被销毁的时候触发            unbind(el,binding)&#123;&#125;        &#125;    &#125;&lt;/script&gt;&lt;!-- 使用 --&gt;    &lt;input type=&#x27;text&#x27; v-focus=&#x27;show&#x27;/&gt;\n全局directive 每次只能声明一个。\nVue.directive(&quot;hidden&quot;,&#123;    inserted(el,binding,vnode)&#123;        // binding.value是指令绑定入参        if(binding.value)&#123;            el.style.display=&quot;none&quot;        &#125;else&#123;            el.style.display=&quot;block&quot;        &#125;    &#125;&#125;)\n\n路由根据URL分配到对应的应用程序；作用就是解析URL，调用对应的控制器。简而言之，路由是指把数据从一个地方传送到另一个地方的行为和动作vue路由有助于在浏览器的URL或历史记录与Vue组件之间建立链接用法&lt;div&gt;    &lt;!-- 使用router-link组件来导航 --&gt;    &lt;!-- 通过传入`to`属性指定链接 --&gt;    &lt;!-- router-link 默认会被渲染成一个&lt;a&gt;&lt;/a&gt;标签 --&gt;    &lt;router-link to=&quot;/home&quot;&gt;home&lt;/router-link&gt;    &lt;router-link to=&quot;/news&quot;&gt;news&lt;/router-link&gt;&lt;/div&gt;&lt;!-- 路由出口 --&gt;&lt;!-- 路由匹配到的组件渲染在这里 --&gt;&lt;router-view&gt;&lt;/router-view&gt;\n[1.定义路由组件]:\n&lt;script&gt;     var Home = &#123; template: &#x27;#home&#x27;&#125;    var News = &#123; template: &#x27;#news&#x27;&#125;   &lt;/script&gt;    &lt;!-- 对应的模块内容： --&gt;    &lt;template id=&quot;home&quot;&gt;         &lt;div&gt;             &lt;h3&gt;组件home&lt;/h3&gt;         &lt;/div&gt;    &lt;/template&gt;    &lt;template id=&quot;news&quot;&gt;         &lt;div&gt;             &lt;h3&gt;组件news&lt;/h3&gt;         &lt;/div&gt;    &lt;/template&gt;\n\n[2.定义路由]：\n// router/index.js    const routes = [        &#123;path: &#x27;/home&#x27;, component: Home&#125;,        &#123;path: &#x27;/news&#x27;, component: News&#125;,         &#123;path: &#x27;/&#x27;, redirect: &#x27;/home&#x27;&#125;    ];    /*    路由命名：        有时候通过一个名称来标识一个路由显得更方便一些，特别是链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。    */   routes:[       &#123;           path: &#x27;/user/:id&#x27;,name: &#x27;user&#x27;,component: User       &#125;   ]\n\n[3.创建router实例]：\n// main.js    const router=new VueRouter(&#123;        routes,//(缩写)相当于 routes: routes        linkActiveClass: &#x27;active&#x27;// 链接激活时默认使用的css类名，用到linkActiveClass来配置，在路由的构造选项里配置默认类名为active    &#125;)\n\n[4.创建和挂载根实例]：记得要通过 router 配置参数注入路由，从而让整个应用都有路由功能\nwindow.onload=function()&#123;    new Vue(&#123;        el:`#my`,【        router    &#125;)&#125;\n\n设置路由导航的两种方式声明式 \n\n编程式router.push(‘&#x2F;home’)\n声明式的常见方式&lt;router-link :to=&quot;/home&quot;&gt;home&lt;/router-link&gt;&lt;!-- 对象 --&gt;&lt;router-link :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt;home&lt;/router-link&gt;&lt;!-- 路由通过名称 --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;homename&#x27;&#125;&quot;&gt;home&lt;/router-link&gt;&lt;!-- 直接路由带查询 --&gt;&lt;!-- 参数query，地址栏变成/home?id=10 --&gt;&lt;router-link :to=&quot;&#123;    path:&#x27;/home&#x27;,    query:&#123;id:10&#125;    &#125;&quot;&gt;    home&lt;/router-link&gt;&lt;!-- 命名路由带参查询query，地址栏变成/home?id=10 --&gt;&lt;router-link :to=&quot;&#123;    name:&#x27;homename&#x27;,    query:&#123;id:10&#125;    &#125;&quot;&gt;    home&lt;/router-link&gt;\n\n编程式常见方法\n字符串 router.push(‘&#x2F;home’)\n对象 router.push({path:’&#x2F;home’})\n路由通过名称 router.push({name:’homename’})\n直接路由带查询参数query,地址栏变成&#x2F;home?id&#x3D;10\n\nrouter.push(    &#123;        path:&#x27;home&#x27;,        query:&#123;id:10&#125;    &#125;)\n\n\n命名路由带查询query，地址栏变成&#x2F;home?id&#x3D;10\n\nrouter.push(    &#123;name:&#x27;homename&#x27;,    query:&#123;id:10&#125;&#125;)\n\n路由传参传入参数的方式方法1例：http://localhost:8080/user/10user\n\n路由配置const routes=[    &#123;path: &#x27;/home&#x27;, component: Home&#125;,    &#123;path: &#x27;/news&#x27;, component: News&#125;,     &#123;path: &#x27;/user/:id&#x27;, component: User&#125;,     //路由中定义http://localhost:8080/#/user/10 需要定义ID]\n\n方法2例：http://localhost:8080/home?id=10传入参数的方式：\n&lt;router-link :to=&quot;&#123;    path:&#x27;/home&#x27;,    query: &#123;id: id&#125;&#125;&quot;&gt;test&lt;/router-link&gt;\n\n路由中定义：user?id&#x3D;10 不需要在路由配置中定义参数\n常见路由对象在使用vue-router的应用中，路由对象会被注入每个组件中，赋值为this.$route，并且当路由切换时，路由对象会被更新，路由对象暴露了以下属性\n监听单个对象,默认开启深度监听\n扩展(AntV G6)[https://antv-g6.gitee.io/zh]AntV G6是一个图可视化引擎。它提供了图的绘制、布局、分析、交互、动画等基础能力。指让关系变得透明，简单。让用户获得关系数据的Insight(了解)。\n(AntV F6)[https://f6.antv.vision/zh]AntV F6是一个图视化引擎。可以去使用在H5、小程序等平台上，跟G6差不多一个pc一个移动端而已。\n","categories":["vue"],"tags":["面试题"]},{"title":"面试题","url":"/2023/08/28/%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"JavaScript普通函数与箭头函数的区别?\n箭头函数没有原型对象prototype\n箭头函数是匿名函数不能作为构造函数不能被new\n箭头函数不能当作Generator函数，不能使用yeild关键字。\n箭头函数不绑定arguments，取而代之用…rest参数解决\n箭头函数不绑定this，会捕获他所在上下文的this值，作为自己的this值\n箭头函数的 this永远指向其上下文的this ，任何方法都改变不了其指向，如 call() , bind() , apply()\n\nGenerator函数Generator函数也叫生成器函数是 ES6提供的一种异步编程解决方案Generator函数像一个状态机，保存了许多状态，并将这些状态作为遍历器对象返回为了和传统的函数区别，Generator函数function后面会跟着一个*号，函数内部通常有许多yield后跟着表达式表示状态。Generator函数特性1.传统的函数被调用后会立马执行，且一次执行到return结束，而Generator函数被调用时不会立马执行内部的语句，而是返回了一个遍历器对象，2.由遍历器对象的next()方法启动，遇到yield后又会暂停，直到下一个next()才会继续启动。Generator函数和构造函数的区别1.Generator 函数返回的遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法\nfunction* gen()\t&#123;\t\tyield 1;\t\tconsole.log(yield 2); // undefined\t\tyield 3;\t\treturn 4;\t&#125;\tlet ge=gen() //返回一个遍历器对象\tconsole.log(ge.next()) // &#123;value: 1, done: false&#125;\tconsole.log(ge.next()) // &#123;value: 2, done: false&#125;\tconsole.log(ge.next()) //  &#123;value: 3, done: false&#125;\tconsole.log(ge.next()) //  &#123;value: 4, done: true&#125;\tconsole.log(ge.next()) // &#123;value: undefined , done: true&#125;\n\n什么是Promise?promise是解决异步的方法。\n\nPromise对象有两个特点：\n1）对象的状态不受外界的影响。\n2）状态一旦改变，便不会再次改变。而且它的状态改变只会由（pending-&gt;fulfilled、pending-&gt;rejected）并且这两种情况只要发生其中一个，状态便固定了。\n\n\nPromise的优点：\n支持链式调用（可以将异步操作以同步的方式显示出来）避免回调地狱\n\n\n\npromise的使用场景?1.获取文件信息2.配合Ajax获取信息3.解决回调地狱，实现单行任务队列4.node中进行本地操作的异步过程\n什么是回调地狱？多层回调函数的相互嵌套 就形成了回调地狱缺点：    代码耦合性太强 牵一发而动全身 难以维护    大量冗余的代码相互嵌套 代码的可读性变差\n对this的理解？1.任何情况下直接在script中写入的this都指向window2.函数中的this在非严格模式下指向的是window，严格模式下是指向undefined3.箭头函数中的this都指向函数外上下文环境的this指向4.对象中的this指向对象外上下文环境的this5.回调中的this指向：①setTimeout，setInterval回调函数不管是不是严格模式都指向window②通过函数内执行当前回调函数和递归中的this，在非严格模式下指向的是window，严格模式下指向的是undefined③使用arguments执行函数时，this指向arguments④事件中的回调函数，this指向事件监听的对象6.call，apply，bind方法执行时，如果第一个参数传入的不是null或者是undefined，那么传入什么this指向什么；如果第一个参数传入的是null或undefined，非严格模式下this指向window7.ES6的类中 this的指向①构造函数中的this指向当前实例类所产生的实例对象②类中实例化方法中this指向 谁执行该方法，this指向谁③类中静态方法中this指向该类或者该类的构造函数④类中实例化箭头方法，this仍然指向当前类实例化的实例对象8.ES5的原形对象中的this指向在原型的方法中，this指向实例化当前构造函数的实例化对象，就是谁执行该方法，this就指向谁\n什么是事件循环事件循环机制就是一种同步编程模型，用于异步处理操作，当代码中遇到需要等待操作结果的语句时 js引擎不会一直等待，而是将该语句放入事件的队列中，并执行下一步语句，异步操作完成的时候，就会将其对应的事件加入到事件队列中\n事件循环机制的组成\n事件队列：  用来存储事件的队列，包括鼠标点击、键盘输入、定时器等等\n执行栈：  用来存储正在执行的代码\n宏任务：  指的是需要被放入事件队列中的任务，例如setTimeout&#x2F;setInterval等\n微任务：  指的是需要当前任务执行完成后立即执行的任务，例如Promise的then&#x2F;catch&#x2F;finally方法\n\n事件轮询的机制 也叫事件循环的机制（eventLoop）一个用来等待和发送消息和事件的程序结构。1、所有任务都在主线程上执行，形成一个执行栈。2、主线程发现有异步任务，如果是微任务就把他放到微任务的消息队列里，如果是宏任务就把他放到宏任务的消息队列里。3、执行栈所有同步任务执行完毕。4、执行微任务队列，之后再执行宏任务队列。5、以上步骤重复执行就是事件轮询\n\n宏任务：setInterVal setTimeout ajax\n微任务：promise async await .then\npromise优先于setTimeout，setTimeout回调函数最后执行，promise一旦被定义就会立即执行\n\n\n\nfor in和for of区别？\nfor  in 用于遍历对象的键，会遍历自身和原型链上的枚举属性 如果是数组将会把数组索引当做对象来遍历\n枚举属性是由enumerable值决定的，true为可枚举，false为不可枚举\n可枚举可以理解为是否可以被遍历\nJS中预定义的原型属性一般是不可枚举的，而自己定义的属性一般可枚举\n可以通过propertyIsEnumerable方法判断该属性是否可枚举\nfor of和forEach一样,是直接得到值\nfor of不能用于对象\n\nnew一个对象的过程？\n在堆内存中申请了一块空间 创建一个新对象\n将新对象的__proto__指向构造函数中的原型对象prototype\n新对象会绑定到函数调用的this(比如：实例对象捕获构造函数的this当做自己的this)\n执行构造函数中的代码（为这个新对象添加属性）\n返回新对象。| 将初始化完毕的新对象地址，保存到等号左边的变量中\n\n什么是闭包？能够读取外层函数内部变量的函数\n\n当内层函数调用外层函数的变量或参数时产生闭包1.访问作用域2.函数嵌套3.在作用域外被调用\n闭包的优点：只有函数内部的子函数才能读取局部变量,可以避免全局污染(避免全局污染)\n闭包的缺点：变量常驻内存，得不到释放会使内存持续增压，导致内存泄漏使用场景1.setTimeout2.回调3.函数防抖\n\n什么是堆内存和栈内存？堆内存是一种非连续的树形存储数据结构，每个节点有一个值栈内存是一种连续存储数据结构，具有先进后出的性质\n\n堆主要用于存放复杂类型的变量\n\n堆是先进先出\n空间较大\n堆的申请和释放是由程序员控制的，容易产生内存泄漏\n\n\n栈主要是存储基本类型的变量\n\n栈是先进后出\n空间较小\n栈是由系统自动分配释放\n栈的效率高\n\n\n\n节流和防抖？防抖是连续触发的事件，只会执行最后一个节流是每隔一段时间触发一次实现防抖通过定时器实现节流通过时间戳\n\n使用场景  防抖：  search搜索时，用户在不断输入值时，用防抖来节约请求资源。  登陆，发短信（倒计时），防止用户点击过快，以至于发送多次请求  节流：  鼠标不断触发某事件时,如点击,只在单位事件内触发一次.  懒加载时要监听计算滚动条的位置,但不必要每次滑动都触发,可以降低计算频率,而不必要浪费CPU资源.\n\n哪些数组方法可以改变原数组？shift()  unshift()  pop()  reverse()  sort()  splice()  push()\n虚拟DOM本质上就是一个JS对象，当数据发生变化时，我们不直接操作真实DOM，因为很昂贵，我们去操作这个JS对象，就不会触发大量回流重绘操作，再加上diff算法，可以找到两次虚拟DOM之间改变的部分，从而去一次性更新真实DOM 性能得到了大大的提升 \n谈一谈垃圾回收机制?js它具有自动回收机制 就是对那些不再用的变量对象进行回收 进行空间的释放\n\n回收的两种机制  1.标记清除 当它进入执行环境的时候 它会被打上进入环境 离开的时候再被打上离开环境 被打上离开环境标记的都会被清除掉  2.引用计数\n原理就是 垃圾收集器会定时找出那些不继续使用的变量 然后释放其内存 因为如果内存开销比较打 他的GC会停止响应其他操作 他会阻塞其他应用程序的执行垃圾回收是按照固定时间 周期性的去执行的\n\nless 和 sass 的区别 ?相同点：Sass和Less都是一种CSS预处理器区别：\n\nLess在JS上运行，Sass在Ruby上使用；\n两者编写变量的方式不同；  变量定义符不一样，less用的是@，而sass用$。\n在Less中仅允许循环数值，而在Sass中可以遍历任何类型的数据；\nSass有Compass，Less有Preboot。\n\nCSS预处理器是什么？CSS预处理器是一种脚本语言，用一种专门的编程语言来进行Web页面的样式设计，然后再转换为正常的CSS样式，进而实现构建动态CSS样式。CSS 预处理器为 CSS 增加了一些编程的特性，无需考虑浏览器的兼容性问题。\n纯函数就是一个函数的返回结果只依赖于它的参数，并且在执行过程中没有副作用，我们就把这个函数叫做纯函数。（redux中的reducer就是纯函数）优点：\n\n可复用性 纯函数仅依赖于传入的参数，这意味着你可以随意将这个函数移植到别的代码中，只需要提供他需要的参数即可\n可测试性 纯函数非常容易进行单元测试，因为不需要考虑上下文环境，只需要考虑输入和输出。\n并行代码 纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行。\n\n\n浏览器的同源策略机制?同源策略，指的是浏览器限制当前网页只能访问同源的接口资源。所谓同源 两方必须是同协议、且同域名、且同端口。只要有一个不相同，则会受到浏览器的约束，不允许请求。\ntoken一般存放在哪里?为什么不存放在cookie内?首先有两个存放位置一个是本地存储 另一种是cookie但是两种都有缺点存在本地存储中 这意味着任何在你的网站上的运行的JavaScript都可以访问，所以容易受到XSS攻击如果存在cookie内的话，浏览器的请求默认会在请求头中携带cookie，所以容易受到csrf攻击我的意见是 放到本地存储中撇开localStorage的各种优点不谈，如果做好适当的XSS防护，收益是远大于风险的。因为localStorage具有更灵活，更大空间，天然免疫 CSRF的特征。Cookie空间有限，而JWT一半都占用较多字节，而且有时你不止需要存储一个JWT。\n\nCSRF攻击简单的说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如：发邮件、发信息、甚至财产操作如转账和购买商品）\nXSS攻击是一种代码注入攻击。攻击者通过在目标网站注入恶意脚本，在用户的浏览器上运行。利用这些恶意脚本，攻击者可以获取用户的敏感信息如Cookie、SessionID等，进而危害数据安全。\n\ntoken是什么token其实就是访问资源凭证 一般在用户成功登陆后 服务器将登陆凭证做数字签名 加密后的字符串作为token\n如何实现一条0.5像素的线方法一： 定位+缩放利用的是 transform 缩放功能，将 1px 缩放一半，同时利用定位，将伪元素覆盖整个 div 元素，从而达到伪元素与本身元素的合并效果。\n方法二： box-shadow利用的是 box-shadow 的扩散半径可以设置为 0.5px 原理方法三： 直接使用border属性\nborder: 0.5px solid #f00;\n\n构造函数\n用new关键字来调用定义的函数，称为构造函数。默认返回的是一个新对象，这个新对象具有构造函数定义的变量和函数以及方法\n\nasync&#x2F;awaitasync&#x2F;await 是ES7提出的基于Promise的解决异步的最终方案。async、await使用 async&#x2F;await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性 async用于申明一个function是异步的 而await用于等待一个异步方法执行完成\ntransform的属性none：不转换。matrix(mei chui ke si)(n,n,n,n,n,n)：定义2D转换，使用六个值的矩阵。matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义3D转换，使用 16 个值的 4x4 矩阵。translate(x,y)：定义2D转换。translate3d(x,y,z)：定义3D转换。translateX(x)：X轴转换translateY(y)：Y轴转换translateZ(z)：Z轴3D转换scale(si gei o)(x,y)：定义2D缩放scale3d(x,y,z)：定义3D缩放scaleX(x)：X轴缩放scaleY(y)：Y轴缩放scaleZ(z)：Z轴3D缩放rotate(angle)：定义2D旋转rotate3d(x,y,z,angle)：定义3D旋转。rotateX(angle)：X轴的3D旋转rotateY(angle)：Y轴的3D旋转rotateZ(angle)：Z轴的3D旋转skew(x-angle,y-angle)：定义2D倾斜skewX(angle)：X轴的2D倾斜skewY(angle)：Y轴的2D倾斜\nIE盒模型和标准盒模型\nIE怪异盒子模型(怪异盒)的元素宽度width&#x3D;content+padding+border\n标准盒模型(普通盒模型)的元素宽度width&#x3D;content+padding+border+margin\n\ncss实现三角形.box&#123;border-left:100px solid red;border-right:100px solid transparent;border-bottom:100px solid transparent;    &#125;\n\naxiosAxios是一个基于promise封装的http请求库特点:1、可以转换请求数据和响应数据，会把响应回来的数据转成 JSON类型的数据；2、拦截请求和响应（相当于给请求加条件）；3、axios.all(promises): 批量发送多个（异步）请求；4、axios在浏览器端&#x2F;node 端都可以使用5、安全性更高\nJQ中$()符叫做jQuery的构造函数。\n$()就是jQuery()，在里面可以传参数，作用就是获取元素。\n\n普通函数和构造函数的区别构造函数：\n\n调用方式不一样 new Fn()\n构造函数内部会创建一个新的对象，构造函数new出来的实例\n函数内部的this指向 构造函数new出来的实例\n默认的返回值是构造函数new出来的实例，return 返回基本类型无效,引用类型有效普通函数：\nfn()\n在函数的内部不会创建新的对象\n函数内部的this指向调用函数的对象（如果没有对象调用，默认是window）\n返回值由return语句决定\n\n浮动与定位float只是行内的 左右的改变，如果后面的元素不清除浮动(clear:both)的话 会影响后面元素的位置，而positon定位的影响比较广，既能定义一个容器的定位也能定义一个容器里面的任意定位\n递归函数递归就是一个函数在它的函数体内调用它自身。执行递归函数将反复调用，每调用一次就进入新的一层。递归函数必须有结束条件。优点：代码简洁。缺点：1、时间和空间的消耗比较大2、重复计算3、栈溢出\nlabel标签 标签为input元素定义标注 当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。\najax执行步骤1.首先创建一个XMLHttpRequest异步对象2.然后使用open设置请求方式和请求地址3.用send发送请求4.监听状态变化5.接收返回的数据\nWebSocket在websocket之前诞生的有轮询(客户端定期向服务器发送请求)长轮询(在客户端发出请求后，保持连接打开，等待新数据响应后在关闭连接)Comrt(保持长链接，在返回请求后保持连接打开)\n\nWebSocKet优势\n适用基于web的游戏，聊天应用以及低延迟的实时连接的应用程序\n双向实时通信\n允许在单个、长时间的连接上进行双向实时通信。在需要快速实时更新的程序里，比HTTP更加高效\n\n\n降低延迟\n连接一旦建立便会保持开放，数据可以再客户端和服务器之间比HTTP更底的延时传输\n\n\n更高效的资源利用\n可以减少重复请求和响应的开销，因为它的连接只需要建立一次\n\n\n\n\nWebSocKet常见库\njavascript库-SocKet.IO\nc#库-SignalR &amp; SuperWebSocket\nPython库-tornado.websocket &amp; autobahn\nJava库-javax.websocket &amp; Jetty\n\n\n\n最后一个元素选中css:last-child\n统计字符串中出现最多的字母let str = &#x27;aabbbccdd&#x27;    function getChar(str) &#123;    if (typeof str !== &#x27;string&#x27;) return // 判断参数是否为字符串    const obj = new Object() // 键为字母，值为次数\tfor (let i = 0; i &lt; str.length; i ++) &#123; // 遍历字符串每一个字母\t\tlet char = str.charAt(i) // 当前字母\t\tobj[char] = obj[char] || 0 // 保证初始值为0\t\tobj[char] ++ // 次数加1\t&#125;    console.log(obj)\tlet maxChar // 存储字母\tlet maxNum = 0 // maxChar字母对应的次数\tfor(let key in obj) &#123; // 遍历obj\t\tif (obj[key] &gt; maxNum) &#123;            maxChar = key // 比较后存储次数多的字母            maxNum = obj[key] // 以及它对应的次数        &#125;\t&#125;\treturn maxChar // 返回结果&#125;console.log(&#x27;出现次数最多的字母为：&#x27; + getChar(str))\n\n自执行函数\n属于匿名函数,直接调用;\n在初次加载的时候，会执行一次(自执行函数只能执行一次)\n自执行函数会形成一个独立的作用域优点:将全局变量写在立即执行函数里，作为局部变量，防止变量污染全局(避免多次声明造成变量覆盖)缺点:不能重复调用\n\n数组 对象区别创建方式不同：数组表示有序数据的集合，而对象表示无序数据的集合调用方法不同对象键值唯一，数组可以重复对象没有长度，不能用for循环\n元素绑定事件1、在HTML上绑定点击事件2、使用js获取元素并添加绑定事件\n&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn&quot;).onclick = function()&#123;alert(&quot;hello world!&quot;);&#125;&lt;/script&gt;\n3、事件侦听注册事件 addEventListener\n&lt;body&gt;&lt;button&gt;方法监听注册事件&lt;/button&gt;&lt;script&gt;var btn = document.querySelector(&#x27;button&#x27;);btn.addEventListener(&#x27;click&#x27;, function () &#123;    alert(22);&#125;)&lt;/script&gt;&lt;/body&gt;\n4、jQuery 绑定事件使用click 要引入jquery.js\n$(&quot;button&quot;).click(function()&#123;&#125;);\n\n\n数组拉平\n递归\n原始数组.flat();\n\npostion属性的值有哪些static(si da tei ke)：默认值，元素没有开启定位relative:元素的相对定位,以自身为参照物absolute:元素的绝对定位，以开启了定位的祖先元素为参照物fixed(fei ke si te):元素的固定定位\n静态方法 实例方法和原型方法\n静态方法\n定义在构造函数上的方法\n只能被构造函数访问\n\n\n实例方法\n构造函数中this上添加的属性都属于实例属性\n只能被实例对象访问\n\n\n原型方法 是共享的方法\n通过构造函数的prototype定义的方法\n能被实例直接访问，构造函数需通过prototype才可访问\n\n\n\ndocumentFragmentdocumentFragment是一个保存多个element的容器对象（保存在内存）当更新其中的一个或者多个element时，页面不会更新。只有当documentFragment容器中保存的所有element更新后再将其插入到页面中才能更新页面。documentFragment用来批量更新\n创建对象的方式- 利用字面量创建对象    优点：简单方便\t缺点：无法量产    var obj = &#123;        uname: &#x27;张三疯&#x27;,        age: 18,        sex: &#x27;男&#x27;,        sayHi: function () &#123;            console.log(&#x27;hi~&#x27;);        &#125;    &#125;\t- 使用对象。\t\t调用对象的属性，我们采取对象名.属性名\t\t\tconsole.log(obj.uname);\t\t调用属性另一种方法 对象名[&#x27;属性名&#x27;]\t\t\tconsole.log(obj[&#x27;uname&#x27;]);\t\t调用对象的方法对象名.方法名( )\t\t\tobj.sayHi();//千万别忘记加上函数的小括号- 利用new Object创建对象    通过这种方式，我们可以调用任意的构造函数(无参的和带参数的)    var obj = new Object();//O要大写        obj.uname = &#x27;张三疯&#x27;;        obj.age = 18;        obj.sex = &#x27;男&#x27;;        obj.sayHi = function () &#123;            console.log(&#x27;hi~&#x27;);        &#125;        console.log(obj.uname);        console.log(obj.age);        console.log(obj[&#x27;sex&#x27;]);        obj.sayHi();        利用等号赋值的方法添加对象的属性和方法        每个属性和方法之间用分号结束- 利用构造函数创建对象\t构造函数的语法格式    //创建        function 构造函数名() &#123;            this.属性 = 值;            this.方法 = function () &#123;            &#125;        &#125;        //调用        new 构造函数名();        // 使用\t\tconsole.log(new 构造函数名().属性)- 使用Class类的newInstance方法    这个方法调用无参的构造函数创建对象。- 使用Constructor类的newInstance方法    这个方法调用有参数的和私有的构造函数。- 使用clone方法    当我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。- 使用反序列化    当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。\n\n本地对象 内置对象 宿主对象\n本地对象与宿主无关，无论在浏览器还是服务器中都有的对象，就是ECMAScript标准中定义的类(构造函数)在使用过程中需要我们手动new创建  Object、Function、Array、String、Boolean、Number、Date\n内置对象与宿主无关，无论在浏览器还是服务器中都有的对象 ECMAScript已经帮我们创建好的对象 在使用过程中无需我们动手new创建  Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）\n宿主对象浏览器提供的对象。所有的BOM和DOM都是宿主对象什么是宿主？宿主就是指JavaScript运行环境，js可以在浏览器中运行，也可以在服务器上运行(nodejs)对于嵌入到网页中的js来说，其宿主对象就是浏览器，所以宿主对象就是浏览器提供的对象所有的BOM和DOM都是宿主对象\n\nSPA​ SPA（Single Page Application）单页面应用程序，页面内容的变化通过ajax局部更新实现，同时支持浏览器地址栏的前进与后退操作，又称单页面多视图。其实现原理是基于url地址的hash变化，hash改变会导致浏览器访问记录的改变，但不会触发新的url请求。SPA最核心的技术点就是前端路由。优点：\n\n良好的交互体验 内容的改变不会重新加载页面 页面数据通过ajax异步获取 没有页面之间的跳转 不会出现跳转白屏的现象\n良好的前后端分离工作模式 前端只需要专注于页面的渲染 更利于前端工程化的发展 后端只需要专注于API接口的提供 更易实现API接口的复用\n减轻服务器的压力 服务器只提供数据不负责页面的合成和逻辑的处理 吞吐能力提高几倍缺点：\n首屏加载慢 解决方案 路由懒加载 CDN加速 代码压缩 网络传输压缩\n不利于SEO(搜索引擎优化) 解决方案：SSR服务器端渲染\n\nJQ链式调用.:用于链式调用  jq方法的返回值,除了获取,几乎均返回jq对象链式调用是通过return this的形式来实现的；通过对象上的方法，最后加上return this，把对象再返回来，对象就可以再继续调用方法，实现链式操作了；\n\njq中链式结构断开怎么办？用end()  end() 方法结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态。\n\n链式调用的好处：节省代码量，代码看起来更优雅链式调用的问题：所有对象的方法返回的都是对象本身，也就是说没有返回值，所以这种方法不一定在任何环境下都适合。\n网页渲染过程1.解析HTML文件，构建 DOM Tree(dom树)2.解析CSS，构建 CSSOM Tree(CSS规则树)3.将 DOM Tree 和 CSSOM Tree合并，构建Render tree(渲染树)4.reflow(重排)：根据Render tree计算节点信息（Layout）5.repaint(重绘)：根据计算好的信息绘制整个页面（Painting）\n获取元素属性innerHTML、outerHTML、innerText 、outerText、value 属于原生javascript的方法。  text()、html()，val()属于jQuery中的方法。\n回调函数函数当作参数传递函数当作返回值返回回调函数就是一个通过函数指针调用的函数\ncss权重Css的权重是指样式的优先级内联样式，权重值为1000ID选择器，权重值为100类、伪类，权重值为10标签选择器，权重为1\ndelete与vue.deletedelete只是将删除的元素变成了undefined 其他的元素的键值还是不变。数组长度也不变。Vue.delete是直接删除该元素，也改变了数组的键值，长度发生变化。\n盒子模型包括：外边距,边框,内边距,和实际内容。Margin（外边距）Border（边框）Padding（内边距）Content（内容）\njavaScript的组成ECMAScript：描述了JS的语法和基本对象。DOM：处理网页内容的方法和接口BOM：与浏览器交互的方法和接口\nJSON方法JSON 指的是 JavaScript 对象表示法JSON 是轻量级的文本数据交换格式JSON 具有自我描述性，更易理解JSON.stringify() 我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。JSON.parse() 我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。\nhttp状态码1、200 ：请求成功2、204： 服务器成功处理了请求，但没有返回任何内容。3、301： 请求的网页已永久移动到新位置。。4、302： 请求的网页临时移动到新位置。5、400： 服务器不理解请求的语法。6、403： 服务器拒绝请求。7、404： 服务器找不到请求的网页。8、410 ：请求的资源永久删除9、500 ：服务器遇到错误10、503： 服务器目前无法使用\n最后一个圆角ul li:last-child/:nth-last-child(1)||(正数):first-child/:nth-first-child(1)&#123;\tborder-radius:50%;&#125;\n\ndocument.reday与window.onload的区别document.reday表示文档结构已经加载完成 不包含图片等非文字媒体文件window.onload表示包含图片等文件的所有元素都加载完成。\nif有作用域吗\n只有函数有作用域，if是没有作用域的。\n但是有一种情况会让if看上去有作用域，就是在if {}语句中，使用const、let，他们会有块级作用域。(因为const、let才拥有块级作用域 )\n\n\n\najax生命周期&#x2F;状态0 初始化xhr 请求对象1 与服务器建立链接并开始向服务器发送请求2 服务器已经接受请求3 处理请求4 请求已处理完成,响应就绪,js可以在此阶段获取数据\n同步异步同步，执行完函数或方法后，需要等待系统返回值或消息，这时程序是阻塞的，必须接收到返回的值或消息后才往下执行其他的命令。异步，执行完函数或方法后，不必等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。\n会话cookie和持久cookie如果 cookie 不包含到期日期，则可视为会话 cookie。 会话 cookie 存储在内存中，决不会写入磁盘。 当浏览器关闭时，cookie 将从此永久丢失。如果 cookie 包含到期日期，则可视为持久性 cookie。 在指定的到期日期，cookie 将从磁盘中删除。\n\ncookie过期时间设置方式： -  cookie.setMaxAge(0);&#x2F;&#x2F;不记录cookie -  cookie.setMaxAge(-1);&#x2F;&#x2F;会话级cookie，关闭浏览器失效  –会话cookie -  cookie.setMaxAge(60*60);&#x2F;&#x2F;过期时间为1小时 –持久cookie\n\ntypeof返回值是以字符串的形式返回你查看的这个值是什么类型的typeof可以判断类型也有六种，分别是：    number    string    Boolean    object    undefined    function检测array返回object检测null返回object检测NaN返回number\n获取时间1、获取当前的日期和时间方法：new Date()2、获取当前日期new Date().toLocaleDateString()3、返回当前时间new Date().toLocaleTimeString()4、从Date()对象返回当前 年份new Date().getFullYear()5、从Date()对象返回当前 月份new Date().getMonth()+16、从Date()对象返回月份的当前 日new Date().getDate()7、从Date()对象返回星期几new Date().getDay()8、从Date()对象的 当前 小时new Date().getHours()\nurl请求过程十步版  请求报文   响应报文1.在浏览器地址栏中输入网址。2.浏览器通过用户输入的URL构建HTTP请求报文。3.浏览器发起DNS（寻址）解析，将域名转换为IP地址。4.浏览器将请求报文发送给服务器。5.服务器接收请求报文（request），并解析。6.服务器处理用户请求，并将处理结果封装成HTTP响应报文（response）。7.服务器将HTTP响应报文发送给浏览器。8.浏览器接收服务器响应的HTTP响应报文，并解析。9.浏览器解析 HTML 页面并展示10.最终浏览器展示出了页面。完整版：    1.DNS 解析：将域名地址解析成 IP 地址    按照以下顺序进行 DNS 解析：        Browser DNS cache（浏览器 DNS 缓存）        OS DNS cache（系统 DNS 缓存）        Router DNS cache（路由器 DNS 缓存）        ISP DNS cache（网络运营商 DNS 缓存）        Recursive search（递归搜索）（若以上 4 种都未找到，则会进行 Recursive search）    2. TCP 连接：TCP 三次握手        第一次握手：由浏览器发起，告诉服务器我要请求数据        第二次握手：由服务器发出，告诉浏览器我准备好接受数据了，你可以发送请求了        第三次握手：由浏览器发出，告诉服务器我马上就发，你准备接受    3. 发送 HTTP 请求&#x2F;处理请求：请求报文    4.  接受响应：响应报文    5.  浏览器解析、渲染页面    6.  断开连接：TCP 四次挥手        第一次挥手：由浏览器发器，发送给服务器，我东西发完了（请求报文），你准备关闭吧        第二次挥手：由服务器发器，告诉浏览器，我东西接受完了（请求报文），我准备关闭了，你也准备好        第三次挥手：由服务器发器，告诉浏览器，我东西发送完了（响应报文），你准备关吧        第四次挥手：由浏览器发器，告诉服务器，我东西接受完了，我准备关了，你也准备好吧\n数据类型基本数据类型-&gt;string、number、Boolean、null、undefined、symbol引用数据类型-&gt;array、object、function基本数据类型是保存在栈内存中，操作的是值，改变源数据不会影响新的变量引用数据类型保存在堆内存中，操作的是地址，改变其中一个会影响另一个\n回流和重绘改变某个元素的结构之后，会重新绘制元素的样式(重绘)，此时会引起浏览器重绘\n\n改变页面布局之后，会发生回流布局重新排列，(回流会引起重绘，但是重绘不会引起回流)\n\n如何减少回流和重绘\n1.浏览器中的优化机制浏览器会维护一个队列，队列中存放的是会触发回流和重绘的操作，当队列中的操作达到一定阀值或者到了一定的时间间隔时，浏览器就会清空队列，进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。\n\n2.自己进行优化使用className。集中修改样式使用定位让元素脱离文档流。在设置display:none;的元素上操作，最后显示出来使用文档片段(document fragment)，在当前DOM外构建一个子树，在它上面操作所有DOM，再把它拷贝回文档。\n\n\nGET 和 POSTGET把参数包含在URL中，POST通过request body传递参数。GET在浏览器回退时是无害的，而POST会再次提交请求。GET请求只能进行url编码，而POST支持多种编码方式。GET请求参数会被保留在浏览器历史记录里，而POST中的参数不会被保留。GET请求在URL中传送的参数是有长度限制的，而POST没有。对参数的数据类型，GET只接受ASCII字符，而POST没有限制。GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\n内存泄漏1）意外的全局变量引起的内存泄漏原因：解决：可以使用严格模式避免全局变量，不会被回收\n2）闭包引起的内存泄漏原因：闭包可以维持函数内局部变量，使其得不到释放解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对dom的引用\n3）没有清理的DOM元素引用原因：对象中还存在对dom的引用解决：手动删除即可\n4） 忘记的定时器或者回调原因：定时器中有dom的引用，即使dom删除了，但是定时器还在解决：手动清除定时器和dom\n深拷贝\n深拷贝拷贝的是键和值深拷贝会开辟一个新的栈，新对象跟原对象不共享内存，修改新对象不影响原对象深拷贝实现方式：JSON.parse(JSON.stringify())、手写递归、jquery的$.extend\n\n浅拷贝拷贝出来的目标对象的指针和源对象的指针指向的是同一块内存空间，Object.assign(目标对象，源对象)\n继承原型链继承(通过改变原型的指向实现继承)    - 缺点：        1、不能传递参数，        2、如果父类的属性是引用类型，子类实列修改了该属性，其他的子类实列会共享该属性。借用父级构造函数实现继承(通过call修改this指向)(不会继承prototype)    - 缺点：        1、子类无法继承父类在原型链上的属性和方法。        2，每个实例都拷贝一份，占用内存大，尤其是方法过多的时候 (函数复用又无从谈起了，本来我们用prototype就是解决复用问题的)    - 优点：    1、解决了子类实列修改了父类属性，其他的子类实列会共享该属性的问题组合继承(原型链继承+借用构造函数继承)    组合继承是js最常用的继承模式，    - 缺点：        1、组合继承最大的问题就是无论在什么情况下，都会调用两次构造函数：一次是在创建子类型原型时，另一次是在子类构造函数内部。寄生组合继承(常用)    - 寄生组合继承就是避免两次调用父类构造函数，通过赋值直接继承父类的原型\n事件冒泡事件冒泡：当某个元素的某类型事件被触发时（如 onclick），它父级的同类型事件也会被触发，它的父级的父级同类型事件也会被触发，以此类推，一直触发到根元素。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。\nH5新标签新增的语义化布局标签\n\nheader和footer(fu te)标签：页面中一个内容区块的头部和尾部布局；\nnav：导航区域；\narticle(a ti ke)标签：页面中独立的内容部分布局；\naside(e sai de)标签：在独立内容之外，但是又与article有关联的部分布局；新增媒体标签\naudio(o diu)（音频）；\nvideo(v diu)（视频）；新增canvas和svg绘画元素\ncanvas表示位图区域；\nsvg定义矢量图；新增表单增强元素表单元素 input 的 type 属性扩充：(下面都属于type的类型)date（输入日期）；email（输入邮件）；url（输入url地址）；search（呈现搜索常规的文本域）；range（输入一定范围内的数值）；month（输入月份）；color（颜色）；number（输入数值）；以及表单元素 input 通过属性进行表单验证：required（必填项）、pattern（验证表单输入）。\n\n浏览器内核浏览器内核又可以分成两部分：渲染引擎和JS引擎渲染引擎：负责获取网页的内容并显示JS引擎：负责解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果\n\n常用内核(内核种类很多) (怎么分析内核)  常见浏览器内核可以分这四种：Trident(拆呢te(IE内核))、Gecko(带构(火狐))、Blink(be(四声)琳ke(谷歌))、Webkit(web凯te(谷歌))1、IE浏览器内核：               Trident内核，也是俗称的IE内核；2、Chrome浏览器内核：           是Blink内核；3、苹果Safari浏览器内核：       Webkit内核，5、搜狗、QQ浏览器内核：         Trident（兼容模式）+Webkit（高速模式）；6、百度浏览器：                 IE内核\n\n跨域为什么有跨域，因为有同源策略      同源策略：同源策略是一种约定，它是浏览器最核心也最基本的安全功能当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域\n异步加载jsdefer(script标签中增加defer属性，异步加载)：    但要等dom文档全部解析完（dom树生成）才会被执行。    只有IE能用；async(script标签中增加async属性，异步加载):    加载完就执行;async只能加载外部脚本    不能把js写在script标签里。    .w3c标准，IE9以下不支持封装一个函数兼容性的异步加载js文件并且可以按需执行该文件里面的函数（按需加载）\npx，em和rem的区别1、px代表像素，呈现的大小和屏幕分辨率有关系，分辨率越高元素尺寸越小，分辨率越低尺寸约大；2、em是相对于父元素大小的相对尺寸；3、rem是元素相对于根元素html的相对尺寸；4、所有浏览器默认的字体大小是16px；\nlink和@import的区别1、link属于XHTML标签，而@import完全是CSS提供的一种方式。2、加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。3、兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。\n性能优化1.1.1 雪碧图雪碧图是根据css sprite(si bai te)音译过来的，就是将很多小图标放在一张图片上就称之为雪碧图，可以减少网站http请求数量，不过随着字体图片、svg图片的流行该技术慢慢退出了舞台\n1.1.2 Base64将图片的内容以Base64格式内嵌到HTML中，可以减少http请求数量，但是编码之后的大小比图片大了\n1.1.3 使用字体图标来代替图片1.2 减少重定向尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验如果一定要使用重定向的话，如http重定向到https，要使用301永久重定向，而不是302临时重定向，因为如果使用302则每一次访问http都会重定向到https页面，而永久重定向在第一次从http重定向到https之后，每次访问http，会直接返回https的页面\n1.3 使用缓存使用cache-control或expires这类强缓存的时候，缓存不过期的情况下不会向服务器发起请求。强缓存过期的时候，会使用last-modified或etag这类协商缓存向服务器发起请求，如果资源没有变化，则服务器返回304响应，浏览器继续从本地缓存加载资源，如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回200\n1.4 不使用css@import使用css@import会造成额外的请求\n1.5 避免使用空的src和hrefa标签设置空的href，会重定向到当前页面的地址form设置空的method，会提交表单到当前页面的地址\n2.1 html压缩html代码压缩就是压缩在文本文件中有意义，但是在html中不显示的字符，包括空格，制表符\n2.2 css压缩css压缩包括无效代码删除与css语义合并\n2.3 js压缩与混乱js压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码的可读性、实现代码的保护\n2.4 图片压缩\n3.1 使用CDNCDN是内容分发网络，它能够实时地根据网络流量和各个节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，其目的是使用户可以就近的取得所需内容，解决网络拥挤的状况，提高网站的响应速度\n3.2 使用DNS预解析当浏览器访问一个域名的时候，需要解析一次DNS,获得对应域名的ip地址，在解析过程中，按照浏览器缓存、系统缓存、路由器换算、DNS缓存、域名服务器的顺序，逐步读取缓存，直到拿到ip地址\n3.3 持久连接使用keep-alive或者persistent来建立持久连接，降低了延时和连接建立的开销\n4、优化资源加载4.1 资源加载位置通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使用功能可用1、css文件放在head中，先外链，后本页2、js文件放在body底部，先外连，后本页3、处理页面、处理页面布局的js文件放在head中，如babel-polyfill.js文件、flexible.js文件4、body中尽量不写style标签和script标签\n4.2 资源加载时机1、异步script标签defer：异步加载，在html解析完成后执行。defer的实际效果与将代码放在body底部类似async：异步加载，加载完成后立即执行2、模块按需加载在SPA等业务比较复杂的系统中，需要根据路由来加载当前页面所需要的业务模块按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积\nwebpack提供了两类技术，优先选择的方式是使用符合ECMAScript提案的import语法，第二种就是使用webpack特定的require.ensure\n3、使用资源预加载preload和资源预读取prefetchpreload让浏览器提前加载指定资源，需要执行时候再执行，可以加快当前页面的加载速度prefetch告诉浏览器加载下一个页面可能会用到的资源，可以加速下一个页面的加载速度4、资源懒加载与资源预加载资源延迟加载也称为资源懒加载，延迟加载资源或符合某些条件的时候才加载某些资源资源预加载是提前加载用户所需的资源，保证良好的用户体验资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不能操作，浏览器空闲的时候再加载资源，优化了网络性能\nimg 中 title和alt区别图片中的 alt属性是在图片不能显示时出现的文本提示。alt有利于SEO优化图片中的 title属性是在鼠标在移动到图片上的文本提示。\nDOM与BOM分别是什么？DOM是文档对象模型    它指的是把文档当作一个对象来对待，提供访问和操作网页内容的方法和接口    - 方法：    document.head  获取一个html的head部分    document.body  获取一个html的body部分    document.innerHTML 获取标签    document.innerText 获取文本    document.querySelector 获取元素    document.getElementById 根据id获取元素    onclick 点击事件    addEventListener 点击事件BOM是浏览器对象模型    它指的是将浏览器当作一个对象来对待，提供与浏览器交互的方法和接口    - 方法    prompt  显示可提示用户输入的对话框    alert  显示带有一个提示信息和一个确定按钮的警示框    confirm  显示一个带有提示信息、确定和取消按钮的对话框    close  关闭浏览器窗口    open  根据给定的url打开一个新的浏览器窗口    setTimeout  在指定的毫秒数后调用函数或计算表达式    setInterval  按照指定的周期（以毫秒计）来调用函数或表达式\n数组去重一、利用ES6 Set去重（ES6中最常用）二、利用for嵌套for，然后splice去重（ES5中最常用）三、利用filter配合indexOf去重四、利用sort()五、利用includes六、利用递归去重\n区分数组对象1.通过constructor2.通过Object.prototype.toString.call()3.通过instanceof4.ES5特地新增isArray()检测变量是否是数组\n反转字符串第一种：字符串转数组，反转数组，数组转字符串。split(“”)：根据空字符串拆分数组reverse()：数组反转元素位置join(“”)：数组转回字符串,且不带分隔符\n第二种：定义新的空字符串，遍历str，通过charAt()是取字符串的最后一个字符，再取倒数第二个…以此类推。都放到新的字符串前面。这样就是倒序的了\n事件委托事件委托，又称事件代理，不是直接给标签添加事件 是给标签的父级添加事件 通过事件对象判断触发事件的标签是谁 执行不同的事件处理函数\n原型对象和对象的原型原型对象prototype 是创建函数 js引擎自动创建的对象对象的原型__proto__ 是实例化对象的原型 会自动继承原型对象中的属性\n形参和实参是什么？实参可以是常量、变量、表达式、函数等，在进行函数调用时，它们都必须有确定的值。通常将函数处理的数据，影响函数功能的因素或者函数处理的结果作为形参。实参是用来填充形参的funcation a(b){var x&#x3D;b;}a(‘zs’)b是形参，’zs’为实参\narguments是什么？arguments是一个对应于传递给函数的参数的类数组对象。类数组：是数组的形式，有length，但不具有数组的一切方法。作用：可以用arguments 对象判断传递给函数的参数个数并获取参数\n\n\n解决跨域的方法第一种方法    在后端服务器设置 请求头 res.setHeader(“Access-Control-Allow-Origin”,”*”)第二种方法    允许指定源访问        let arr=[&quot;浏览器请求路径&quot;]    if(arr.includes(req.headers.origin))&#123;        res.setHeader(&quot;Access-Control-Allow-Origin&quot;,req.headers.origin)    &#125;注意:谷歌浏览器不允许本地file文件load 右键谷歌浏览器--设置--目标：加上&quot;--allow-file-access-from-files&quot;注意前面有空格第三种方法    后端中下载插件 npm i cors    然后引入    const cors=require(&quot;cors&quot;)app.use(cors())第四种方法    在前端通过script标签解决跨域问题    Script src link 都不受同源策略的影响    可以直接    缺点：    1、不能接收JSON数据 只能接收js代码 前端通过变量或者是函数名来接收    2、无法携带拼接的参数 只能携带固定字符串 不能携带拼接在?后面的内容    3、script标签是同步操作 第一个script执行完才能执行第二个script第五种方法    通过jsonp动态创建script        jsonp的本质        前端发起请求 发起请求前声明一个函数 function fn(data){console.log(data)}        后端返回一个函数调用 res.send(fn(333))后端返回的函数名和前端声明的函数名要一致        前端的函数中的参数也就是data接受的就是后端返回的数据 333        动态scipt标签是可以传递拼接在?后边的参数的\n    动态创建script标签的三个步骤\n    创建一个空标签 let s=docoument.createElement(&quot;script&quot;)\n    给标签添加属性 s.src=&quot;http://localhost:3000/getData&quot;\n    将创建好的标签追加到尾部 document.documentElement.appendChild(s)\n\n第六种方法    nginx(代理)      总的结论：          正向代理隐藏用户          反向代理隐藏服务器          正向代理：              1.用户发送请求到自己的代理服务器              2.自己的代理服务器发送请求到服务器              3.服务器将数据返回到自己的代理服务器              4.自己的代理服务器再将数据返回给用户          反向代理：              1.用户发送请求到反向代理服务器(访问的其实是反向代理服务器，但用户不知道)              2.反向代理服务器发送请求到真正的服务器              3.真正的服务器将数据返回给反向代理服务器              4.反向代理服务器将数据返回给用户\n面向对象\n在js中对象是一个无序的数据集合或者也可以说是属性和方法的集合，可以动态的添加属性和方法\n面向对象是一种软件开发的思想和面向过程是相对应的，就是把程序看做一个对象，将属性和方法封装其中，以提高代码的灵活性、复用性、可扩展性\n面向过程是按需求一步一步的用代码从上往下实现，这样做代码不易维护、复用、扩展\n所以大型项目中我们需要以面向对象的方式去开发这样就体现了用面向对象的方法写出来的代码易维护、易复用、易扩展。\n\n面向对象的特征：封装、继承、多态、抽象。\n封装  我对封装的理解就是把属性和方法封装其中，将不需要对外公开的内容隐藏起来提供接口让用户访问属性和方法。\n继承  继承就好比我继承了我爸部分的相貌特征但我和我爸又不完全长一个样子，而且我自己没有钱但我爸有钱，我爸的钱可以给我花。  就是指子类构造函数继承父类构造函数的一些属性和方法，但其本身也有一些自己的方法和属性\n多态  多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果  比如一个我养了条狗和一个猫，我对它们发出“叫”的指令时它们一个是“汪汪汪”的叫一个是“喵喵喵”的叫，我给的指令是一样的它们发出来的声音却不一样。\n抽象  先不去考虑细节的东西，从大的方向开始。比如学生就是一个抽象实体，他的属性并不足以描述出一个人，需要更多的细节才能描述一个人的方方面面。使用抽象可以尽可能避免过早考虑一些细节\n\n原型 原型链原型：    所有的函数默认都有一个“prototype”这样公有且不可枚举的属性，它会指向另一个对象，这个对象就是原型。原型链：    当访问对象的属性或者方法时，首先对象从自身去找，找不到就会往原型中去找，也就是他构造函数的prototype中，如果原型中找不到，即构造函数中也没有该属性，就会往原型后面的原型上去找，这样就形成了链式的结构，称为原型链\nthis指向的情况有哪些事件绑定中的 this普通函数执行中的 this箭头函数执行中的 this构造函数中的 this基于 call&#x2F;apply&#x2F;bind 强制改变中的 this\nNull和undefined的区别？1、null是JavaScript的关键字，而undefined是JavaScript的一个全局变量，也就是挂载在window对象上的一个变量，并不是关键字。2、在使用typeof运算符进行检测时，Undefined类型的值会返回undefined.而Null类型的值返回为object3、在需要进行字符串类型的转换时，null会转换成字符串null,而undefined会转换字符串undefined.4、在进行数值类型的转换时，undefined会转换为NaN,无法参与计算，而null会转换为0,可以参与计算。undefined +0;&#x2F;&#x2F; NaNnull+0 ;&#x2F;&#x2F; 05、建议：无论在什么情况下都没有必要将一个变量显示的赋值为undefined。如果需要定义某个变量来保存将来要使用的对象，应该将其初始化为null.\nCall、apply、bind的区别？call是一个方法,是函数的方法call可以调用函数,call可以改变函数中this的指向\ncall和apply相同点:都会调用函数不同点:传参的方式不同,call传参时一直往后加参数,apply传参数是以数组的形式传参\ncall和bind相同点:传参的方式一样不同点:call会调用函数,bind不会调用函数,它会作为一个返回值返回一个函数,然后才可以调用\nDOCtype(document type)的作用\nDOCTYPE是document type (文档类型) 的缩写。\n用于告诉浏览器该以什么文档标准去解析这个文档\n主要作用是告诉浏览器的解析器使用哪种HTML规范或者XHTML规范来解析页面。\n\nJS语言主要分哪几部分 三部分\nECMAscript 提供核心语言功能\nDom 文档对象模型，提供访问和操作网页内容的方法和接口\nBom 浏览器对象模型，提供与浏览器交互的方法和接口\n\n原型对象、实例对象、构造函数三者之间的关系  实例是由new构造函数生成;\n  原型是构造函数的prototype,构造函数原型上的constructor属性,是构造函数本身;\n实例的_proto_属性,指向构造函数原型\n\n判断对象自身是否包含此属性\nconsole.log(boj1.hasOwnProperty(‘age’))\n\n认识函数\n函数内部定义函数：闭包\n函数内部调用其他函数：函数调用\n函数内部调用参数传过来的函数：回调函数\n函数内部调用自己这个函数：递归\n\nJavaScript数组常用方法有哪些？1、push：在数组末尾添加一个或者多个元素 返回新数组的长度2、pop：移除并返回数组末尾的元素3、unShift：在数组头部添加一个或多个元素 返回新数组的长度4、shift：移除并返回数组头部的元素5、concat：合并两个或者多个数组 并返回合并后的新数组 该方法不会影响原数组6、slice：从数组的指定位置截取元素，返回一个新数组，不会影响原始数组7、splice：从数组指定位置删除或替换元素，可修改原始数组8、indexOf：查找指定元素在数组的索引位置，如果没找到返回-19、lastIndexOf：从数组尾部查找指定元素的索引位置，如果没找到返回-110、includes：查找数组中是否有指定元素，返回布尔值11、json：数组转字符串，并用指定分隔符连接它们12、reverse：反转数组，影响原始数组13、sort：数组排序，默认根据字母顺序排列，会修改原始数组14、forEach：对数组每一个元素执行提供的函数15、filter：遍历数组 返回所有符合条件的元素16、map：创建一个新数组，其中包含对数组中的每一个元素操作后的结果17、reduce：将数组中的元素进行累积操作，返回一个单一值18、some：遍历数组 判断数组中是否有符合条件的元素 返回布尔值19、every：遍历数组，判断数组中元素是否都符合条件 返回布尔值20、find：遍历数组，返回第一个符合条件的元素本身\n导致JavaScript中this指向混乱的原因是什么在js中this的指向是动态的 也就是this指向会根据上下文的环境变化而发生变化 导致他的指向变得混乱或难以预测。常用的导致this指向混乱的原因包括一下几个方面：\n1、函数调用方式不同：\n当一个函数被调用时，它的this指向取决于调用方式，如果使用普通函数调用方式（如fn()），则this会指向全局对象window，如果是方法调用（如obj.fn()）则this指向调用该方法的对象\n\n2、箭头函数的使用：\n箭头函数不具有自己的this值，他会捕获上下文中的this值，因此，如果在箭头函数中访问this，它会指向外层作用域中的this值\n\n3、使用apply、call、bind方法\napply、call、bind方法都可以改变this指向，其中apply、call方法可以立即执行函数并传入参数，而bind方法可以返回一个新函数，该函数的this值被绑定到指定对象上\n\n4、对象的嵌套和继承：\n当一个对象被嵌套在另一个对象中或者使用继承时，this的指向可能变得混乱。这是因为this的指向取决于函数被调用时的上下文环境，而不是对象本身，因此，在嵌套对象或继承类中使用this时需要特别注意他的指向\n\n怎么实现虚拟列表\n虚拟列表是一种优化长列表渲染性能的技术，他只渲染可视化区域内的内容，从而降低了页面渲染的复杂度\n具体而言，实现虚拟列表需要以下几个步骤1、计算可视化区域：首先计算出可见区域内的列表数量和位置2、渲染可见区域：只渲染可见区域内的内容，而不是整个列表3、动态调整列表高度：由于只渲染了部分列表项，因此需要动态调整列表容器的高度，确保滚动条可以正确显示并且用户可以滚动整个列表4、延迟加载非可见区域：当用户滚动列表的时，需要根据当前滚动条0位置动态加载，非可见区域的列表项，以便在用户滚动到该区域是能够及时显示.\n\n说说对轮询的理解什么是轮询\n轮询是指在一定时间内，定时向服务器发送请求，获取最新数据的过程\n轮询通常用于从服务器获取实时更新的数据\n\n轮询和长轮询有什么区别\n轮询是在固定的时间间隔内向服务器发送请求，既是服务器没有数据更新，也会继续发送请求，而长轮询则是发送一个请求，服务器如果没有数据更新，则不会返回，而是一直挂着，直到有数据更新再返回结果\n\n前端轮询的实现方法有什么有两种：基于定时器的轮询和基于递归的轮询。基于定时器的轮询使用setInterval方法来定时发送请求，基于递归的轮询则使用setTimeout方法来控制下一次请求的时间\n轮询有什么缺点\n轮询会产生大量的无效请求，浪费宽带和服务器资源，并且对服务器压力比较大，同时在短时间内频繁对服务器发起请求，可能会被服务器视为恶意行为，导致IP被封禁等问题\n\n如何避免轮询的缺点\n可以使用webSocket和SSE等技术来实现实时数据更新  WebSocket是一种双向通信协议，能够实现服务器与客户端之间的实时通信。  而SSE是一种基于HTTP的单向通信协议，可以实现服务器向客户端推送实时数据。\n这些技术都能够减少无效请求，提高数据传输效率，并且对服务器资源的消耗也比较小\n\n作用域和作用域链作用域\n作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合\n\n换句话说：作用域决定了代码区块中变量和其他资源的可见性\n\n我们一般将作用域分为：  全局作用域  局部作用域  块级作用域\n\n\n全局作用域\n不在任何函数中和大括号中的变量 我们都视为全局作用域，全局作用域下的变量可以在任意位置访问到\n\n函数作用域函数作用域也称局部作用域 如果一个变量在函数内部声明，那么这个变量只能在这个函数体内部才能被访问到，函数外是访问不到的\n块级作用域ES6中引入let和const关键字，和var关键字不同的是，在大括号中使用let和const声明的变量存在于块级作用域，在大括号外是访问不到的\n词法作用域\n又叫静态作用域，变量被创建时就确定好了，JavaScript就是遵循的词法作用域\n相同层级的两个函数没有办法访问打彼此作用域中的变量\n\n作用域链\n当js中使用一个变量时，首先js引擎会在当前作用域下去查找，如果没找到，则会去它的上层作用域查找，依次类推直到找到该变量或者找到了全局作用域\n如果在全局作用域找不到，在非严格模式下回隐式声明该变量，严格模式直接报错\n\nES6有哪些新特性1、let、const 块级作用域以及和 var 的区别声明方式\t变量提升\t作用域\t初始值\t重复定义var\t\t\t  是\t   函数级  不需要\t允许let\t\t\t  否\t    块级   不需要  不允许const\t\t  否\t\t块级\t必需   不允许\n2、解构-快速提取数组&#x2F;对象中的元素数组解构\n单独解构-根据数组索引，将数组解构成单独的元素\nconst arr = [1, 2, 3]const [a, b, c] = arrconsole.log(a, b, c) //1,2,3const [, , d] = arrconsole.log(d) //3\n\n默认值，解构时可以给变量设置默认值，数组没有这个元素的话\nconst arr = [1, 2, 3]const [, , , defaultVal = &#x27;4&#x27;] = arrconsole.log(&#x27;设置默认值&#x27;, defaultVal)\n\n剩余解构用 “…+变量名” 解构剩余参数到新数组，只能用一次\nconst arr = [1, 2, 3]const [e, ...rest] = arrconsole.log(rest) //[2, 3]\n\n对象解构\n单个&#x2F;多个解构-跟数组解构差不多\nconst obj = &#123; name: &#x27;zzm&#x27;, age: 18, height: undefined &#125;const &#123; name, age &#125; = objconsole.log(name, age) // &#x27;zzm&#x27;, 18\n\n解构+重命名-给解构出来的变量重命名\nconst obj = &#123; name: &#x27;zzm&#x27;, age: 18, height: undefined &#125;const &#123; name: objName &#125; = objconsole.log(objName)\n\n默认值-给解构变量设置默认值\nconst obj = &#123; name: &#x27;zzm&#x27;, age: 18, height: undefined &#125;const &#123; next = &#x27;default&#x27; &#125; = objconsole.log(next)\n\n3、模板字符串用法：使用&#96;&#96;将字符串包裹起来功能：可以换行、插值、使用标签函数进行字符串操作\n//换行const str = `fdsjak    fdsa`console.log(str)// 插值const strs = `random: $&#123;Math.random()&#125;`console.log(strs)\n\n4、字符串扩展方法\nincludes-是否包含\nstartsWith-是否以什么开始\nendsWith-是否以什么结束\n\n5、参数默认值&amp;剩余参数\n给函数形参设置默认值// 带默认参数的形参一般放在后面，减少传参导致的错误几率const defaultParams = function (name, age = 0) &#123;  return [age, name]&#125;console.log(defaultParams(1))\n使用…rest 形式设置剩余形参，支持无限参数// 剩余参数，转化成数组const restParams = function (...args) &#123;\tconsole.log(args.toString()) //1, 2, 3, 4, 5&#125;restParams(1, 2, 3, 4, 5)\n\n6、展开数组\n使用…将数组展开const arr = [1, 2, 3]console.log(...arr)// 等价于es5中以下写法console.log.apply(console, arr)\n\n7、箭头函数特性&amp;优势：\n1、简化了函数的写法\n2、没有 this 机制，this 继承自上一个函数的上下文，如果上一层没有函数，则指向 window\n3、作为异步回调函数时，可解决 this 指向问题\n\n8、对象字面量增强\n同名属性可以省略 key:value 形式，直接 key，\n函数可以省略 key：value 形式\n可以直接 func(),\n可以使用计算属性，比如：{[Math.random()]: value}\n\n9、Object.assign(target1, target2, targetN)-复制&#x2F;合并对象/** * Object.assign(target1, target2, ...targetn) * 后面的属性向前面的属性合并 * 如果target1是空对象，可以创建一个全新对象，而不是对象引用 */const obj1 = &#123;  a: 1,  b: 2,&#125;const obj2 = &#123;  a: 1,  b: 2,&#125;const obj3 = Object.assign(&#123;&#125;, obj1)obj3.a = 5console.log(obj3, obj2, obj1)\n\n10、Object.is(value1, value2)\n作用：比较两个值是否相等\n特性：  没有隐式转换  可以比较+0,-0、NaNconsole.log(NaN === NaN) //falseconsole.log(Object.is(NaN, NaN)) //trueconsole.log(0 === -0) // trueconsole.log(Object.is(0, -0)) //falseconsole.log(Object.is(1, 1)) //true\n\n11、Proxy(object, handler)\n作用：  代理一个对象的所有，包括读写操作和各种操作的监听\n用法const P = &#123;  n: &#x27;p&#x27;,  a: 19,&#125;const proxy = new Proxy(P, &#123;  get(target, property) &#123;    console.log(target, property)    return property in target ? target[property] : null  &#125;,  defineProperty(target, property, attrs) &#123;    console.log(target, property, attrs)    //   throw new Error(&#x27;不允许修改&#x27;)  &#125;,  deleteProperty(target, property) &#123;    console.log(target, property)    delete target[property]  &#125;,  set(target, property, value) &#123;    target[property] = value  &#125;,&#125;)proxy.c = 100console.log(&#x27;pp&#x27;, P)\n与 Object.defineProperty  对比\n优势：  拥有很多 defineProperty 没有的属性方法  对数组的监视更方便  以非侵入的访视监管对象的读写\n\n12.Reflect\n作用：  用于对对象的统一操作，集成 Object 相关的所有方法\n\n13.Promise\n作用：解决异步编程中回调嵌套过深问题\n\n14.class&amp;静态方法&amp;继承定义\n使用 class 关键字定义类class Person &#123;\tconstructor(props) &#123;    \tthis.props = props  \t&#125;&#125;\n\n方法\n实例方法，需要实例化之后才能调用，this 指向实例\n静态方法，用 static 修饰符修饰，可以直接通过类名调用，不需要实例化，this 不指向实例，而是指向当前类class Person &#123;  constructor(props) &#123;    this.props = props  &#125;  // 实例方法\teat() &#123;&#125;  // 静态方法  static run() &#123;&#125;&#125;// 调用静态方法Person.run()const person = new Person(&#x27;props&#x27;)// 调用实例方法person.eat()\n\n继承：子类使用 extends 关键字实现继承，可以继承父类所有属性class Student extends Person &#123;  constructor(props) &#123;    super(props)  &#125;  printProps() &#123;    console.log(this.props)  &#125;&#125;const student = new Student(&#x27;student&#x27;)student.printProps()\n\n15.Set说明：\nSet 是一种类似于数组的数据结构\n\n特性：\n元素唯一性，不允许重复元素\n使用 add 增加重复元素，将会被忽略\n\n用途：\n数组去重\n数据存储const arr = [1, 3, 1, 1, 1]const set = new Set(arr)set.add(1).add(1)console.log(set.size) //2const newArr = Array.from(set)console.log(newArr) //[ 1, 3 ]\n\n16.Map说明：\n类似 Object，以 key、value 形式存储数据\n\n区别：\nMap 键不会隐式转换成字符串，而是保持原有类型\n\n实例：const map = new Map()map.set(1, 1)map.set(&#x27;name&#x27;, &#x27;map&#x27;)map.set(obj, obj)console.log(map.get(1)) //1/**    1 1    name map    &#123; &#x27;1&#x27;: 1, true: true, a: &#x27;a&#x27; &#125; &#123; &#x27;1&#x27;: 1, true: true, a: &#x27;a&#x27; &#125;*/map.forEach((val, key) =&gt; &#123;\tconsole.log(key, val)&#125;)\n\n17.Symbol说明：\nJavaScript 第六种原始数据类型，用来定义一个唯一的变量\n\n作用：\n创建唯一的变量，解决对象键名重复问题\n\n为对象、类、函数等创建私有属性\n\n修改对象的 toString 标签\n\n为对象添加迭代器属性\n\n如何获取对象的 symbol 属性？  Object.getOwnPropertySymbols(object)\n\n实例\n// 对象属性重名问题；const objSymbol = &#123;  [Symbol()]: 1,  [Symbol()]: 2,&#125;console.log(objSymbol)// 2、为对象、类、函数等创建私有属性const name = Symbol()const obj2 = &#123;  [name]: &#x27;symbol&#x27;,  testPrivate() &#123;    console.log(this[name])  &#125;,&#125;obj2.testPrivate()// 定义toString标签；console.log(obj2.toString())obj2[Symbol.toStringTag] = &#x27;xx&#x27;console.log(obj2.toString()) //[object xx]\n\n18.for…of…用途：\n已统一的方式，遍历所有引用数据类型\n\n特性：\n可以随时使用 break 终止遍历，而 forEach 不行\n\n实例：// 基本用法// 遍历数组const arr = [1, 2, 3, 4]for (const item of arr) &#123;  if (item &gt; 3) &#123;    break  &#125;  if (item &gt; 2) &#123;    console.log(item)  &#125;&#125;// 遍历setconst set = new Set()set.add(&#x27;foo&#x27;).add(&#x27;bar&#x27;)for (const item of set) &#123;  console.log(&#x27;set for of&#x27;, item)&#125;// 遍历mapconst map = new Map()map.set(&#x27;foo&#x27;, &#x27;one&#x27;).set(&#x27;bar&#x27;, &#x27;two&#x27;)for (const [key, val] of map) &#123;  console.log(&#x27;for of map&#x27;, key, val)&#125;//迭代对象const obj = &#123;  name: &#x27;xiaohui&#x27;,  age: &#x27;10&#x27;,  store: [1, 2, 3],  // 实现可迭代的接口  [Symbol.iterator]: function () &#123;    const params = [this.name, this.age, this.store]    let index = 0    return &#123;      next() &#123;        const ret = &#123;          value: params[index],          done: index &gt;= params.length,        &#125;        index++        return ret      &#125;,    &#125;  &#125;,&#125;for (const item of obj) &#123;\tconsole.log(&#x27;obj for of&#x27;, item)&#125;\n\n19. 迭代器模式作用：\n通过 Symbol.interator 对外提供统一的接口，获取内部的数据\n\n外部可以通过 for…of…去迭代内部的数据const tods = &#123;  life: [&#x27;eat&#x27;, &#x27;sleep&#x27;],  learn: [&#x27;js&#x27;, &#x27;dart&#x27;],  // 增加的任务  work: [&#x27;sale&#x27;, &#x27;customer&#x27;],  [Symbol.iterator]: function () &#123;    const all = []    Object.keys(this).forEach((key) =&gt; &#123;      all.push(...this[key])    &#125;)    let index = 0    return &#123;      next() &#123;        const ret = &#123;          value: all[index],          done: index &gt;= all.length,        &#125;        index++        return ret      &#125;,    &#125;  &#125;,&#125;for (const item of tods) &#123;\tconsole.log(item)&#125;\n\n20、Generator函数\n函数前添加 *，生成一个生成器\n一般配合 yield 关键字使用\n最大特点，惰性执行，调 next 才会往下执行\n主要用来解决异步回调过深的问题function* gen()\t&#123;\t\tyield 1;\t\tconsole.log(yield 2); // undefined\t\tyield 3;\t\treturn 4;\t&#125;\tlet ge=gen() //返回一个遍历器对象\tconsole.log(ge.next()) // &#123;value: 1, done: false&#125;\tconsole.log(ge.next()) // &#123;value: 2, done: false&#125;\tconsole.log(ge.next()) //  &#123;value: 3, done: false&#125;\tconsole.log(ge.next()) //  &#123;value: 4, done: true&#125;\tconsole.log(ge.next()) // &#123;value: undefined , done: true&#125;\n\n21.includes 函数-es2016\n判断数组是否包含某个元素，包含 NaN，解决 indexOf 无法查找 NaN 问题//  includes函数const arr = [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;, NaN]console.log(arr.includes(NaN)) //trueconsole.log(arr.indexOf(NaN)) //-1\n\n22. 运算符-es2016\n指数运算// 指数运算符 **// es5中2十次方console.log(Math.pow(2, 10))// es6中2十次方console.log(2 ** 10)\n\n23.values 函数-es2017\n将对象的值以数组的形式返回const obj = &#123;\tfoo: 1,\tbar: 2,\tbaz: 3,&#125;console.log(Object.values(obj)) //[ 1, 2, 3 ]\n\n24.entries 函数-es2017\n将对象以键值对二维数组返回，使之可以使用 for…of…遍历const obj = &#123;\tfoo: 1,\tbar: 2,\tbaz: 3,&#125;console.log(Object.entries(obj))const entry = Object.entries(obj)for (const [key, value] of entry) &#123;\tconsole.log(key, value)&#125;\n\n25.Object.getOwnPropertyDescriptors(obj)-es2017\n获取对象的描述信息\n可以通过获得的描述信息，配合 Object.defineProperties 来完整复制对象，包含 get，set 方法// getOwnPropertyDescriptors// 普通get方法const objGet = &#123;  foo: 1,  bar: 2,  get getCount() &#123;    return this.foo + this.bar  &#125;,&#125;// assign方法会把getCount当做普通属性复制，从而getCount为3，修改bar不管用const objGet1 = Object.assign(&#123;&#125;, objGet)objGet1.bar = 3console.log(objGet1.getCount) //3// descriptorsconst descriptors = Object.getOwnPropertyDescriptors(objGet)console.log(&#x27;des&#x27;, descriptors)// 通过descriptors来复制对象，可以完整复制对象，包含get，setconst objGet2 = Object.defineProperties(&#123;&#125;, descriptors)objGet2.bar = 3console.log(objGet2.getCount) //4\n\n26.padStart, padEnd 函数-es2017\n在字符串前，或者后面追加指定字符串\n\n参数：\ntargetLenght: 填充后的目标长度\npadString:填充的字符串\n\n规则：1、填充的字符串超过目标长度，会在规定长度时被截断2、填充字符串太短会以空格填充3、padString 未传值，以空格填充\n作用：\n一般用来对齐字符串输出/**\tfoo.................|1\tbarbar..............|2\tbazbazbaz...........|3*/\tconsole.log(`$&#123;key.padEnd(20, &#x27;.&#x27;)&#125;$&#123;value.toString().padStart(2, &#x27;|&#x27;)&#125;`)\n\n函数式编程是什么主要编程范式有三种：命令式编程、声明式编程、函数式编程\n\n简单来说，函数式编程就是把过程逻辑写成函数，定义好输入参数，只关心他的输出结果\n\n概念\n纯函数  就是一个函数的返回结果只依赖于它的参数，并且在执行过程中没有副作用，我们就把这个函数叫做纯函数。\n高阶函数 就是以函数作为输入或者输出的函数被称为高阶函数\n柯里化函数 柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程\n组合与管道 组合函数，目的是将多个函数组合成一个函数\n\n优缺点优点\n更好的管理状态：因为他的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况\n更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用，这样的代码复用时，完全不需要考虑他的内部实现和外部影响\n更优雅的组合：往大了说，网页是由各个组件组成的。往小了说，一个函数也可能由多个小函数组成的。更强的复用性，带来更强大的组合\n隐性好处。减少代码量，提高维护性\n\n缺点\n性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为他往往对一个方法过度包装，从而产生上下文切换的性能开销\n资源占用：在js中为了实现对象状态不可变，往往会创建新的对象，因此，他对垃圾回收所产生的压力远远超过其他编程方式\n递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作\n\ncookie、localStorage和sessionStorage 三者之间有什么区别生命周期\ncookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效\nlocalStorage：除非手动删除，否则将会永久保存\nsessionStorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除\n\n存放数据大小\ncookie：4KB左右\nlocalStorage和sessionStorage：可以保存5MB的信息\n\n易用性\ncookie：需要程序员自己封装，原生的cookieAPI不友好\nlocalStorage和sessionStorage：原生的API可以接受，亦可再次封装来对object和array有更好的支持\n\n浏览器有哪几种缓存，各种缓存的优先级是什么样的？强制缓存：1、浏览器发送HTTP请求2、服务器返回HTTP响应（响应头中的缓存标识：cache-Control(http1.1)、Expires(http1.0)）    - Cache-Control：max-age&#x3D;300，响应内容浏览器本地缓存300秒，缓存时间内再次加载资源，就会命中强缓存    - Expires：Wed,26 Jul 2023 15:50:40 GMT，失效具体时间（2023年7月26日星期三15:50:40 GMT）,缓存时间内再次加载资源，就会命中强缓存    - 同时设置Cache-Control和Expires，Cache-Control优先级更高3、浏览器再次发送相同HTTP请求4、不会再进过服务器，直接从浏览器本地缓存拿出进行返回\n协商缓存：协商缓存步骤如下：（缓存标识对：Etag&#x2F;If-None-Match(http1.1)、Last-Modified&#x2F;If-Modified-Since(http1.0)）1、浏览器发起HTTP请求2、服务器返回HTTP响应（响应头中的缓存标识：Etag、Last-Modified）    - Etag：”64d452af-70b8”,内容的hash值，只有内容改变了，hash才会变化    - Last-Modified:Thu, 10 Aug 2023 02:59:59 GMT，修改时间，哪怕内容没有变化，重新保存可能都会导致修改时间变化    - 同时设置Etag和Last-Modified，Etag优先级更高3、浏览器再次发送相同的HTTP请求（请求头中的缓存标识If-None-Match(http1.1)、If-Modified-Since(http1.0)）4、服务器会检查Etag &#x3D;&#x3D;&#x3D; If-None-Match或者Last-Modified &#x3D;&#x3D;&#x3D; If-Modified-Since是否相等，相等就命中缓存，服务端返回304，从本地缓存中取即可，否则未命中缓存，返回最新的数据和响应头中的缓存标识\nService Worker 缓存：Service Worker 是一种特殊的 JS 脚本，可以拦截网络请求并返回缓存的响应，以实现离线访问和更快的加载速度等功能。\nWeb Storage 缓存：包括 localStorage 和 sessionStorage。localStorage 用于存储用户在网站上的永久性数据，而 sessionStorage 则用于存储用户会话过程中的临时数据。\n这些缓存的优先级如下：Service Worker 缓存：由于其可以完全控制网络请求，因此具有最高的优先级，即使是强制缓存也可以被它所覆盖。强制缓存：如果存在强制缓存，并且缓存没有过期，则直接使用缓存，不需要向服务器发送请求。协商缓存：如果强制缓存未命中，但协商缓存可用，则会向服务器发送条件请求，询问资源是否更新。如果服务器返回 304 Not Modified 响应，则直接使用缓存。Web Storage 缓存：Web Storage 缓存的优先级最低，只有在网络不可用或者其他缓存都未命中时才会生效。\n项目首屏提速\n大致可以分两种\n\n用户感知提速\n因为用户 在很多情况下对于速度的感知是非常主观的，所以说呢，我们可以通过一些加载动画来拖慢用户的这种感知\n\n技术加载提速\n我们可以在服务端通过prerender进行一个预渲染，然后以SSR的形式，完成首页的一个服务端渲染，然后把我们后续的渲染交给CSR客户端去进行渲染，这样的话我们就组成了一种同构渲染的方式，来完成一个渲染的提速\n\n还有一些静态资源的渲染，比如说图片的加载，比如说数据的加载，我们可以借助intersectionObserver来完成一些懒加载的处理\n\n\ncss元素隐藏\n1、display:none 渲染树不会渲染对象\n2、visibility(v 死 biu 了 踢):hidden 元素在页面内仍占据空间，但是不会响应绑定的监听事件\n3、opacity(哦 怕 死 踢):0 元素在页面中仍占据空间 并且能够响应元素绑定的监听事件\n4、position:absolute 通过使用绝对定位将元素移除到可视化区域外，来隐藏元素\n5、z-index:-9999 使其他元素覆盖给元素\n6、transform:scale(si 给 o)(0,0) 将元素缩放为0 元素仍在页面中占据位置 但是不会响应绑定的监听事件\n\ncss元素居中\nflex布局设置居中  给容器设置：  display: flex;写在父元素上这就是定义了一个伸缩容器  justify-content 主轴对齐方式，默认是横轴  align-items 纵轴对齐方式，默认是纵轴\n\n绝对定位设置居中  使用绝对定位的方式实现水平垂直居中。  容器设置position: relative。  子元素设置      position:absolute;      left:50%;      top:50%;      transform:translate(-50%,-50%);\n\n绝对定位设置居中  使用绝对定位的方式实现水平垂直居中。  容器设置position: relative。  子元素设置      position:absolute;      width:300px;      height:300px;      margin-left:-150px &#x2F;&#x2F; 盒子宽的一半      margin-top:-150px &#x2F;&#x2F; 盒子高的一半\n\n还有一种奇葩的方法  这个奇葩方式和使用绝对定位相似，  容器设置position: relative。  子元素设置      position: absolute;      设置固定宽度和高度      top、left、bottom、right都设置为0;      margin设置为auto；      也能实现垂直水平居中。\n\n\nem和rem的区别em\n是一个相对单位，相对于当前父级文本的font-size，如果当前文字的字体尺寸没有设置，则相对于浏览器的默认字体尺寸，即1em&#x3D;16px  特点：  1、em的值并不是固定的  2、em会继承父元素的字体大小\n\nrem\n是相对单位，是相对HTML根元素，比如HTML标签设置font-size：100px；那么1rem就相当于100px  特点：  1、rem为元素设定字体大小的时候，是相对于根元素进行计算的  2、当我改变根元素下的字体大小时，下面的大小都会改变  3、通过rem既可以做的只修改根元素就可以成比例的调整所以字体，又可以避免字体大小逐层复合的连锁反应\n\nHTTP1.0和HTTP2.0的区别1、连接复用\nHTTP1.0：每个HTTP请求都需要建立一个新的TCP连接，请求结束后立即关闭连接，这样的方式会导致每个请求都需要重新建立连接，增加了延迟和开销\nHTTP2.0：引入了多路复用技术，允许在同一个TCP连接上发送多个请求和响应，避免了建立和关闭多个连接的开销，提高了性能和效率\n\n2、请求-响应方式\nHTTP1.0：采用的是单向请求-响应模式，即每个请求只能对应一个响应，请求和响应是一一对应的\nHTTP2.0：引入了Server Push机制，服务器可以在客户端请求之前主动推送相关资源，避免了客户端重复请求的等待事件，提高了页面加载速度\n\n3、头部压缩\nHTTP1.0：每个请求和响应的头部都包含大量的重复信息，造成了较大的网络传输开销\nHTTP2.0：使用HPACK算法对头部进行压缩，减少了头部的大小，降低了网络传输开销\n\n4、二进制协议\nHTTP1.0：采用文本形式进行数据传输，易于阅读和调试，但是传输效率较低\nHTTP2.0：采用二进制格式传输数据，减少了解析的复杂性，提高了传输效率\n\n5、流控制和优先级\nHTTP1.0：没有流控制和优先级的概念，所有请求头都是按照发生的顺序进行处理\nHTTP2.0：引入了流控制和优先级的机制，可以根据需求对请求进行优先级排序和流量控制，确保重要请求的及时处理\n\n6、长连接支持\nHTTP1.0：基本都是短连接，每个请求响应完成之后立即关闭连接\nHTTP2.0：支持长连接，即一个TCP连接可以承载多个请求和响应，减少连接的建立和关闭次数，提高了性能\n\n（DFS）深度优先搜索算法\n其过程为沿着每一个可能的路径向下进行搜索，直到不能再深入为止，并且每一个节点只能访问一次。\n\nBFS（宽度优先算法）\n它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。简单来说，bfs好像是一个耳听六路眼观八方的人\n\n冒泡排序\n原理：  相邻的数据进行两两比较，小数放在前面，大数放在后面，这样一趟下来，最小的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成。\n\n快速排序\n原理：  选择数组中的一个值作为基准，将数组中小于该值的数置于该数之前，大于该值的数置于该数之后，接着对该数前后的两个数组进行重复操作直至排序完成。\n\nJavaScript中常见的数据结构Queue 队列\n队列是一个先进先出的数据结构，一般JavaScript中采用队列解决问题时会用到  入队push ()：在数组的尾部添加元素  出队shift ()：移除数组中第一个元素  queue (0) ：取数组的第一个元素  isEmpty ()：确定队列是否为空  size ()：获取队列中元素的数量\n\nStack 栈\n栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进⬇后出⬆的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。\n\nJavaScript中没有栈，但是可以用Array实现栈的功能。栈中数组长度减一即为栈尾元素，也就是最后进入的那个元素，最先出去的那个元素JavaScript中对栈的操作一般会使用到    push()方法，将元素压入栈顶    pop()方法，从栈顶弹出（删除）元素，并返回该元素    peek()方法，返回栈顶元素，不删除    clear()方法，清空栈    length拿到栈中元素数量\nLinked List 链表\n链表是由多个元素组成的列表，链表中的元素储存不连续，用next指针连接在一起。\n数组：增删非数组元素需要移动元素\n链表：增删非首尾元素不需要移动元素只需要更改next的指向即可\n链表是一个链式数据结构，每个节点由两个信息组成：节点的数据和指向下一个节点的指针。链表和传统数组都是线性数据结构，具有序列化的存储方式。\nJavaScript中没有链表，但是可以用object来模拟链表\n\n集合\n集合：一种无序且唯一的数据结构，集合区别队列、栈、链表最大的区别就是元素不能重复\nJavaScript中ES6中新增了集合这种数据结构，可以通过实例化Set对象来创建集合const set &#x3D; new Set()\n\n树前端🎄树结构还是比较常见的，例如级联选择、层级目录等都是树形结构。javascript中没有树这个数据结构，但是一般用object和array来模拟树。\n\n树的常用遍历方式  1、深度优先遍历  2、广度优先遍历\n\n二叉树\n叉树是n(n&gt;&#x3D;0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成\n\n树的每个节点最多只能有两个子节点\n\njs中自然也没有二叉树这个数据结构，一般还是用object对象来模拟二叉树\n\n二叉树遍历（递归）  （1）前序遍历  DLR：根节点——左子树——右子树  每次遍历到一个节点都重复一次前序遍历  （2）中序遍历  LDR：左子树——根节点——右子树  每次遍历到一个节点都重复一次中序遍历  （3）后序遍历  LRD：左子树——右子树——根节点  每次遍历到一个节点都重复一次后序遍历  注意：  前序遍历第一个为根节点  中序遍历根节点左边为左子树，右边为右子树  后序遍历最后一个为根节点\n\n\n堆\n堆是一种特殊的完全二叉树\n所有的节点都大于等于（最大堆）或者小于等于（最小堆）他的子节点\n\nes6中map和object的区别是什么\n1、Map的键可以是任意值，而Object的键必须是一个String或是Symbol。\n2、Map中的key是有序的，而Object的键是无序的。\n3、Map的键值对个数可以轻易地通过size属性获取，而Object的键值对个数只能手动计算。\n4、Map可以直接被迭代，而Object不可以直接被迭代。\n5、Map在频繁增删键值对的场景下表现更好，而Object的效率比较差。\n\nVueVue的最大优势是什么?\n比较轻量，中国人自己写的框架，文档易读（这里比较轻松，拿出平时和朋友聊天的语气）\n双向数据绑定,\n数据驱动视图,\n组件化开发\n数据和视图分离\n单页面应用可以实现页面数据局部刷新\n\n\n\nMVVM和MVC区别是什么?MVC ： 传统的设计模式。\n设计模式： 一套广泛被使用的开发方式  M： model 模型  模型：就是数据的意思  V ： view视图  视图：就是页面的意思  C：controller控制器  控制器：在这里写js业务逻辑，把数据M 渲染到 视图 V （有点类似于我们之前学习的，把数据渲染到页面）\n\nMVVM： vue所使用的设计模式M： model数据模型 (data里定义)\nV： view视图 （页面标签）\nVM： ViewModel视图模型 (vue.js源码)\n\n\nMVVM通过数据双向绑定让数据自动地双向同步 不再需要操作DOM  V （修改视图） -&gt; M（数据自动同步）  M（修改数据） -&gt; V （视图自动同步）\n\n设计模式: 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。(代码分层, 架构设计)\n\n\n1. 在vue中，不推荐直接手动操作DOM！！！2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！(思想转变)vue第一次加载页面1、创建vue实例2、在创建Vue实例的时候，执行了init()初始化，在init过程中先调用了beforeCreate钩子函数；3、同时监听data数据，初始化vue内部事件，进行属性和方法的计算4、模板开始编译，把vue里面的数据和语法编译成HTML\n当页面第一次加载时会触发 beforeCreate, created, beforeMount, mounted\nVue常用修饰符有哪些?.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.once: 只执行一次这个事件.enter:监听键盘enter键\n对Vue渐进式的理解- 主张最少,\n- 自底向上,\n- 增量开发,\n- 组件集合,\n- 便于复用\n\n\n个人见解  使用模块化规范，实现自助餐式开发，用什么导什么。 最大程度上节省资源。\n\nvue 生命周期什么是vue生命周期和生命周期钩子函数？beforeCreated：在实例初始化之后，el 和 data 并未初始化（这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到）created:完成了 data 数据的初始化，el没有（这个时候可以操作vue实例中的数据和各种方法，但是还不能对”dom”节点进行操作）beforeMount：完成了 el 和 data 初始化 &#x2F;&#x2F;这里的el是虚拟的dom；mounted ：完成挂载，在这发起后端请求，拿回数据，配合路由钩子做一些事情（挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行）beforeUpdate：是指view层数据变化前，不是data中的数据改变前触发；update：是指view层的数据变化之后，beforeDestroy： 你确认删除XX吗？destroyed ：当前组件已被删除，清空相关内容A、什么是vue生命周期？Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程。B、vue生命周期的作用是什么？它的生命周期有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑。C、vue生命周期总共有几个阶段？它可以总共分为8个阶段：创建前&#x2F;后, 载入前&#x2F;后,更新前&#x2F;后,销毁前&#x2F;销毁后D、第一次页面加载会触发哪几个钩子？第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子E、DOM 渲染在 哪个周期中就已经完成？DOM 渲染在 mounted 中就已经完成了。F、简单描述每个周期具体适合哪些场景？生命周期钩子的一些使用方法： beforeCreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，\n说出至少4个Vue指令及作用\nv-on 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在methods里面\nv-bind 动态绑定 作用： 及时对页面的数据进行更改, 可以简写成:分号\nv-slot: 缩写为#, 组件插槽\nv-for 根据数组的个数, 循环数组元素的同时还生成所在的标签\nv-show 显示内容\nv-if 显示与隐藏\nv-else 必须和v-if连用 不能单独使用 否则报错\nv-text 解析文本\nv-html 解析html标签\n\n为什么避免v-for和v-if在一起使用Vue 处理指令时，v-for 比 v-if 具有更高的优先级, 虽然用起来也没报错好使, 但是性能不高, 如果你有5个元素被v-for循环, v-if也会分别执行5次.\nv-if与v-show区别逐字稿面试官你好，我是这么理解v-if和v-show的。 v-if本质其实是动态的创建 或者 删除元素节点。一般不用频繁切换, 要么显示, 要么隐藏的情况, 我都会用 v-if。因为v-if 是惰性的, 如果初始值为 false, 那么这些元素就直接不创建了, 这样就可以节省一些初始渲染开销。v-show本质是在控制元素的 css 样式,display: none;，一般元素需要频繁的切换显示隐藏, 用 v-show。因为v-if在频繁切换会大量的创建和删除元素, 消耗性能。\nVue中key值作用\n1.vue在渲染的时候,会 先把 新DOM 与 旧DOM 进行对比， 如果dom结构一致，则vue会复用旧的dom。 （此时可能造成数据渲染异常）\n2.使用key可以给dom添加一个 唯一标识符，让vue强制更新dom\n\n面试官你好,我是这么理解key值的\nkey值的主要作用是给元素添加一个唯一标识符,用于提高vue渲染性能,当data发生变化的时候,vue会使用diff算法来对比新旧虚拟DOM.如果key值相同,才会考虑复用元素.如果key值不同,则会强制更新元素.一般通过给元素key设置为id,来保证vue更新数据的时候可以最大限度复用相同的key值的元素.\n\nv-for指令使用key值几种情况[v-for指令使用key值几种情况逐字稿]\n\n没有key值(默认是下标) :   不复用，就地更新\nkey值为下标(相当于没设置) :  不复用，就地更新\nkey值是id   :  复用相同的key，更新不同的key总结 ： key值优先设置id, 没有id就用下标\n\nVue中:key作用, 为什么不能用索引\n:key是给v-for循环生成标签颁发唯一标识的, 用于性能的优化\n因为v-for数据项的顺序改变，Vue 也不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素\n\nv-model的作用及原理\n作用\n数据双向绑定指令，专门给表单元素\n\n\n原理\nv-model是一个语法糖，他背后本质上是包含两个操作\nv-bind绑定一个value属性\nv-on指令给当前元素绑定input事件v-model实现原理的例子&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;// 等于// @input input框的事件&lt;input type=&quot;text&quot; v-bind:value=&quot;message&quot;  @input=&quot;message = $event.target.value&quot;&gt;\n\n\n\n\n\nVue中有时候数组会更新页面，有时候不更新，这是为什么?\n因为vue内部只能监测到数组顺序&#x2F;位置的改变&#x2F;数量的改变, 但是值被重新赋予监测不到变更, 可以用 Vue.set() &#x2F; vm.$set()\n\n请说下封装 vue 组件的过程\n有复用的地方就有封装1.先分析需求：确定业务需求，把页面中可以复用的结构，样式以及功能2.具体步骤：Vue.component 或者在new Vue配置项components中, 定义组件名, 可以在props中接受给组件传的参数和值，子组件修改好数据后，想把数据传递给父组件。可以采用$emit方法\n\nvue组件传值\n父传子  1.子组件props定义变量  2.父组件在使用子组件时通过行内属性给props变量传值  特点：单向数据流\n子传父  1.子组件：$emit触发父的事件  2.父在使用组件用@自定义事件名&#x3D;父的方法 (子把值带出来)  特点：事件监听\n非父子组件  vuex  事件总线(Event Bus)  事件总线是一种通过中央事件管理器来实现组件通信的方式。在Vue中，可以使用Vue实例作为事件总线来发送和接收事件。\n\nVue 组件 data 为什么必须是函数因为组件是需要在多个地方使用的\n    如果data是一个对象，对象是引用类型。 一旦某一个地方修改，就会全部修改\n    data是一个函数，每一次复用组件的时候就会从这个函数返回一个新的对象。 这样组件在复用的时候就可以做到数据互不干扰。\n\n讲一下组件的命名规范\n一种是使用链式命名”my-component”，一种是使用大驼峰命名”MyComponent”，\n因为要遵循W3C规范中的自定义组件名 (字母全小写且必须包含一个连字符)，避免和当前以及未来的 HTML 元素相冲突\n\nscoped作用与原理作用：组件css作用域，避免子组件内部的css样式被父组件覆盖默认情况下，如果子组件和父组件css选择器权重相同，优先加载父组件css样式原理：给元素添加一个自定义属性 v-data-xxxxx\n一针见血答案： 通过属性选择题来提高css权重值\nVue 的 nextTick 的原理是什么?为什么需要 nextTick    Vue 是异步修改 DOM 的并且不鼓励开发者直接接触 DOM，但有时候业务需要必须对数据更改–刷新后的 DOM 做相应的处理，这时候就可以使用 Vue.nextTick(callback)这个 api 了。最终答案：    nextTick 的原理是 vue 通过异步队列控制 DOM 更新    nextTick底层是promise，所以是微任务。这个一定要知道\n子组件修改父组件的数据子组件通过this.$emit(“自定义事件名称a”,传递的参数)父组件通过子组件标签接收&lt;组件标签 @自定义事件名称a&#x3D;”自定义名称b”&#x2F;&gt;methods：{    自定义名称b(v){        console.log(v)    }}\n\n$eventBus 灵活\nthis.$emit(‘事件名’,传递的参数)\nthis.$on(‘事件名’,接收的回调)\n\n\nvuex 也算是一种\n\nvue事件冒泡当一个父元素div1 包裹着一个子元素div2 同时都有点击事件，我们点击子元素，不想触发父元素的事件，我们可以采用阻止事件冒泡解决.stop 清除事件冒泡.prevent 阻止默认行为.once 只触发一次.self 只允许元素自己触发\n响应式 简单说就是用户更改数据(Data)时，视图可以自动刷新，页面UI能够响应数据变化。原理：在生成vue实例时，为对传入的data进行遍历，使用Object.defineProperty把这些属性转为getter&#x2F;setter每个vue实例都有一个watcher实例，它会在实例渲染时记录这些属性，并在setter触发时通知render重新渲染。\n插槽更高级的组件复用方式。 接收dom片段或内容，加工处理后返回显示。\t匿名插槽(默认插槽)\t\t写在插槽组件中的内容或者template没有命名都会视为匿名插槽，相当于#default\t\t&lt;b&gt;我是匿名插槽接收的数据&lt;/b&gt;\t\tb组件&lt;template&gt;&lt;solt&gt;我要接收匿名插槽数据的&lt;/solt&gt;&lt;/template&gt;\t具名插槽\t\t插槽组件中在template模板上使用v-slot命令绑定一个名称\t\t插槽组件使用内置组件slot，用name属性去匹配v-slot名称\t\t&lt;b&gt;&lt;template slot=&#x27;aa&#x27;&gt;要传的内容&lt;/template&gt;&lt;/b&gt;\t\tb插槽组件内：&lt;template&gt;&lt;div&gt; &lt;slot name=&#x27;aa&#x27;&gt;要传的内容会在这里显示&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;\t作用域插槽\t\t父组件中的插槽模板template里， 其作用域属于插槽组件。\t\t\t父传子：父组件使用v-bind向插槽组件进行传参\t\t\t子传父：插槽组件在slot组件上使用v-bind反向传参， 父组件使用v-slot=&#x27;参数&#x27;接收数据\t\t\t子集&lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt;\t\t\t父级：&lt;b&gt;&lt;template slot-scope=&quot;user&quot;&gt;&#123;&#123;user.data.name&#125;&#125;&lt;/template&gt;\n\n什么时候使用插槽当子组件被复用时，需要在特定的区域展示不同的定制化的内容。\n插槽的使用场景\n\nv-show  v-if共同点: v-if 和 v-show 都是动态显示DOM元素。区别编译过程：v-if 是真正的条件渲染，因为它会在切换过程对元素和组件适当的销毁和重建 。v-show的元素始终会被渲染。只是基于CSS属性display的切换编译条件：v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做。直到条件第一次变为真时，才会开始渲染。v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS进行切换性能消耗：v-if有更高的切换消耗。v-show有更高的 初始渲染消耗&#96;。应用场景：v-if适合条件很少改变时使用。v-show适合频繁切换\n自定义指令的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives钩子函数：bind(绑定事件触发)、inserted(节点插入的时候触发)、update(组件内相关更新)钩子函数参数：el、binding\nvue路由作用与原理路由作用： 实现单页面应用原理：监听location的hash值\n路由之间是怎么跳转的？有哪些方式?1、2、this.$router.push()跳转到指定的url，并在history中添加记录，点击回退返回到上一个页面3、this.$router.replace()跳转到指定的url，但是history中不会添加记录，点击回退到上上个页面4、this.$touter.go(n)向前或者后跳转n个页面，n可以是正数也可以是负数\n再用动态路由的时候防止刷新白屏router.addRoutes(routes) routes新的路由next({…to,replace:true})\nvue-router怎么配置路由（路由配置六个流程）1.引入组件2.配置路由path和组件, 和生成路由对象routes3.创建路由对象router4.把路由对象挂载到new Vue()5.页面使用 承载路由6. 设置路由导航(声明式导航方式&#x2F;编程式跳转)\nvue-router的钩子函数都有哪些（导航守卫）关于vue-router中的钩子函数主要分为3类    1.全局钩子函数beforeEach（全局前置守卫，所有路由生效）        beforeEach函数有三个参数,分别是:            to:router即将进入的路由对象            from:当前导航即将离开的路由            next:function,进行管道中的一个钩子，如果执行完了,则导航的状态就是 confirmed （确认的）否则为false,终止导航。    2.单独路由独享组件（只对这个路由生效）        beforeEnter,    3 组件内钩子        beforeRouterEnter，（渲染路由组件前）        beforeRouterUpdate,（路由改变）        beforeRouterLeave（路由离开）\n完整的导航解析流程\n1.导航被触发。\n2.在失活的组件里调用 beforeRouteLeave 守卫。\n3.调用全局的 beforeEach 守卫。\n4.在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。\n5.在路由配置里调用 beforeEnter。\n6.解析异步路由组件。\n7.在被激活的组件里调用 beforeRouteEnter。\n8.调用全局的 beforeResolve 守卫(2.5+)。\n9.导航被确认。\n10.调用全局的 afterEach 钩子。\n11.触发 DOM 更新。\n12.调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。\n\n什么是路由守卫？路由守卫又叫导航守卫，就是路由跳转 前，中，后过程中的一些钩子函数，这个函数能够让你操作一些其他的事。\n路由传值的方式有哪几种Vue-router传参可以分为两大类，分别是编程式的导航和声明式的导航    1.编程式导航：router.push        字符串：直接传递路由地址，但是不能传递参数            this.$router.push(“home”)        对象：            命名路由 这种方式传递参数，目标页面刷新会报错 name+params            this.$router.push({name:”news”,params:{userId:123}})            查询参数 和path配对的是query            this.$router.push({path:”&#x2F;news’,query:{usersId:123}})        接收参数 this.$route.query    2.声明式导航        字符串 &lt;router-link to:”news”&gt;        命名路由 &lt;router-link :to:”{name:’news’,params:{userId:1111}}”&gt;        还可以to&#x3D;”&#x2F;path&#x2F;值” - 需要提前在路由 规则里值 &#x2F;path&#x2F;:key        查询参数         还可以to&#x3D;”&#x2F;path?key&#x3D;value\nVue路由传参方式，如何接收对应的值？三种： 分别是query，params，动态路由传参接收：通过query方式传递过来的参数一般是通过this.$route.query接收通过params方式传递过来的参数一般是通过this.$route.params接收通过动态路由传参方式传递过来的参数一般是通过this.$route.params接收\nVue的路由实现模式：hash模式和history模式1.路径不同    hash有#, history没有#2.工作模式不同    hash : 修改当前页面hash,不需要服务器额外配    history: 会给服务器发送请求，需要服务器配置\n1.hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。\n2.history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更\n请说出路由配置项常用的属性及作用路由配置参数：    path : 跳转路径    component : 路径相对于的组件    name:命名路由    children:子路由的配置参数(路由嵌套)    props:路由解耦    redirect : 重定向路由\n$route和$router的区别?$router 对象。用于跳转路由和传递参数$route 对象。用于接收路由跳转参数\nkeep-alivekeep-alive组件 作用就是保持一个组件活着\n\n缓存状态组件，他不会渲染成真实dom，只是将被包裹的自定义组件的状态缓存到内存中\n多用于缓存 表单填写的组件\n它不能缓存v-for循环渲染出来的组件 include属性,表示在被keep-alive管理的组件中,哪些需要保持活跃,有多个需要保持的,以逗号隔开 exclude属性,表示在被keep-alive管理的组件中,哪些不需要保持活跃,\n\n跟keep-alive有关的生命周期是哪些？1.前言：在开发Vue项目的时候，大部分组件是没必要多次渲染的，所以Vue提供了一个内置组件keep-alive来缓存组件内部状态，避免重新渲染2.生命周期函数：在被keep-alive包含的组件&#x2F;路由中，会多出两个生命周期的钩子:activated 与 deactivated。    activated钩子：在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。    deactivated钩子：组件被停用（离开路由）时调用\nvuex作用及五大组成部分vuex作用： 全局数据管理 解决复杂的父子组件传值\nstate作用：存储数据\ngetter作用：派生数据。相当于state计算属性\nmutations作用：修改state中的数据\nactions作用： 异步更新数据\nmodule作用：模块化处理vuex数据\n\nvuex中action工作流程1.组件给actions发送消息2.actions异步请求数据3.actions将请求到的数据提交给mutations4.mutations同步更新state中的数据\nvuex刷新页面丢失数据原因和解决方法？原因：- 因为js的数据都是保存在浏览器的堆和栈内的，刷新浏览器页面，以前堆栈申请的内存被释放(这就是浏览器的运行机制),那么堆栈里的数据自然就被清空了\n\n解决方法\n使用cookie或localstorage\n第二种方法是 vuex-along\n安装 vuex-along -  npm install vuex-along –save\n\n\n第三种方法是 vuex-persistedstate po si te si de te\n安装 vuex-persistedstate -  npm install –save vuex-persistedstate\n\n\n第四种方法是 vuex-persist\n安装 vuex-persist - npm install –save vuex-persistor\n\n\n\n\n\n说一下你在vue中踩过的坑1、操作data中的数据，发现没有响应式    原因： 数组中有很多方法，有的会改变数组（例如pop push）,有的不会改变数组（例如slice, filter）    解决方案：通过Vue.set(对象，属性，值)这种方式就可以达到，对象新添加的属性是响应式的2、在created操作dom的时候，是报错的，获取不到dom，这个时候实例vue实例没有挂载    解决方案：Vue.nextTick(回调函数进行获取)\n小程序小程序的登录流程是什么\n用户点击登录按钮 通过wx.login() 获取用户的code码\n通过wx.request() 网络请求将code码发送给开发者服务器\n后端开发者拿到code码后需要通过appid+appsecret+code向微信接口服务器请求当前用户的session_key和openid\n后端得到session_key 和openid后 会自定义一个登录态(token)和session_key及openid进行绑定\n后端会将token返回给小程序端&#x2F;&#x2F;tao kin\n将小程序端得到token后 要将token存到本地\n\n小程序项目允许的最大体积是多少不适用分包的情况下 小程序总体积不能超过2MB如果使用分包的情况下 总体积不能超过20MB 单个包体积不能超过2MB\n小程序和普通网页区别运行环境不同：网页在浏览器运行，小程序在微信环境运行\n开发模式不同： 网页开发用浏览器+代码编辑器 小程序有自己的一套标准开发模式，使用小程序开发工具\napi不同 运行环境不同所以小程序没有办法调用bom和dom的api 小程序可以调用微信环境提供的各种api 比如扫码，支付，地理定位，摇一摇，附近的人等等…\n小程序的项目构成pages 用来存放所有小程序页面utils 用来存放工具性质模块，比如格式化时间.wxs文件，封装请求数据组件.js文件​app.js 小程序项目的入口文件  类似vue的 app.vueapp.json 小程序项目的全局配置文件app.wxss 小程序项目的全局样式文件project.config.json 项目的配置文件sitemap.json 用来配置小程序是否允许被微信搜索引擎搜索到，比如：在微信小程序搜京东，会弹出京东小程序，如果关闭，搭建的项目，微信是无法搜索到的。\n小程序页面的组成部分**每个页面由四个基本文件组成，在app.json文件中配置好pages后小程序会自动生成文件\n\n.js文件 存放页面脚本文件，存放页面的数据，事件处理函数等 （写逻辑代码）\n.json文件 当前页面配置文件，配置窗口的外观，表现等\n.wxml文件 存放页面布局，类似html但不同，div&#x3D;view span&#x3D;text img&#x3D;image\n.wxss文件 存放样式类似css但是和css不同，.wxss新增了rpx像素单位，只能引入外链文件和样式背景图等都必须外链文件。\n\n## app.json中的配置有哪些1、pages 用于保存页面的路径2、window 配置页面头部的导航栏3、tabBar 配置页面底部菜单栏4、entryPagePath 页面加载时初始化的页面5、networkTimeout 配置网络超时时间6、subpackage 配置小程序的分包功能\nwindow配置中的配置项有哪些\nnavigationBarBackgroundColor：导航栏背景色 只支持十六进制的颜色表示法 &#x2F;&#x2F;nav一给身霸拜克哥软的卡乐\nnavigationBarTextStyle：导航栏的文本样式，只支持两个值 block white\nnavigationBarTitleText：导航栏的标题文本\nbackgroundColor：设置下拉刷新的背景色\nbackgroundTextStyle：下拉刷新界面的文本样式 只支持两个值 dark light\nenablePullDownRefresh：是否启用下拉刷新功能 &#x2F;&#x2F;以内bo pou当瑞服瑞吃\nnavigationStyle:导航栏的样式 只支持两个值 default与custom default表示默认显示导航栏，custom表示隐藏导航栏 只保留右侧胶囊按钮 可以自己定义\n\ntabBar配置中的配置项有哪些\nlist 配置底部的菜单栏列表项\ncolor 设置默认状态的文本颜色\nselectedColor 设置激活状态的文本颜色\nbackgroundColor 设置菜单栏的背景色\nborderStyle 设置菜单栏的上边框样式 支持white和black \nposition 菜单栏的位置 只支持top和bottom\ncustom 自定义菜单栏 true  或者  false\n\n如何自定义tabBar首先在app.json中 配置“tabBar”，对象然后创建list数组，写实际的路径，最少两个，最多五个。\nnetworkTimeout配置中的配置项有哪些\nrequest：配置网络请求的超时时间\nconnectSocket：配置既时通讯的超时时间\nuploadFile：配置上传内容的超时时间\ndownloadFile：配置下载文件的超时时间\n\n小程序渲染数据如何渲染使用插值表达式渲染数据\n列表渲染的指令是什么wx:for\n\n列表渲染如何修改item和index的名字wx:for-item   wx:for-index\n\n列表渲染可以渲染的数据类型有哪些Array  Object  String  Number\n\nblock标签的作用是什么专门用于条件渲染和列表渲染使用的,block标签不会渲染到页面视图中\n\n小程序中如何实现响应式的数据修改获取数据使用this.data.变量名\n通过this.setData() 方法来修改数据\n\n小程序生命周期函数有哪些onLaunch:整个小程序初始化完成\nonShow:小程序加载完成或者当小程序切回前台时触发\nonHide:小程序切换到后台时触发\n\n页面级生命周期函数有哪些onLoad:当前页面加载时触发的时间\nonShow:当前页面在前台显示时触发\nonReady:当前页面初次渲染完成后触发\nonHide:当前页面隐藏是触发\nonUnload:当前页面卸载是触发\n\n组件级生命周期函数有哪些created:当前组件初始化完成时触发,无法调用setData方法\nattached:当前组件在页面中挂载是会触发\nready:当前组件已经全部渲染完成后触发\nmoved:当前组件从节点树中的一个位置移动到另一个位置时触发\ndetached:当前组件被移除是触发--*\n\n组件的主要生命周期在小程序中，最重要的生命周期函数有三个分别是，    created，attached，detached    1.组件实例刚刚被创建好触发created，不能调用setData    用来给组件的this添加一些自定义属性    2.组件完全初始化完毕，进入页面节点树后，触发    attached。this.data已经被初始化完毕，初始化工作比如发送请求。    3.组件离开页面节点树，触发detached生命周期函数，清理性质工作\ninput组件如何实现双线数据绑定需要通过 value&#x3D;’‘ 将数据渲染到输入框中  再通过bind:input 事件 获取用户输入的内容，来修改数据的值\ninput组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值send\t   发送\nsearch\t 搜索\nnext\t   下一个\ngo\t     前往\ndone\t   完成\n\ninput组件中有几种键盘类型，分别是什么input 键盘类型\ntext              文本输入键盘  \nnumber            数字输入键盘  \nidcard            身份证输入键盘 \ndigit             带小数点的数字键盘 \nsafe-password     密码安全输入键盘 指引 \nnickname          昵称输入键盘\n\nscroll-view组件想要纵向滚动时，必须要设置的内容有哪些scroll-y 必须设置高\n\nnavigator组件的跳转方式有哪些navigate  redirect  switchTab reLaunch  navigateBack  exit\n\nnavigate和 redirect方式有什么区别，共同点navigate:保留当前页面\nredirect:关闭当前页面\n共同点：不能跳到tabBar页面 可以携带参数\n\nnavigate和 switchTab 方式有什么区别，共同点navigate:保留当前页面 不可以跳转tabBar 可以携带参数\nswitchTab:跳转到tabBar页面 并关闭其他所有非tabBar页面 不可以传参\n没有共同点\n\nnavigate和 reLaunch 方式有什么区别，共同点navigate:保留当前页面 不可以跳转tabBar\nreLaunch:关闭所有页面 允许跳转任意页面\n共同点：可以传递参数\n\n图片组件是否有默认宽高，默认宽高是多少?宽：320px 高240px\n\nwxss和css的不同之处有哪些wxss文件\n在小程序中,不能使用通配符选择器(*)\n新增了尺寸单位 rpx\n新增样式导入   使用@import语句可以导入外联样式表  该语句后面必须要以分号结尾,不然会报错\n可以配置全局样式与局部样式,全局样式直接写在app.wxss中\n\n小程序有几种绑定事件的方式，有什么区别小程序的事件系统\n两种绑定事件的语法 bind 与catch\n通过bind绑定通用事件,会产生事件流,如果祖级元素有相同类型的事件,会同时触发\ncatch绑定通用事件,不会产生事件流,\nbind与catch绑定时,语法为bind:事件名,但是中间的:可以省略\n\n常见移动端事件有哪，说出5个以上移动端事件:    tap 触摸事件    longtap 长按事件(被longpress代替)    touchstart 手指触摸动作开始事件    touchend 手指触摸动作结束事件    touchmove 手指触摸后移动事件    touchcancel 手指触摸动作被打断，如来电提醒，弹窗    longpress 手指触摸后,超过350ms再离开,如果指定了事件回调函数并触发了这个事件,tap事件将不被触发    touchforcechange  在支持 3D Touch 的 iPhone 设备，重按时会触发\n触摸事件的事件对象中有哪些常见属性，作用是什么事件对象在小程序的事件绑定函数上,不允许加括号调用触摸事件的事件对象     changedTouches:[] 记录发生改变的手指的数量     currentTarget: 表示真正触发事件的元素     offsetLeft: 元素与设备左侧的距离     offsetTop: 元素与设备上方的距离     detail: 记录参数信息,手指触摸的坐标,     target: 手指触摸的元素     touches:[] 记录手指触摸的个数     type: 事件类型\ntarget 和currentTarget两者的区别是什么target表示的是手指触摸的元素,而currentTarget表示响应事件的元素\n\n我们可以通过target中的内容来进行判断,实现事件委托的操作\n我们可以通过target中的id属性来进行判断触发的是哪一个组件,实现事件委托的操作\n\n小程序中的事件如何传递数据通过data-属性来传递数据  例 data-变量名=&quot;传递的数据&quot;  通过e.currentTarget.dataset.变量名接收数据\n\n小程序中全局数据如何使用，有什么特点在app.js中,配置一个globalData属性,在这个属性中保存的内容就是全局数据\n在其他页面中使用时,通过getApp()方法,可以获取到app实例,从而使用app.globalData就可以拿到数据\n在globalData中的数据不能通过setData()方法来更新\n\n如何自定义一个组件在项目中新建一个components 目录 该目录用于保存自定义组件 在页面的json文件中的usingComponents字段中 引入对应的组件路径 之后就可以在对应页面的wxml中使用该组件\n\n关于父子组件之间样式是如何影响的在组件的js文件中可以添加一个options，该选项是一个对象，对象中可以添加一个styleIsolation属性用于控制父子组件之间的样式隔离问题\nstyleIsolation属性有3个可选值：\n    isolated ：默认不会相互影响\n    apply-shared 父影响子\n    shared:相互影响\n\n组件的外部样式类如何设置- 在子组件希望有样式的标签上添加一个类名\n- 在子组件的component构造器中添加externalclasses:[]添加上的类名 \n- 在父组件的子组件标签上 添加对应的class的属性名 值是一个父组件的类名\n- 在父组件的wxss中设置对应的class的样式即可生效\n\n小程序想要实现多个插槽使用如何设置如果想要同时使用多个 需要在组件的js文件的options选项内开启配置multipleSlots:true 才会生效\n\n父组件如何传值给子组件1. 在父组件的子组件标签上动态绑定一个自定义属性，将要需要传递的数据放到属性值中\n2. 在子组件的js文件中 通过properties属性来接收父组件传递的数据\n\n子组件如何传值给父组件1. 在子组件的事件函数中 通过this.triggerEvent()向父组件发出一个自定义事件 该方法有两个参数 第一个是自定义事件名 第二个是传递的参数\n2. 在父组件的子组件标签上 通过bind监听子组件发出的自定义事件 在事件对象event的detail属性中可以接收到子组件传递过来的数据\n\n组件如何监听页面级生命周期通过pageLifetimes属性来监听\n该属性对象中有三个响应函数 show hide resize\n    1. show 表示组件所在页面被展示时的函数\n    2. hide 表示组件所在页面被隐藏时的函数\n    3. resize 表示组件所在页面尺寸发生变化时的函数\n\n小程序中的交互API有哪些wx.showToast：消息提示框\nwx.showModal：显示模态对话框\nwx.showLoading 显示 loading 提示框。需主动调用 wx.hideLoading 才能关闭提示框\nwx.showActionSheet 显示操作菜单\nwx.hideToast 隐藏消息提示框\nwx.hideLoading 隐藏loading提示框\n\n小程序中域名无法识别如何处理在小程序本地设置中勾选不校验合法域名选项即可请求\n在发布阶段，如果希望能够请求服务器资源，那么我们必须为这个服务器配置白名单\n\n网络请求限制，如何配置合法域名？1.出于安全考虑，小程序对数据接口的请求有限制要求，小程序只能请求https类型接口，\n必须将接口的域名添加到信任列表中否则控制台会提示（警告）\n2.登录小程序公众平台---&gt;开发管理----&gt;开发设置---&gt;服务器域名---&gt;修改合法域名\n\n小程序中base64与二进制数据流之间的转换如何转换wx.base64ToArrayBuffer\nwx.arrayBufferToBase64\n\n你是怎么封装微信小程序的数据请求的？在根目录下创建util目录及api.js文件和apiConfig.js文件\n在apiConfig.js封装基础的get，post和put，upload等请求方法，设置请求体，带上token和异常处理等\n在api中引入apiConfig.js封装好的请求方法.根据页面数据请求的urls，设置对应的方法并导出\n在具体的页面中导入或将所有的接口放在统一的js文件中并导出\n在app.js中创建封装请求数据的方法\n\n小程序支付如何实现？小程序注册，要以公司的身份去注册一个小程序，才有微信支付权限\n绑定商户号\n在小程序填写合法域\n调用wx.login()获取appid\n调用\nwx.requestPayment(&#123;    &#x27;timeStamp&#x27;: &#x27;&#x27;,//时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间    &#x27;nonceStr&#x27;: &#x27;&#x27;,//随机字符串，长度为32个字符以下。    &#x27;package&#x27;: &#x27;&#x27;,//统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=*    &#x27;signType&#x27;: &#x27;MD5&#x27;,//签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致    &#x27;paySign&#x27;: &#x27;&#x27;,//签名,具体签名方案参见微信公众号支付帮助文档;    &#x27;success&#x27;:function(res)&#123;&#125;,//成功回调    &#x27;fail&#x27;:function(res)&#123;&#125;,//失败    &#x27;complete&#x27;:function(res)&#123;&#125;//接口调用结束的回调函数（调用成功、失败都会执行）&#125;)\n\n小程序如何进行分包在subpackages字段里面的页面都是分包内容\nroot 分包根目录\nname 分包别名\npages 分包页面路径\n\n普通分包和独立分包有什么不同普通分包 那么该包必须依赖主包才能加载 不允许单独加载\n独立分包 独立运行 不需要先加载主包\n\n分包有哪些注意事项tabBar页面不允许放在分包中 只能放在主包\n一个分包的根目录不能是另一个分包的子目录\n一个分包不能require导入另一个分包的js文件 但是可以使用主包的js文件\n一个分包不能使用另一个分包中的资源 但是可以使用主包资源\n\nuni-appuni-app有哪些优势?\n开发者&#x2F;案例的数量最多\n平台能力不受限制\n性能体验优秀\n周边生态丰富\n学习成本低\n开发成本低\n\nuni-app语法、组件 及 生命周期 的 相同之处？\n所有的语法接近与vue 可以使用vue的所有的指令，以及vue中的语法\n所有的组件接近与微信小程序\n所有的生命周期接近于小程序\n\nuni-app的不同之处？\n条件编译 可以在任意位置出现是以注释的形式来添加条件编译\n\n#ifdef 表示包含那些端渲染，起始位置#idndef 表示排除那些端渲染，起始位置#endif 表示结束位置各端的条件：H5 表示移动端MP 表示所有小程序MP-WEIXIN 表示微信小程序APP-PLUS 表示APP端\n\nAPP端的Nvue开发如果你不开发APP，那么是不需要使用Nvue的\nHTML5+引擎APP内置了HTML5+引擎，可以让js具有直接调用原生能力，在H5和小程序端没有HTML5+引擎的，因此如果需要使用这个引擎，还是需要加条件编译\n\n网络封装let baseUrl=&quot;网址&quot;;export function request(confing)&#123;  return new Promise((res,rej)=&gt;&#123;    wx.request(&#123;      url:baseUrl+confing.url,      method:confing.method||&quot;GET&quot;,      data:confing.data,      header:&#123;        &quot;content-type&quot;:&quot;application/x-www-form-urlencoded&quot;      &#125;,      success:(r)=&gt;&#123;        res(r)    &#125;    &#125;)  &#125;)&#125;\n\nVue3vue2和Vue3的区别一. 根节点不同vue2中必须要有根标签\nvue3中可以没有根标签，会默认将多个根标签包裹在一个fragement虚拟标签中，有利于减少内存。\n\n二. 组合式API和选项式API在vue2中采用选项式API，将数据和函数集中起来处理，将功能点切割了当逻辑复杂的时候不利于代码阅读。\n在vue3中采用组合式API，将同一个功能的代码集中起来处理，使得代码更加有序，有利于代码的书写和维护。\n\n三. 生命周期的变化创建前：beforeCreate -&gt; 使用setup()\n创建后：created -&gt; 使用setup()\n挂载前：beforeMount -&gt; onBeforeMount\n挂载后：mounted -&gt; onMounted\n更新前：beforeUpdate -&gt; onBeforeUpdate\n更新后：updated -&gt; onUpdated\n销毁前：beforeDestroy -&gt; onBeforeUnmount\n销毁后：destroyed -&gt; onUnmounted\n异常捕获：errorCaptured -&gt; onErrorCaptured\n被激活：onActivated 被包含在&lt;keep-alive&gt;中的组件，会多出两个生命周期钩子函数。被激活时执行。\n切换：onDeactivated 比如从 A 组件，切换到 B 组件，A 组件消失时执行\n\n四. v-if和v-for的优先级在vue2中v-for的优先级高于v-if，可以放在一起使用，但是不建议这么做，会带来性能上的浪费\n在vue3中v-if的优先级高于v-for，一起使用会报错。可以通过在外部添加一个标签，将v-for移到外层\n\n五. diff算法不同\nvue2中的diff算法  遍历每一个虚拟节点，进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方。  用patch记录的消息去更新dom  缺点：比较每一个节点，而对于一些不参与更新的元素，进行比较是有点消耗性能的。  特点：特别要提一下Vue的patch是即时的，并不是打包所有修改最后一起操作DOM，也就是在vue中边记录变更新。（React则是将更新放入队列后集中处理）。\n\nvue3中的diff算法  在初始化的时候会给每一个虚拟节点添加一个patchFlags，是一种优化的标识。  只会比较patchFlags发生变化的节点，进行识图更新。而对于patchFlags没有变化的元素作静态标记，在渲染的时候直接复用。\n\n\n六. 响应式原理不同\nvue2通过Object.definedProperty()的get()和set()来做数据劫持、结合和发布订阅者模式来实现，Object.definedProperty()会遍历每一个属性。\n\nvue3通过proxy代理的方式实现。  proxy的优势：不需要像Object.definedProperty()的那样遍历每一个属性，有一定的性能提升proxy可以理解为在目标对象之前架设一层“拦截”，外界对该对象的访问都必须通过这一层拦截。这个拦截可以对外界的访问进行过滤和改写。  当属性过多的时候利用Object.definedProperty()要通过遍历的方式监听每一个属性。利用proxy则不需要遍历，会自动监听所有属性，有利于性能的提升\n\n\nReact基础概念与组件React什么是reactReact是一个用于构建用户界面的javascript库，它允许你将UI拆分成可复用的组件。\nreact组件有哪些\nReact组件主要有函数组件和类组件两种类型。\n函数组件接收props作为参数并返回react元素。\t\n类组件使用ES6类语法，并扩展React Component，可以使用this关键字访问组件的状态和生命周期方法。\n\n什么是JSX\nJSX是React的扩展语法，它允许你在javascript代码中写类似于HTML的标签。JSX最终会被Babel转译成React.createElement调用。\n\n如何创建React组件\n可以通过函数或者类来创建React组件。函数组件直接返回React元素，而类组件需要继承React.Component并在render方法中返回React元素。\n\n状态管理与Props什么是React中的state\nState是组件记忆信息的一种方式，他允许组件在数据变化时重新渲染。\nState是组件私有的，并且只能通过setState方法来更新。\n\nprops与state的区别是什么\nProps是父组件传递给子组件的数据，他是不可变的。而state是组件内部的数据，可以通过setState方法来更新。\n\n什么是受控组件与非受控组件\n受控组件是状态由React控制的组件，其值由父组件通过props传递，并在改变时触发回调函数。\n非受控组件则使用refs或者其他方法在内部管理自己的状态。\n\n生命周期与生命周期方法React组件的生命周期是什么\nReact组件的生命周期包括挂载(Mounting)、更新(Updateing)、卸载(Unmounting)和错误处理(Error Handing)等阶段。\n\n常用的生命周期方法有哪些\n常用的生命周期方法包constructor、render、componentDidMount、componentDIdUpdate、componentWillUnmount等。\n\nReact 16.3之后引入了那些生命周期方法被标记为UNSAFE\nReact16.3之后，componentWillMount、componentWillReceiveProps和componentWillUpdate等生命周期方法被标记UNSAFE，因为他们可能在未来的React版本中被废弃或者更改。\n\n高阶组件与Hooks什么是高阶组件（HOC）\n高阶组件是一个函数，它接受一个组件并返回一个新的组件。HOC可以用于复用组件逻辑、修改组件props或state等。\n\nReact Hooks有哪些\nReact Hooks包括useState、useEffect、useContext、useRef、useCallback、useMemo、useReducer等。他们提供了在函数组件中使用state和其他React特性的能力。\n\n如何使用useState Hook\nuseState是一个Hook，他返回一个状态值和一个更新它的函数。可以在函数组件中使用它来管理组件的状态。\n\n性能优化与最佳实践React中如何性能优化\nReact中的性能优化方法包括使用PureComponent或React.memo来避免不必要的重新渲染、使用shouldComponentUpdate生命周期方法来控制更新、使用React的懒加载和代码拆分等。\n\n什么是React的虚拟dom\n虚拟DOM是React的一个核心概念，它是一个轻量级的、表示真实DOM结构的对象树。当React组件的状态或者Props发生变化时，React会更新虚拟DOM，并将与其之前的虚拟DOM进行比较，以切丁需要更新的真实DOM部分。\n\nReact中如何避免内存泄漏\n在React中，可以通过及时取消订阅事件、清理定时器、避免在组件内部创建不必要的闭包等方式来避免内存泄漏。\n\nReact深入概念\n涵盖React的深入概念、性能优化、组件设计、状态管理、以及React的生态系统等方面。\n\nReact的虚拟DOM是什么？它是如何工作的\n虚拟DOM是React的一个核心概念，它用javascript对象的形式来模拟页面DOM的嵌套关系。当React组件的状态或者属性发生变化时，React会重新生成一颗全新的虚拟DOM树，并与之前的虚拟DOM树进行比较(diff算法)，找出差异的部分，然后打包成pathc应用到真实的DOM上，从而实现高效的页面更新。\n\nReact的diff算法是如何运作的\nReact的diff算法是为了节省性能从而设计的，他主要通过层级进行比较，不跨层级，使得性能更加高效。Diff算法主要是分为tree层、compontnt层和element层三个层次进行比较。\n\nReact的生命周期有哪些阶段？每个阶段对应的方法是什么？\nReact的生命周期主要分为创建阶段、更新阶段和卸载阶段。创建阶段包括constructor、getDerivedStateFromProps、render和componentDidMount等方法；更新阶段包括getDerivedStateFromProps、shouldCompontntUpdate、render、getSnapshotBeforeUpdate和componentDidUpdate等方法；卸载阶段则只有componentWillUnmount方法。\n\n性能优化如何避免不必要的渲染\n可以通过shouldComponentUpdate方法或者React.memo来避免不必要的重新渲染。\nShouldComponentUpdate方法允许开发者在组件更新之前自定义判断，如果返回false则不用重新渲染组件，React.memo则针对函数组件的类似优化手段。\n\n如何使用React的懒加载和代码分割来提高性能\nReact提供了React.lazy和Supense组件来事件懒加载和代码分割。懒加载允许开发者在多个需要时才加载某些组件或者模块，从而减少初始化加载时间。代码分割则是将代码拆分成多个小快，按需加载，以提高性能。\n\n组件设计如何设计可复用的React组件\n设计可复用的React组件需要遵循高内聚低耦合的原则，将组件的职责明确划分，并尽量保持组件的独立性。同时，可以通过props和context等机制来实现组件间的通信和数据共享。\n\n如何处理React组件中的副作用\nReact中的副作用通常指的是哪些影响外部状态或执行非函数操作的行为。可以使用useEffect、useLayoutEffect等Hook来处理副作用。这些Hook允许开发者在组件渲染后或DOM更新后执行特定的操作。\n\n状态管理Redux是什么？它是如何工作的\nRedux是一个用于Javascript应用的状态管理库，它遵循Flux架构的核心理念，即单向数据流。Redux通过action、reducer和store等核心概念来实现状态的管理和更新。Action是一个描述要执行什么操作的普通Javascript对象；- reducer是一个纯函数，它接收当前的state和action作为参数，并返回一个新的state；store则是Redux的核心，他保存了应用的整个状态树，并提供了一系列方法来访问和更新状态。\n\n如何使用Redux中间件来处理异步操作\nRedux中间件是一个用于拦截和扩展action处理流程的函数。通过中间件，开发者可以在action被发送到reducer之前执行一些额外的操作，它允许开发者在action中返回函数来处理异步操作。\n\nReact生态系统React Router是什么？他是如何工作的\nReact Router是一个用于React应用的路由库，它允许开发者在应用中定义不同的路由和页面组件，并根据用户的导航来操作来渲染响应的页面组件。React Router通过context和history等机制来实现路由的管理和状态更新。\n\nReact与TypeScript的结合使用有哪些优势\nReact与TypeScript的结合使用可以提高代码的可读性、可维护性和安全性。TypeScript为Javascript添加了静态类型检查，使得开发者在编写代码时能够及时发现潜在的错误。同时，typeScript还支持接口、枚举等高级类型特征，有助于构建更加健壮和可扩展的React应用。\n\n以上是一些React高级面试中可能出现的问题及其解答。在准备面试时，建议深入理解React的核心概念和原理，并熟悉常用的性能优化手段、组件设计原则以及状态管理库等。同时，也要关注React的生态系统和发展趋势，以便更好地应对面试中的挑战。\n","categories":["解析"]}]