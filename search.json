[{"title":"常用到的css","url":"/2021/07/20/Css/","content":"css设置文字间距/* 使用css样式属性单词text-indent抬头距离，letter-spacing字与字间距。 */text-indent: 20px;/*抬头间距*/    阿三哥东方红郡kilo挖讽德诵功letter-spacing: 20px; /*字体间距*/阿 三 哥 东 方 红 郡 k i l o 挖 讽 德 诵 功","categories":["css"]},{"title":"Eslint","url":"/2022/07/11/Eslint/","content":"eslint\n默认eslint规则\n代码末尾不能加分号；\n代码中不能存在多行空行\ntab键不能使用，必须换成两个空格\n代码中不能存在声明了但未使用的变量\n\n\n\n最简单的方法，关闭eslint检测，其实很简单，把build&#x2F;webpack.base.conf.js配置文件中的eslint rules注释掉即可。但是不推荐这么做，eslint检测是有必要的，能保持良好代码风格\n第二种方法就是把不符合自己习惯的规则去掉，找到配置文件，名字以.eslintrc.*命名\nmodule.exports = &#123;  root: true,  parser: &#x27;babel-eslint&#x27;,  parserOptions: &#123;    //设置&quot;script&quot;（默认）或&quot;module&quot;如果你的代码是在ECMAScript中的模块。    sourceType: &#x27;module&#x27;  &#125;,  env: &#123;    browser: true,  &#125;,  // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style  extends: &#x27;standard&#x27;,  // required to lint *.vue files  plugins: [    &#x27;html&#x27;  ],  // add your custom rules here  &#x27;rules&#x27;: &#123;    // allow paren-less arrow functions    &#x27;arrow-parens&#x27;: 0,    // allow async-await    &#x27;generator-star-spacing&#x27;: 0,    // allow debugger during development    &#x27;no-debugger&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? 2 : 0,    &quot;no-unused-vars&quot;: [2, &#123;       // 允许声明未使用变量      &quot;vars&quot;: &quot;local&quot;,      // 参数不检查      &quot;args&quot;: &quot;none&quot;     &#125;],    // 关闭语句强制分号结尾    &quot;semi&quot;: [0],    //key值前面是否要有空格     &quot;key-spacing&quot;: [0, &#123;      &quot;singleLine&quot;: &#123;        &quot;beforeColon&quot;: false,        &quot;afterColon&quot;: true      &#125;,      &quot;multiLine&quot;: &#123;        &quot;beforeColon&quot;: true,        &quot;afterColon&quot;: true,        &quot;align&quot;: &quot;colon&quot;      &#125;，    //空行最多不能超过100行    &quot;no-multiple-empty-lines&quot;: [0, &#123;&quot;max&quot;: 100&#125;],    //关闭禁止混用tab和空格    &quot;no-mixed-spaces-and-tabs&quot;: [0],    //数组第一个指定是否启用这个规则，第二个指定几个空格    &quot;indent&quot;:[1,2],&#125;其中的rules就是配置规则的。\n\n配置参数rules:&#123;    &quot;规则名&quot;:[规则值，规则配置]&#125;\n规则值&quot;off&quot;或者0    //关闭规则关闭&quot;warn&quot;或者1    //在打开的规则作为警告（不影响退出代码）&quot;error&quot;或者2    //把规则作为一个错误（退出代码触发时为1）\n常见规则列表&quot;no-alert&quot;: 0,//禁止使用alert confirm prompt&quot;no-array-constructor&quot;: 2,//禁止使用数组构造器&quot;no-bitwise&quot;: 0,//禁止使用按位运算符&quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee&quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名&quot;no-class-assign&quot;: 2,//禁止给类赋值&quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句&quot;no-console&quot;: 2,//禁止使用console&quot;no-const-assign&quot;: 2,//禁止修改const声明的变量&quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1)&quot;no-continue&quot;: 0,//禁止使用continue&quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符&quot;no-debugger&quot;: 2,//禁止使用debugger&quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符&quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/&quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;&quot;no-dupe-args&quot;: 2,//函数参数不能重复&quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复&quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句&quot;no-empty&quot;: 2,//块语句中的内容不能为空&quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空&quot;no-empty-label&quot;: 2,//禁止使用空label&quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符&quot;no-eval&quot;: 1,//禁止使用eval&quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值&quot;no-extend-native&quot;: 2,//禁止扩展native对象&quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定&quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换&quot;no-extra-parens&quot;: 2,//禁止非必要的括号&quot;no-extra-semi&quot;: 2,//禁止多余的冒号&quot;no-fallthrough&quot;: 1,//禁止switch穿透&quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3.&quot;no-func-assign&quot;: 2,//禁止重复的函数声明&quot;no-implicit-coercion&quot;: 1,//禁止隐式转换&quot;no-implied-eval&quot;: 2,//禁止使用隐式eval&quot;no-inline-comments&quot;: 0,//禁止行内备注&quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数）&quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式&quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量&quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格&quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性&quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同&quot;no-labels&quot;: 2,//禁止标签声明&quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块&quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句&quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）&quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型&quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格&quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格&quot;no-multi-spaces&quot;: 1,//不能用多余的空格&quot;no-multi-str&quot;: 2,//字符串不能用\\换行&quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行&quot;no-native-reassign&quot;: 2,//不能重写native对象&quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有!&quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算&quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值&quot;no-new-func&quot;: 1,//禁止使用new Function&quot;no-new-object&quot;: 2,//禁止使用new Object()&quot;no-new-require&quot;: 2,//禁止使用new require&quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number&quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON()&quot;no-octal&quot;: 2,//禁止使用八进制数字&quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列&quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值&quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接&quot;no-plusplus&quot;: 0,//禁止使用++，--&quot;no-process-env&quot;: 0,//禁止使用process.env&quot;no-process-exit&quot;: 0,//禁止使用process.exit()&quot;no-proto&quot;: 2,//禁止使用__proto__属性&quot;no-redeclare&quot;: 2,//禁止重复声明变量&quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/&quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错&quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式&quot;no-script-url&quot;: 0,//禁止使用javascript:void(0)&quot;no-self-compare&quot;: 2,//不能比较自身&quot;no-sequences&quot;: 0,//禁止使用逗号运算符&quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名&quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用&quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格&quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2]&quot;no-sync&quot;: 0,//nodejs 禁止同步方法&quot;no-ternary&quot;: 0,//禁止使用三目运算符&quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格&quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super&quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;;&quot;no-undef&quot;: 1,//不能有未定义的变量&quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined&quot;no-undefined&quot;: 2,//不能使用undefined&quot;no-unexpected-multiline&quot;: 2,//避免多行表达式&quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾&quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;&quot;no-unreachable&quot;: 2,//不能有无法执行的代码&quot;no-unused-expressions&quot;: 2,//禁止无用的表达式&quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数&quot;no-use-before-define&quot;: 2,//未定义前不能使用&quot;no-useless-call&quot;: 2,//禁止不必要的call和apply&quot;no-void&quot;: 2,//禁用void操作符&quot;no-var&quot;: 0,//禁用var，用let和const代替&quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注&quot;no-with&quot;: 2,//禁用with &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格&quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来&quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号&quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter&quot;block-scoped-var&quot;: 0,//块语句中使用var&quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格&quot;callback-return&quot;: 1,//避免多次调用回调什么的&quot;camelcase&quot;: 2,//强制驼峰法命名&quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号&quot;comma-spacing&quot;: 0,//逗号前后的空格&quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾&quot;complexity&quot;: [0, 11],//循环复杂度&quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的&quot;consistent-return&quot;: 0,//return 后面是否允许省略&quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名&quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super&quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125;&quot;default-case&quot;: 2,//switch语句最后必须有default&quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾&quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号&quot;eol-last&quot;: 0,//文件以单一的换行符结束&quot;eqeqeq&quot;: 2,//必须使用全等&quot;func-names&quot;: 0,//函数表达式必须有名字&quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式&quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格&quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤&quot;handle-callback-err&quot;: 0,//nodejs 处理错误&quot;id-length&quot;: 0,//变量名长度&quot;indent&quot;: [2, 4],//缩进风格&quot;init-declarations&quot;: 0,//声明时必须赋初值&quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格&quot;lines-around-comment&quot;: 0,//行前/行后备注&quot;max-depth&quot;: [0, 4],//嵌套块深度&quot;max-len&quot;: [0, 80, 4],//字符串最大长度&quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度&quot;max-params&quot;: [0, 3],//函数最多只能有3个参数&quot;max-statements&quot;: [0, 10],//函数内最多有几个声明&quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用&quot;new-parens&quot;: 2,//new时必须加小括号&quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行&quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格&quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法&quot;one-var&quot;: 1,//连续声明&quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的&quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首&quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行&quot;prefer-const&quot;: 0,//首选const&quot;prefer-spread&quot;: 0,//首选展开运算&quot;prefer-reflect&quot;: 0,//首选Reflect的方法&quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &#x27;&#x27;&quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号&quot;radix&quot;: 2,//parseInt必须指定第二个参数&quot;id-match&quot;: 0,//命名检测&quot;require-yield&quot;: 0,//生成器函数必须有yield&quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾&quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格&quot;sort-vars&quot;: 0,//变量声明时排序&quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格&quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格&quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格&quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格&quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格&quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格&quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格&quot;spaced-comment&quot;: 0,//注释风格要不要有空格什么的&quot;strict&quot;: 2,//使用严格模式&quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN()&quot;valid-jsdoc&quot;: 0,//jsdoc规则&quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值&quot;vars-on-top&quot;: 2,//var必须放在作用域顶部&quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格&quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来&quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件","categories":["eslint"]},{"title":"expo版rn","url":"/2023/06/08/ExpoRN/","content":"","categories":["RN"]},{"title":"TypeScript","url":"/2022/01/26/TypeScript/","content":"什么的是TypeScript\njs的超集(超级集合)\n包含js里所有的元素\n能运行js代码\n支持ES语法(ES6,ES7…)\n是一种开源、跨平台的编程语言\n\n\n编译器编译为js代码，js解析器执行\n完全兼容js代码\n静态类型检查器\n静态类型，更加严格的语法\n减少运行时异常出现的几率\n后期维护\n\n\n\n写ts前的一些小配置\n安装TypeScript\nnpm install -g typescript\ntsc -v 查看typescript版本号\n\n\n编译ts文件为js文件\n手动编译为js\ntsc 文件名\n\n\nvscode自动编辑 (快速生成tsconfig.json)\ntsc –init 生成配置文件\n修改配置文件tsconfig.json\n“outDir”:”.&#x2F;js”\n“strict”:false\n\n\n启动监视任务\n终端\n运行任务\n监视tsconfig.json\n\n\n\n\n\n\n\n类型声明基础类型let num:Number=10num =11function ab(a:string)&#123;console.log(a);&#125;ab(&#x27;1111&#x27;)// 类型声明 指定ts变量(参数，形参)的类型 ts编译器，自动检查// 类型声明给变量设置了类型，使用变量只能存储某种类型的值// 布尔类型 booleanlet flag : boolean = true// flag = 123 报错 flag = false// 数字类型 Numberlet a:number = 10 //十进制let a1:number = 0b1010//二进制let a2:number = 0o12 //八进制let a3:number = 0xa  //十六进制a = 11//字符串类型 stringlet str:string = &#x27;123&#x27;// str=123str=&#x27;&#x27;// undefined和null，用的不多let u:undefined=undefinedlet n:null=nullconsole.log(u,n);// u=123 // undefined和null还可以作为其他类型的子类型   XXX行得通但是ts里会报错，js里没有事情// 可以吧undefined和null 赋值给其他类型的变量let b:number=undefinedlet str1:String= nullconsole.log(b,str1);\n数组// 定义数组一：let arr1:number[]=[1,2,3]arr1=[1,2,3]// 定义数组二：泛型let arr2:Array&lt;number&gt;=[12,20,30]\n对象\nobject 表示非原始类型，除了number、string、boolean之外的类型let obj:object=&#123;&#125;// 字面量// obj=123 报错// obj=&#x27;&#x27; 报错obj=nullobj=undefinedobj=[]obj= new String()  //实例对象obj=String\n\nany\nany 任何类型let h:any = 123h=trueh=&#x27;123&#x27;h=&#123;&#125;h=[]let newArr:any[]=[100,2,3,&quot;&quot;,true]// 有优点也有缺点console.log(newArr[0].split(&#x27;&#x27;));\n\nvoid\nvoid空值 ，便是没有任何返回值的函数function fun1():void&#123;    console.log(123);    // return undefined&#125;console.log(fun1());// 没有任何类型let v:void=undefined  \n\n类型推断// ts在没有明确的指定类型的时候推测一个类型// 两种情况// 1、定义变量的时候，直接给变量赋值，则定义类型为对应的类型// 2、定义变量的时候，没有赋值，则定义类型为iany类型let t=123; //将t定义为了一个number类型通过类型推断// t=&quot;&quot; 报错let g;g=123g=[]g=&#123;&#125;g=&quot;&quot;\n联合类型\n表示取值可以为多种类型中的一种// flag true，1, false，0let f:boolean |number | string  = truef=123  //再次赋值，类型推断，给变量定义一个类型f=&#x27;123&#x27;// f=trueconsole.log(f.split(&#x27;&#x27;));\n\n接口对象类型// 它是对行为的抽象，用于对[对象的形状(Shape)]进行描述，理解为一种约束// 接口一般首字母大写，// 定义的变量比接口少了一些属性是不允许的，不能多出其他的属性// ?表示可选属性，定义对象 ? 的属性可有可无// [propName:string]:any 任意属性和任意属性值// [propName:string]:string 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集// 可以用 readonly(瑞得令) 定义只读属性// 定义接口  interface(阴的费嘶)interface IPerson&#123;    readonly id:number,    name:string,    age:number,    sex?:string,    // [propName:string]:any,    [propName:string]:string |number | boolean&#125;let p:IPerson=&#123;    id:10,    name:&#x27;zhangsan&#x27;,    age:18,    // sex:&#x27;男&#x27;,    width:&quot;&quot; //报错&#125;// p.id=11\n数组类型// 不常用interface INewArray&#123;    [index:number]:number //任意属性，index表示数组中的下标&#125;// [1,2,3,4]  arr[0]--&gt;obj[&#x27;name&#x27;]//  0,1,2,3let arr:INewArray=[1,2,3,4]\n函数类型interface ISeacrchFunc&#123;    // (参数: 类型,....)：返回值得类型    (a: string,b: string): boolean&#125;// 参数，返回值const fun1:ISeacrchFunc=function(a:string,b:string):boolean&#123;    return a.search(b) !== -1&#125;console.log(fun1(&#x27;123&#x27;,&#x27;2&#x27;));\n\n函数函数声明和表达式// // 函数声明，命名函数// function add(a,b)&#123;//     return a+b// &#125;// // 函数表达式，匿名函数// let add2=function(a,b)&#123;//     return a+b// &#125;// ts 函数声明，命名函数 // a 和 b 都是number类型// :number 表示该函数的返回值为number类型function add(a:number,b:number):number&#123;    return a+b&#125;console.log(add(1,2));let c:number=add(1,2)console.log(c);// 函数表达式，匿名函数let add2=function(a:number,b:number):number&#123;    return a+b&#125;console.log(add2(1,2));// 函数完整的写法let add3:(a:number,b:number)=&gt;number=function(a:number,b:number):number&#123;    return a+b&#125;\n可选参数和默认参数\n可选参数 ? 必选参数不能位于可选参数后let getName=function(x:string,y?:string,z:string=&quot;你好&quot;):string&#123;    return x+y+z&#125;// console.log(getName(&#x27;zhang&#x27;));// 默认参数console.log(getName(&quot;张三&quot;));\n\n剩余参数和默认参数// 剩余参数function fn(x:string,y:string,...args:number[])&#123;    console.log(x,y,args);    &#125;fn(&#x27;&#x27;,&#x27;&#x27;,1,2,3,4,5)// 函数重载 ：函数名相同，形参不同的多个函数// 数字 相加，字符串 拼接 ... 联合类型// 函数重载声明,可以使用重载定义多个 newAdd 的函数类型function newAdd(x:string,y:string):stringfunction newAdd(x:number,y:number):number// 函数实现function newAdd(x:string|number, y:string|number):string|number &#123;    if (typeof x == &#x27;string&#x27; &amp;&amp; typeof y == &#x27;string&#x27;) &#123;        return x + y; //字符串拼接    &#125;    else if (typeof x == &#x27;number&#x27; &amp;&amp; typeof y == &#x27;number&#x27;) &#123;        return x + y; //数字相加    &#125;&#125;// 然而这样有一个缺点，就是不能够精确的表达，// 输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。console.log(newAdd(1,2));console.log(newAdd(&#x27;张&#x27;,&#x27;三&#x27;)); \n类型断言// 定义一个函数，获取到一个数组或者字符串的长度// 类型断言：可以手动指定一个类型// 两种方式// 1、变量 as 类型// 2、(&lt;类型&gt;变量)// 讲一个联合类型断言为其中一个类型function getLength(x:string|number):number&#123;    if((x as string).length)&#123;        return (&lt;string&gt;x).length    &#125;else&#123;        return x.toString().length    &#125;&#125;console.log(getLength(&#x27;123&#x27;));console.log(getLength(123));// 将任何一个类型断言为 any ,any类型是访问任何属性和方法的(window as any).a=123\n\n进阶类型别名type s=string //通过type给类型起别名type all=string|number|booleanlet str:s=&quot;!123&quot;// str=123// 常用于给联合类型起别名let a:all = 123a=&#x27;&#x27;let b:all = trueb=123\n字符串字面量类型// 用来约束取值只能是某几个字符串中的一个// 张三封，张三，张牛马type stringType=&quot;张三封&quot; | &quot;张三&quot; | &quot;张牛马&quot;let names:stringType=&quot;张三封&quot;\n元组Tuplelet arr:number[] = [1,2,3,4]// 数值和字符串// 元组(Tuple) 合并了不同类型的对象let Tarr:[number,string]=[123,&quot;123&quot;]// 添加内容的时候，需要是number或者string类型Tarr.push(456)Tarr.push(&quot;456&quot;)// Tarr.push(true) 报错\n枚举\n使用枚举类型给一组数组赋予名称\n可以通过名称去拿取值，通过值拿取名称\n枚举成员被赋值为从0开始递增的数字，同时也会对枚举值到枚举名进行反向映射// 1,2,3,4enum numberType&#123;    one=2, //手动赋值，没有赋值，第一个参数默认为0，后面的递增+1    two=1,//后面的值如果没有手动赋值，会根据前面的值进行递增+1    three,    four,&#125;// 手动赋值注意：尽量不要写一些重复的值console.log(numberType);// 枚举项有两种类型：常数项（constant member）和计算所得项（computed member）// 计算所得项需要放置在已经确定赋值的枚举项之前，后面不能存放为手动赋值的手动项enum Color&#123;    red,    blue=&quot;blue&quot;.length,    green=11&#125;// 常数枚举是使用const enum定义的枚举类型// 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含任何计算成员const enum Obj&#123;    o,    b,    j=10+101&#125;console.log(Obj.o);console.log(Obj.b);console.log(Obj.j);// 外部枚举(Ambient Enums) 是使用 declare(滴窥儿) enum 定义的枚举类型// declare 定义的类型只会用于编译时的检查，编译结果中会被删除// 声明文件declare const enum ABC&#123;    a,    b,    c&#125;console.log(ABC.a);\n\nts进阶\n类型别名\n通过type去定义，用来给一个类型起个新名字\n\n\n字符串字面量类型\n用来约束取值只能是某几个字符串中的一个\n\n\n元组Tuple(台坡)\n\n类属性和方法\n类：描述了所创建的对象共同的属性和方法// 实例化对象class Person&#123;    name:string    age:number    constructor(name:string,age:number)&#123;        this.name=name        this.age=age    &#125;    sayHi(str:string)&#123;        console.log(&#x27;hi&#x27;+str);            &#125;&#125;let p = new Person(&#x27;zs&#x27;,12) //new的时候，会执行类中构造方法constructorp.sayHi(&#x27;李四&#x27;)\n\n继承// 扩展现有的类，通过继承// 继承：类与类之间的关系// 子类继承父类class Animal&#123; //父类    name:string    age:number    constructor(name:string,age:number)&#123;        this.name=name        this.age=age    &#125;    sayHi(str:string)&#123;        console.log(&#x27;hi&#x27;+str);            &#125;&#125;// 子类class Dog extends Animal&#123;    constructor(name:string,age:number)&#123;        // 调用父类的构造函数，使用super        super(name,age)    &#125;    // 可以调用父类的方法，还可以重写父类的方法    sayHi()&#123;     console.log(&#x27;我是Dog类的sayHi方法&#x27;);        super.sayHi(&#x27;狗子&#x27;)    &#125;&#125;const a = new Animal(&#x27;小猫&#x27;,1)a.sayHi(&#x27;小猫&#x27;)const d = new Dog(&#x27;拉布拉多&#x27;,2)d.sayHi()// 总结：类与类之间存在继承关系，通过extends进行继承// 子类可以调用父类的方法，通过super// 子类还可以重写父类的方法\n存取器// 存取器，可以帮助我们控制对象成员的访问class Name&#123;    firstName:string    lastNAme:string    constructor(firstNAme:string,lastName:string)&#123;        this.firstName = firstNAme        this.lastNAme = lastName    &#125;    // 设置存取器    // 读取器--&gt;用来读取数据    get fullName()&#123;        // 姓名=姓氏+名字        return this.firstName+&#x27;-&#x27;+this.lastNAme        // return &quot;张三&quot;    &#125;    // 设置器--&gt;用来设置数据    set fullName(value)&#123;        console.log(value);        let names=value.split(&#x27;-&#x27;)        this.firstName=names[0]        this.lastNAme=names[1]            &#125;&#125;const n=new Name(&#x27;张&#x27;,&#x27;狗子&#x27;)console.log(n);n.fullName=&quot;张-三封&quot;console.log(n.fullName);\n静态方法\n静态成员\n只属于类自己的属性和方法// 静态方法// 静态属性class A&#123;    static name1:string    // constructor(name:string)&#123;    //     this.name=name    // &#125;    static sayHi()&#123;        console.log(&#x27;hi&#x27;);            &#125;&#125;const a1 = new A()console.log(A.name1);A.sayHi()// console.log(a1.name); //报错// a1.sayHi() //报错\n\n修饰符\npublic 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\nprivate(拍喂特) 修饰的属性或方法是私有的，不能在声明它的类的外部访问，包括其子类也不能，但是这个属性和方法是可以被继承的\nprotected(坡柔太克特的) 被访问的修饰的属性或方法是受保护的，它和 private类似，区别是它在子类中也是允许class B&#123;    public gender:string //公有的属性    private name1:string //私有的属性    protected age:number //受保护的属性    public constructor(name:string,age:number)&#123; //共有的方法        this.name1 = name        this.age=age    &#125;    public p()&#123;        console.log(this.name1);        console.log(this.age);                    &#125;&#125;class C extends B&#123;    constructor(name1:string,age:number)&#123;        super(name1,age)    &#125;    play()&#123;        // console.log(this.name1);        console.log(this.age);                    &#125;&#125;const b=new B(&#x27;张三&#x27;,12)const c=new C(&#x27;张三封&#x27;,13)// console.log(c.age);// console.log(b.name1);// b.p()c.play()\n\nreadonly修饰符class X&#123;    // readonly age:number  //只读属性，但是在构造函数是可以修改的    // readonly以及三个修饰符定义在参数上，那就是创建并且会初始化age参数    // constructor(readonly age:number)&#123;    // constructor(public age:number)&#123;    // constructor(private age:number)&#123;    constructor(protected age:number)&#123;        // this.age=age    &#125;    update()&#123;        // this.age=122  报错，不能被修改 ， 只读属性    &#125;&#125;const x = new X(111)console.log(x);// x.age=115\n抽象类// abstract(啊波嘶拽科特)abstract class Y&#123; //定义一个抽象类，为子类服务    abstract name:string //抽象属性    // constructor(name)&#123;    //     this.name=name    // &#125;    abstract sayHi() //不能够有具体实现&#125;// 不能够被实例化class Z extends Y&#123;    name: string    constructor(name)&#123;        super()        this.name=name    &#125;    // 在子类中去具体实现抽象类中的抽象方法    sayHi()&#123;        console.log(&#x27;hi&#x27;);            &#125;&#125;const z=new Z(&#x27;张三&#x27;)console.log(z.name);z.sayHi()\n类的类型class Car&#123;    name:string    constructor(name:string,)&#123;        this.name=name    &#125;&#125;class Ben extends Car&#123;    age:number    constructor(name)&#123;        super(name)    &#125; &#125;const car:Car=new Car(&#x27;&#x27;)const ben:Ben=new Ben(&#x27;&#x27;)\n类实现接口// implements(阴坡门(三声)呲)interface ISing&#123;    // 这个方法是没有任何的实现    sing()&#125;interface IDance&#123;    dance()&#125;class P implements ISing,IDance&#123;//人 唱歌，跳舞    sing() &#123;        console.log(&#x27;唱&#x27;);            &#125;    dance() &#123;        console.log(&#x27;跳rap&#x27;);            &#125;&#125;class An implements ISing,IDance&#123;//动物 唱歌，跳舞    sing() &#123;        console.log(&#x27;唱&#x27;);            &#125;    dance() &#123;        console.log(&#x27;跳rap&#x27;);            &#125;&#125;const p1=new P()const an=new An()p1.sing()an.sing()p1.dance()an.dance()\n接口继承接口interface IRun&#123;    run()&#125;interface ISwim&#123;     swinm()&#125;// 接口是可以继承其他多个接口的interface IActive extends IRun,ISwim&#123;&#125;// ...class I implements IActive&#123;    run() &#123;            &#125;    swinm() &#123;            &#125;&#125;\n声明合并// 函数合并--&gt;函数重载// 接口合并// 合并的属性的类型必须是唯一的// 类的合并和接口合并规则一样的interface Cat&#123;    name:&quot;栗子&quot;,    gender:&quot;女&quot;&#125;interface Cat&#123;    name:&quot;栗子&quot;    age:3&#125;const cat:Cat=&#123;    name:&quot;栗子&quot;,    age:3,    gender:&quot;女&quot;&#125;\n\n泛型泛型的简单使用// 需求：定义一个函数，传入两个参数，第一个参数是数据，第二个参数是数量// 函数的作用:根据数量产生对应个数的数据，存放在一个数组中 // (123,3)--&gt;[123,123,123]// 数值// T表示function getArr&lt;T&gt;(value:T,count:number):T[]&#123;    const arr:T[]=[]    for(let i=0;i&lt;count;i++)&#123;        arr.push(value)    &#125;    return arr&#125;// 原则上不推荐any// 使用泛型，在定义时不需要先确定类型，而是在使用的时候再去确定// 如果没有确定的话，就睡走类型推断console.log(getArr(123,3));console.log(getArr&lt;string&gt;(&#x27;123&#x27;,4));[123,&quot;&quot;,true,&#123;&#125;,[]]     \n多个泛型参数的函数// [123,&quot;123&quot;]--&gt;[&quot;123&quot;,123]function updateArr&lt;T,U&gt;(t:[T,U]):[U,T]&#123;    return [t[1],t[0]]&#125;console.log(updateArr&lt;string,number&gt;([&#x27;123&#x27;,123]));console.log(updateArr&lt;boolean,number&gt;([true,123]));\n泛型约束// 获取一个参数的长度// 泛型约束，约束这个输入的任意类型，必须要有length属性interface ILength&#123;    length:number&#125;function getLength&lt;T extends ILength&gt;(x:T):number&#123;    return x.length&#125;console.log(getLength(&quot;123&quot;));\n泛型接口// 定义一个泛型接口// interface IArr&#123;//     &lt;T&gt;(value:T,count:number):Array&lt;T&gt; // &#125;interface IArr&lt;T&gt;&#123;    (value:T,count:number):Array&lt;T&gt; &#125;let getArr1:IArr&lt;string&gt; = function &lt;T&gt;(value:T,count:number):T[]&#123;    const arr:T[]=[]    for(let i=0;i&lt;count;i++)&#123;        arr.push(value)    &#125;    return arr&#125;console.log(getArr1(&quot;123&quot;,3));interface IPerson&lt;T&gt;&#123;    name:T&#125;let p:IPerson&lt;string&gt;=&#123;    name:&quot;&quot;&#125;let p1:IPerson&lt;number&gt;=&#123;    name:123&#125;\n泛型类class Person&lt;T&gt;&#123;    name:string    age:T    constructor(name:string,age:T)&#123;        this.name=name        this.age=age    &#125;&#125;const person=new Person&lt;string&gt;(&quot;123&quot;,&quot;333&quot;)const person1=new Person&lt;number&gt;(&quot;123&quot;,111)\n\n装饰器装饰器的使用function addAge(constructor:Function)&#123;    constructor.prototype.age = 18&#125;@addAgeclass Person&#123;    name:string;    age!:number;    constructor()&#123;        this.name = &#x27;huihui&#x27;    &#125;&#125;let person = new Person();console.log(person.age);\n\n其他import 和 import type的区别import type 是用来协助进行类型检查和声明的，在运行时是完全不存在的。\n\nimport type\n在ts 3.8中import type，希望能够用一种更加清晰移动的方式来控制某个导入是否要被删除掉\n使用import type 和export type 导入和导出的类型只能在类型上下文中使用，不能作为一个值来使用\n\n\nimport \n会在编译时删掉你导入的类\n\n\n注意点class\nclass既可以代表一个类型，也可以代表一个值，他在runtime是有实际意义的，所以用import type 引入一个class的时候，不能用到它值得含义，不能 extends 这个class\n\n\n不可以同时引入默认个命名绑定使用 import type 的时候，可以引入一个默认导出的类型，也可以引入命名绑定的形式导出的类型，但是不可以同时使用两者.import type Foo,&#123;Bar,Baz&#125; from &#x27;...&#x27;// 借误!仅类型导入可以指定默认导入或命名绑定，但不能同时指定两者\nimport 和 import type有什么区别\n可以导入的内容相同，但是使用的方式不同import 和 import type 都可以导入一个类型或一个值，但是使用import type 导入的值，只能在类型上下文中使用，不能作为一个值来使用，而 import 导入的类型和值，都可以按照其原本的意义试用// type.tsexport type UnionType = string | number;export const unionValue: UnionType = &#x27;1&#x27;;// value.tsimport &#123; UnionType, unionValue &#125; from &#x27;./type&#x27;;const value1: UnionType = &#x27;value1&#x27;; // 作为类型使用const value2: typeof unionValue = &#x27;value2&#x27;; // 获取类型const value3 = unionValue; // 作为值使用// value1.tsimport type &#123; UnionType, unionValue &#125; from &#x27;./type&#x27;;const value1: UnionType = &#x27;value1&#x27;; // 作为类型使用const value2: typeof unionValue = &#x27;value2&#x27;; // 获取类型// Error: &quot;unionValue&quot; 是使用 &quot;import type&quot; 导入的，因此不能用作值const value3 = unionValue; // 作为值使用// import type导入的内容只能用在跟类型相关的地方.\n\n\n\n跟import type有关的tsconfig.json项\nimportsNotUsedAsValues跟 import type 一起在 3.8 中引入的还有一个编译项importsNotUsedAsValues来控制怎么处理在runtime阶段不会用到的import(这里控制import，所有使用import type 的都会在编一阶段被删除),这个编译项有三个值\nremove: 默认行为, 会删除那些仅作为类型出现的导入.(删除仅引用类型的import语句的默认行为。)\npreserve: 保留所有值或者类型没有被使用的导入. 这种方式会保留所有的导入和副作用.\nerror: 这种方式将保留所有的导入(跟preserve一样), 但如果导入的一个值只作为类型被使用, 则会报错.\n\n\n\ntsconfig.json常使用配置项说明&quot;target&quot;: &quot;es2016&quot; //ts最终要编译成js某个的版本&quot;outDir&quot;:&quot;./&quot; // 表示ts文件最终编译为js文件，js文件存放的位置&quot;strict&quot;:&quot;false&quot; //严格模式默认开启\n\n在一个js的rn项目改成ts的步骤\n删除babel.config.js(他俩会有冲突，因为编译时有些地方不一样)\n卸载babel-preset-expo npm uninstall babel-preset-expo\n安装typescript依赖 npm install @types&#x2F;react @types&#x2F;react-native @types&#x2F;expo typescript -D\n创建typescript配置文件 tsc –init\n创建rn-cli.config.jsmodule.exports = &#123;  getTransformModulePath() &#123;    return require.resolve(&quot;react-native-typescript-transformer&quot;);  &#125;,  getSourceExts() &#123;    return [&quot;ts&quot;, &quot;tsx&quot;];  &#125;&#125;;\n\n修改源码修改App.js为App.tsx\n运行npm run android\nRN &gt;&#x3D; 0.59metro.config.js\nmodule.exports = &#123;  transformer: &#123;    babelTransformerPath: require.resolve(&#x27;react-native-typescript-transformer&#x27;)  &#125;&#125;;\nRN &gt;&#x3D; 0.57, &lt; 0.59rn-cli.config.js\nmodule.exports = &#123;  transformer: &#123;    babelTransformerPath: require.resolve(&#x27;react-native-typescript-transformer&#x27;)  &#125;&#125;\nRN &lt; 0.57rn-cli.config.js\nmodule.exports = &#123;  getTransformModulePath() &#123;    return require.resolve(&#x27;react-native-typescript-transformer&#x27;);  &#125;,  getSourceExts() &#123;    return [&#x27;ts&#x27;, &#x27;tsx&#x27;];  &#125;&#125;","categories":["typeScript"]},{"title":"Python","url":"/2021/08/20/Python/","content":"Anaconda\nAnaconda是用来管理python的工具就像，就跟nvm(用来管理node的版本的工具)一样\n\n安装Anaconda这个是用来管理Python版本的，他可以实现Python的多版本切换。安装时按默认的一路next就行。\n看版本\n打开conda prompt，输入conda -V 弹出版本号即为正确安装：栗：C:\\Users\\levero&gt; conda -Vconda 22.9.0conda版本，对上即可\n\n配置库包下载环境，加快网络速度替换下载库包地址为国内的清华镜像站。\n执行下面：\nconda config --set show_channel_urls yes\n生成.condarc 文件在C:\\Users\\leover下用记事本打开并修改.condarc文件。\n把下面的内容全部复制进去，全部覆盖原内容，ctrl+s保存，关闭文件：\nchannels:  - defaultsshow_channel_urls: truechannel_alias: https://mirrors.tuna.tsinghua.edu.cn/anacondadefault_channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloudssl_verify: true\n更改完成后，在命令行输入以下命令完成配置的更新：\nconda config --set show_channel_urls yes\n\nAnaconda修改python版本\n查看选择修改版本号\nconda search –full –name python\n\n\n使用python -V命令查看当前虚拟环境的python版本：\npython -V\n\n\n已知python版本为3.8.0，现在我想把它升级为3.10.6。\n使用命令：\nconda install python&#x3D;3.10.6  &#x2F;&#x2F;3.8版本号\n\n\n如果在conda install python&#x3D;3.10.6中遇到问题，例如：Solving environment: failed with initial frozen solve. Retrying with flexible solve.\n则可以先使用：\nconda uninstall python\n对前版本python进行卸载，然后再使用conda install python&#x3D;3.10.6安装即可。\n\n\n\n\n\n","categories":["python"]},{"title":"expo","url":"/2023/02/19/expo/","content":"什么是expo\nExpo是一组工具、库和服务，可以通过编写javaScript来构建本地的iOS和android应用程序。说人话就是在React Native的基础上在封装一层，让我们开发更加方便，更快\n使用expo，会比你开发一个裸的React Native快很多，而且会少踩很多坑\n没有做过移动端的朋友就更需要这个了，要不然移动端的一些隐藏的限制和坑，会很让人头疼\n\n\n\n项目搭建流程安装expo 安装expocli脚手架npm install --global expo-cli\n创建项目expo init my-project","categories":["RN"]},{"title":"http","url":"/2021/08/07/http/","content":"Js强制缓存和协商缓存\n强制缓存栗子：假如页面需要引入一个logo并且不会频繁的更改，那么就可以tongg服务端响应头中设置强制缓存来优化该请求：// 强制缓存一个月Cache-Control: public, max-age=2592000在用户第一次访问该图片之后，浏览器会将其缓存起来，并且在未过期之前不会再想服务端发送请求。这样减少了网络请求，提高页面加载速度\n协商缓存栗子：在网页中引用了一个JavaScript文件，希望文件发生变化时通知浏览器重新获取最新版本。可以通过在服务端的响应头中设置协商缓存来实现：// 设置 Last-Modified 和 ETagLast-Modified: Mon, 10 Jul 2023 12:00:00 GMTETag: &quot;abcd1234&quot;当浏览器再次发送请求时，会携带上一次请求中的Last-Modified和ETag，服务器会通过对比这些值来判断资源是否发生变化。如果资源未发生变化，服务器返回304 Not Modified，浏览器则使用缓存的版本；如果资源发生了变化，服务器会返回新的资源以及更新的响应头。// 这两个例子展示了如何使用强制缓存和协商缓存来优化网页加载性能。通过合理配置缓存策略，可以有效减少网络请求，提高用户体验。\n\n","categories":["http面试题"]},{"title":"npm命令","url":"/2022/05/20/npm%E5%91%BD%E4%BB%A4/","content":"删除依赖\n删除node包\nnpm uninstall  node包\n\n\n\nnpm install –global、–save、 –save-dev的区别和使用场景npm install(i) moduleName\n安装到本项目node_modules目录下\n\nnpm install –global(-g)\n全局安装\n是一些需要通用的工具类安装，比如npm、yarn\n\nnpm install –save(-S)\n是项目需要的，是项目运行必备，如：vue、element-ui等\n\nnpm install –save-dev(-D)\n是开发时需要的，但是项目运行不必须的，不需要打包到项目里的，如：webkpack、gulp等\n\n","categories":["npm"]},{"title":"package文件解析","url":"/2022/10/29/package/","content":"文件展示当我们搭建一个新项目时，往往脚手架就帮我们初始化好了一个 package.jaon 配置文件，它位于项目的根目录中。当使用 react 脚手架（create-react-app）初始化一个项目时，其 package.json 文件内容如下：\n&#123;  &quot;name&quot;: &quot;my-app&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;private&quot;: true,  &quot;dependencies&quot;: &#123;    &quot;@testing-library/jest-dom&quot;: &quot;^5.14.1&quot;,    &quot;@testing-library/react&quot;: &quot;^11.2.7&quot;,    &quot;@testing-library/user-event&quot;: &quot;^12.8.3&quot;,    &quot;react&quot;: &quot;^17.0.2&quot;,    &quot;react-dom&quot;: &quot;^17.0.2&quot;,    &quot;react-scripts&quot;: &quot;4.0.3&quot;,    &quot;web-vitals&quot;: &quot;^1.1.2&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  &#125;,  &quot;eslintConfig&quot;: &#123;    &quot;extends&quot;: [      &quot;react-app&quot;,      &quot;react-app/jest&quot;    ]  &#125;,  &quot;browserslist&quot;: &#123;    &quot;production&quot;: [      &quot;&gt;0.2%&quot;,      &quot;not dead&quot;,      &quot;not op_mini all&quot;    ],    &quot;development&quot;: [      &quot;last 1 chrome version&quot;,      &quot;last 1 firefox version&quot;,      &quot;last 1 safari version&quot;    ]  &#125;&#125;\n\n必须属性\nname: 项目&#x2F;模块名称，长度必须小于等于214个字符，不能以”.“(点)或者”_“(下划线)开头，不能包含大写字母。\nversion：项目版本version 字段表示该项目包的版本号，它是一个字符串。在每次项目改动后，即将发布时，都要同步的去更改项目的版本号。版本号的使用规范如下：\n版本号的命名遵循语义化版本 2.0.0 规范，格式为：「主版本号. 次版本号. 修订号」，通常情况下，修改主版本号是做了大的功能性的改动，修改次版本号是新增了新功能，修改修订号就是修复了一些 bug；\n如果某个版本的改动较大，并且不稳定，可能如法满足预期的兼容性需求，就需要发布先行版本，先行版本通过会加在版本号的后面，通过 “-” 号连接以点分隔的标识符和版本编译信息：内部版本（alpha）、公测版本（beta）和候选版本（rc，即 release candiate）// 查看最新版本npm view react version// 查看所有版本npm view react versions\n\n\n\n描述信息package.jaon 中有五个和项目包描述信息相关的配置字段，下面就分别来看看这些字段的含义。\ndescription\ndescription 字段用来描述这个项目包，它是一个字符串，可以让其他开发者在 npm 的搜索中发现我们的项目包。\n\nkeywords\nkeywords 字段是一个字符串数组，表示这个项目包的关键词。和 description 一样，都是用来增加项目包的曝光率的。下面是 eslint 包的描述和关键词：\n\n\nauthor\nauthor 顾名思义就是作者，表示该项目包的作者。它有两种形式，一种是字符串格式：&quot;author&quot;: &quot;CUGGZ &lt;xxxxx@xx.com&gt; (https://juejin.cn/user/3544481220801815)&quot; \n另一种是对象形式：&quot;author&quot;: &#123;  &quot;name&quot; : &quot;CUGGZ&quot;,  &quot;email&quot; : &quot;xxxxx@xx.com&quot;,  &quot;url&quot; : &quot;https://juejin.cn/user/3544481220801815&quot;&#125;\n\ncontributors\ncontributors 表示该项目包的贡献者，和 author 不同的是，该字段是一个数组，包含所有的贡献者，它同样有两种写法：&quot;contributors&quot;: [  &quot;liuxiaoye &lt;xxxxx@xx.com&gt; (xxxx)&quot;,  &quot;liuxiaoye &lt;xxxxx@xx.com&gt; (xxxx)&quot; ] \n&quot;contributors&quot;: [  &#123;   &quot;name&quot; : &quot;liuxiaoye&quot;,   &quot;email&quot; : &quot;xxxxx@xx.com&quot;,   &quot;url&quot; : &quot;xxxx&quot; &#125;,  &#123;   &quot;name&quot; : &quot;liuxiaoye&quot;,   &quot;email&quot; : &quot;xxxxx@xx.com&quot;,   &quot;url&quot; : &quot;xxxx&quot; &#125; ]\n\nhomepagehomepage 就是项目的主页地址了，它是一个字符串。\nrepositoryrepository 表示代码的存放仓库地址，通常有两种书写形式。第一种是字符串形式：\n&quot;repository&quot;: &quot;https://github.com/facebook/react.git&quot; \n除此之外，还可以显式地设置版本控制系统，这时就是对象的形式：\n&quot;repository&quot;: &#123;  &quot;type&quot;: &quot;git&quot;,  &quot;url&quot;: &quot;https://github.com/facebook/react.git&quot;&#125;\nbugsbugs 表示项目提交问题的地址，该字段是一个对象，可以添加一个提交问题的地址和反馈的邮箱：\n&quot;bugs&quot;: &#123;   &quot;url&quot; : &quot;https://github.com/facebook/react/issues&quot;,  &quot;email&quot; : &quot;xxxxx@xx.com&quot;&#125;\n最常见的 bugs 就是 Github 中的 issues 页面，如上就是 react 的 issues 页面地址。\n依赖配置通常情况下，我们的项目会依赖一个或者多个外部的依赖包，根据依赖包的不同用途，可以将他们配置在下面的五个属性下：dependencies、devDependencies、peerDependencies、bundledDependencies、optionalDependencies 。下面就来看看每个属性的含义。\ndependenciesdependencies 字段中声明的是项目的生产环境中所必须的依赖包。当使用 npm 或 yarn 安装 npm 包时，该 npm 包会被自动插入到此配置项中：\nnpm install &lt;PACKAGENAME&gt;yarn add &lt;PACKAGENAME&gt;\n当在安装依赖时使用 –save 参数，也会将新安装的 npm 包写入 dependencies 属性。\nnpm install --save &lt;PACKAGENAME&gt;\n该字段的值是一个对象，该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。\n&quot;dependencies&quot;: &#123;   &quot;react&quot;: &quot;^17.0.2&quot;,   &quot;react-dom&quot;: &quot;^17.0.2&quot;,   &quot;react-scripts&quot;: &quot;4.0.3&quot;,&#125;,\n\n这里每一项配置都是一个键值对（key-value）， key 表示模块名称，value 表示模块的版本号。版本号遵循「主版本号. 次版本号. 修订号」的格式规定：\n\n「固定版本：」 上面的 react-scripts 的版本 4.0.3 就是固定版本，安装时只安装这个指定的版本；\n\n「波浪号：」 比如~ 4.0.3，表示安装 4.0.x 的最新版本（不低于 4.0.3），也就是说安装时不会改变主版本号和次版本号；\n\n「插入号：」 比如上面 react 的版本 ^17.0.2，表示安装 17.x.x 的最新版本（不低于 17.0.2），也就是说安装时不会改变主版本号。如果主版本号为 0，那么插入号和波浪号的行为是一致的；\n\nlatest：安装最新的版本。\n\n\n需要注意，不要把测试或者过渡性的依赖放在 dependencies，避免生产环境出现意外的问题。\ndevDependenciesdevDependencies 中声明的是开发阶段需要的依赖包，如 Webpack、Eslint、Babel 等，用于辅助开发。它们不同于 dependencies，因为它们只需安装在开发设备上，而无需在生产环境中运行代码。当打包上线时并不需要这些包，所以可以把这些依赖添加到 devDependencies 中，这些依赖依然会在本地指定 npm install 时被安装和管理，但是不会被安装到生产环境中。\n当使用 npm 或 yarn 安装软件包时，指定以下参数后，新安装的 npm 包会被自动插入到此列表中：\nnpm install --save-dev &lt;PACKAGENAME&gt;yarn add --dev &lt;PACKAGENAME&gt;\n&quot;devDependencies&quot;: &#123;  &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,  &quot;babel-core&quot;: &quot;^6.22.1&quot;&#125;\n\npeerDependencies如果需要在找不到包或者安装包失败时，npm 仍然能够继续运行，则可以将该包放在 optionalDependencies 对象中，optionalDependencies 对象中的包会覆盖 dependencies 中同名的包，所以只需在一个地方进行设置即可。\n需要注意，由于 optionalDependencies 中的依赖可能并未安装成功，所以一定要做异常处理，否则当获取这个依赖时，如果获取不到就会报错。\nbundledDependencies上面的几个依赖相关的配置项都是一个对象，而 bundledDependencies 配置项是一个数组，数组里可以指定一些模块，这些模块将在这个包发布时被一起打包。\n需要注意，这个字段数组中的值必须是在 dependencies, devDependencies 两个里面声明过的包才行。\nengines当我们维护一些旧项目时，可能对 npm 包的版本或者 Node 版本有特殊要求，如果不满足条件就可能无法将项目跑起来。为了让项目开箱即用，可以在 engines 字段中说明具体的版本号：\n&quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=8.10.3 &lt;12.13.0&quot;,  &quot;npm&quot;: &quot;&gt;=6.9.0&quot;&#125;\n需要注意，engines 只是起一个说明的作用，即使用户安装的版本不符合要求，也不影响依赖包的安装。\n脚本配置scriptsscripts 是 package.json 中内置的脚本入口，是 key-value 键值对配置，key 为可运行的命令，可以通过 npm run 来执行命令。除了运行基本的 scripts 命令，还可以结合 pre 和 post 完成前置和后续操作。先来看一组 scripts：\n&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;node index.js&quot;,  &quot;predev&quot;: &quot;node beforeIndex.js&quot;,  &quot;postdev&quot;: &quot;node afterIndex.js&quot;&#125;\n这三个 js 文件中都有一句 console：\n// index.jsconsole.log(&quot;scripts: index.js&quot;)// beforeIndex.jsconsole.log(&quot;scripts: before index.js&quot;)// afterIndex.jsconsole.log(&quot;scripts: after index.js&quot;)复制代码\n\n当我们执行 npm run dev 命令时，输出结果如下：\nscripts: before index.jsscripts: index.jsscripts: after index.js复制代码\n可以看到，三个命令都执行了，执行顺序是 predev→dev→postdev。如果 scripts 命令存在一定的先后关系，则可以使用这三个配置项，分别配置执行命令。\n通过配置 scripts 属性，可以定义一些常见的操作命令：\n&quot;scripts&quot;: &#123;  &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,  &quot;start&quot;: &quot;npm run dev&quot;,  &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,  &quot;test&quot;: &quot;npm run unit&quot;,  &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit&quot;,  &quot;build&quot;: &quot;node build/build.js&quot;&#125;\n这些脚本是命令行应用程序。可以通过调用 npm run XXX 或 yarn XXX 来运行它们，其中 XXX 是命令的名称。例如：npm run dev。我们可以为命令使用任何的名称，脚本也可以是任何操作。\n使用好该字段可以大大的提升开发效率。\nconfigconfig 字段用来配置 scripts 运行时的配置参数，如下所示：\n&quot;config&quot;: &#123; &quot;port&quot;: 3000&#125;\n如果运行 npm run start，则 port 字段会映射到npm_package_config_port环境变量中：\nconsole.log(process.env.npm_package_config_port) // 3000\n用户可以通过npm config set foo:port 3001 命令来重写 port 的值。\n文件 &amp; 目录下面来看看 package.json 中和文件以及目录相关的属性。\nmainmain 字段用来指定加载的入口文件，在 browser 和 Node 环境中都可以使用。如果我们将项目发布为 npm 包，那么当使用 require 导入 npm 包时，返回的就是 main 字段所列出的文件的 module.exports 属性。如果不指定该字段，默认是项目根目录下的 index.js。如果没找到，就会报错。\n该字段的值是一个字符串：\n&quot;main&quot;: &quot;./src/index.js&quot;,\n\nbrowserbrowser 字段可以定义 npm 包在 browser 环境下的入口文件。如果 npm 包只在 web 端使用，并且严禁在 server 端使用，使用 browser 来定义入口文件。\n&quot;browser&quot;: &quot;./src/index.js&quot; \nmodulemodule 字段可以定义 npm 包的 ESM 规范的入口文件，browser 环境和 node 环境均可使用。如果 npm 包导出的是 ESM 规范的包，使用 module 来定义入口文件。\n&quot;module&quot;: &quot;./src/index.mjs&quot;,\n需要注意，.js 文件是使用 commonJS 规范的语法 (require(‘xxx’))，.mjs 是用 ESM 规范的语法 (import ‘xxx’)。\n上面三个的入口入口文件相关的配置是有差别的，特别是在不同的使用场景下。在 Web 环境中，如果使用 loader 加载 ESM（ES module），那么这三个配置的加载顺序是 browser→module→main，如果使用 require 加载 CommonJS 模块，则加载的顺序为 main→module→browser。\nWebpack 在进行项目构建时，有一个 target 选项，默认为 Web，即构建 Web 应用。如果需要编译一些同构项目，如 node 项目，则只需将 webpack.config.js 的 target 选项设置为 node 进行构建即可。如果在 Node 环境中加载 CommonJS 模块，或者 ESM，则只有 main 字段有效。\nbinbin 字段用来指定各个内部命令对应的可执行文件的位置：\n&quot;bin&quot;: &#123;  &quot;someTool&quot;: &quot;./bin/someTool.js&quot;&#125;\n这里，someTool 命令对应的可执行文件为 bin 目录下的 someTool.js，someTool.js 会建立符号链接 node_modules&#x2F;.bin&#x2F;someTool。由于 node_modules&#x2F;.bin &#x2F; 目录会在运行时加入系统的 PATH 变量，因此在运行 npm 时，就可以不带路径，直接通过命令来调用这些脚本。因此，下面的写法可以简写：\nscripts: &#123;    start: &#x27;./node_modules/bin/someTool.js build&#x27;&#125; // 简写scripts: &#123;    start: &#x27;someTool build&#x27;&#125;\n所有 node_modules&#x2F;.bin &#x2F; 目录下的命令，都可以用 npm run [命令] 的格式运行。\n上面的配置在 package.json 包中提供了一个映射到本地文件名的 bin 字段，之后 npm 包将链接这个文件到 prefix&#x2F;fix 里面，以便全局引入。或者链接到本地的 node_modules&#x2F;.bin &#x2F; 文件中，以便在本项目中使用。\nfilesfiles 配置是一个数组，用来描述当把 npm 包作为依赖包安装时需要说明的文件列表。当 npm 包发布时，files 指定的文件会被推送到 npm 服务器中，如果指定的是文件夹，那么该文件夹下面所有的文件都会被提交。\n&quot;files&quot;: [    &quot;LICENSE&quot;,    &quot;Readme.md&quot;,    &quot;index.js&quot;,    &quot;lib/&quot; ]\n如果有不想提交的文件，可以在项目根目录中新建一个. npmignore 文件，并在其中说明不需要提交的文件，防止垃圾文件推送到 npm 上。这个文件的形式和. gitignore 类似。写在这个文件中的文件即便被写在 files 属性里也会被排除在外。比如可以在该文件中这样写：\nnode_modules.vscode build .DS_Store\n\nmanman 命令是 Linux 中的帮助指令，通过该指令可以查看 Linux 中的指令帮助、配置文件帮助和编程帮助等信息。如果 node.js 模块是一个全局的命令行工具，在 package.json 通过 man 属性可以指定 man 命令查找的文档地址：\n&quot;man&quot;: [ &quot;./man/npm-access.1&quot;, &quot;./man/npm-audit.1&quot;]\nman 字段可以指定一个或多个文件, 当执行 man {包名} 时, 会展现给用户文档内容。需要注意\n\nman 文件必须以数字结尾，如果经过压缩，还可以使用. gz 后缀。这个数字表示文件安装到哪个 man 节中；\n如果 man 文件名称不是以模块名称开头的，安装的时候会加上模块名称前缀。对于上面的配置，可以使用以下命令来执行查看文档：man npm-accessman npm-audit\n\ndirectoriesdirectories 字段用来规范项目的目录。node.js 模块是基于 CommonJS 模块化规范实现的，需要严格遵循 CommonJS 规范。模块目录下除了必须包含包项目描述文件 package.json 以外，还需要包含以下目录：\n\nbin ：存放可执行二进制文件的目录\nlib ：存放 js 代码的目录\ndoc ：存放文档的目录\ntest ：存放单元测试用例代码的目录\n…\n\n在实际的项目目录中，我们可能没有按照这个规范进行命名，那么就可以在 directories 字段指定每个目录对应的文件路径：\n&quot;directories&quot;: &#123;    &quot;bin&quot;: &quot;./bin&quot;,    &quot;lib&quot;: &quot;./lib&quot;,    &quot;doc&quot;: &quot;./doc&quot;,    &quot;test&quot; &quot;./test&quot;,    &quot;man&quot;: &quot;./man&quot;&#125;,\n这个属性实际上没有什么实际的作用，当然不排除未来会有什么比较有意义的用处。\n发布配置npm 项目包发布相关的配置。\nprivateprivate 字段可以防止我们意外地将私有库发布到 npm 服务器。只需要将该字段设置为 true：\n&quot;private&quot;: true\npreferGlobalpreferGlobal 字段表示当用户不把该模块安装为全局模块时，如果设置为 true 就会显示警告。它并不会真正的防止用户进行局部的安装，只是对用户进行提示，防止产生误解：\n&quot;preferGlobal&quot;: true\npublishConfigpublishConfig 配置会在模块发布时生效，用于设置发布时一些配置项的集合。如果不想模块被默认标记为最新，或者不想发布到公共仓库，可以在这里配置 tag 或仓库地址。更详细的配置可以参考 npm-config[1]。\n通常情况下，publishConfig 会配合 private 来使用，如果只想让模块发布到特定 npm 仓库，就可以这样来配置：\n&quot;private&quot;: true,&quot;publishConfig&quot;: &#123;  &quot;tag&quot;: &quot;1.1.0&quot;,  &quot;registry&quot;: &quot;https://registry.npmjs.org/&quot;,  &quot;access&quot;: &quot;public&quot;&#125;\n\nosos 字段可以让我们设置该 npm 包可以在什么操作系统使用，不能再什么操作系统使用。如果我们希望开发的 npm 包只运行在 linux，为了避免出现不必要的异常，建议使用 Windows 系统的用户不要安装它，这时就可以使用 os 配置：\n&quot;os&quot; [&quot;linux&quot;]   // 适用的操作系统&quot;os&quot; [&quot;!win32&quot;]  // 禁用的操作系统\n\ncpu该配置和 OS 配置类似，用 CPU 可以更准确的限制用户的安装环境：\n&quot;cpu&quot; [&quot;x64&quot;, &quot;AMD64&quot;]   // 适用的cpu&quot;cpu&quot; [&quot;!arm&quot;, &quot;!mips&quot;]  // 禁用的cpu\n可以看到，黑名单和白名单的区别就是，黑名单在前面加了一个 “!”。\nlicenselicense 字段用于指定软件的开源协议，开源协议表述了其他人获得代码后拥有的权利，可以对代码进行何种操作，何种操作又是被禁止的。常见的协议如下：\n\nMIT ：只要用户在项目副本中包含了版权声明和许可声明，他们就可以拿你的代码做任何想做的事情，你也无需承担任何责任。\nApache ：类似于 MIT ，同时还包含了贡献者向用户提供专利授权相关的条款。\nGPL ：修改项目代码的用户再次分发源码或二进制代码时，必须公布他的相关修改。\n\n可以这样来声明该字段：\n&quot;license&quot;: &quot;MIT&quot;\n\n第三方配置typingstypings 字段用来指定 TypeScript 的入口文件：\n&quot;typings&quot;: &quot;types/index.d.ts&quot;,\n该字段的作用和 main 配置相同。\neslintConfigeslint 的配置可以写在单独的配置文件. eslintrc.json 中，也可以写在 package.json 文件的 eslintConfig 配置项中。\n&quot;eslintConfig&quot;: &#123;      &quot;root&quot;: true,      &quot;env&quot;: &#123;        &quot;node&quot;: true      &#125;,      &quot;extends&quot;: [        &quot;plugin:vue/essential&quot;,        &quot;eslint:recommended&quot;      ],      &quot;rules&quot;: &#123;&#125;,      &quot;parserOptions&quot;: &#123;        &quot;parser&quot;: &quot;babel-eslint&quot;     &#125;,&#125;\n\nbabelbabel 用来指定 Babel 的编译配置，代码如下：\n&quot;babel&quot;: &#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;], &quot;plugins&quot;: [...]&#125;\n\nunpkg使用该字段可以让 npm 上所有的文件都开启 cdn 服务，该 CND 服务由 unpkg 提供：\n&quot;unpkg&quot;: &quot;dist/vue.js&quot;\n\nlint-stagedlint-staged 是一个在 Git 暂存文件上运行 linters 的工具，配置后每次修改一个文件即可给所有文件执行一次 lint 检查，通常配合 gitHooks 一起使用。\n&quot;lint-staged&quot;: &#123; &quot;*.js&quot;: [   &quot;eslint --fix&quot;,    &quot;git add&quot;  ]&#125;\n使用 lint-staged 时，每次提交代码只会检查当前改动的文件。\ngitHooksgitHooks 用来定义一个钩子，在提交（commit）之前执行 ESlint 检查。在执行 lint 命令后，会自动修复暂存区的文件。修复之后的文件并不会存储在暂存区，所以需要用 git add 命令将修复后的文件重新加入暂存区。在执行 pre-commit 命令之后，如果没有错误，就会执行 git commit 命令：\n&quot;gitHooks&quot;: &#123; &quot;pre-commit&quot;: &quot;lint-staged&quot;&#125;\n这里就是配合上面的 lint-staged 来进行代码的检查操作。\nbrowserslistbrowserslist 字段用来告知支持哪些浏览器及版本。Babel、Autoprefixer 和其他工具会用到它，以将所需的 polyfill 和 fallback 添加到目标浏览器。比如最上面的例子中的该字段值：\n&quot;browserslist&quot;: &#123;  &quot;production&quot;: [    &quot;&gt;0.2%&quot;,    &quot;not dead&quot;,    &quot;not op_mini all&quot;  ],  &quot;development&quot;: [    &quot;last 1 chrome version&quot;,    &quot;last 1 firefox version&quot;,    &quot;last 1 safari version&quot;  ]&#125;\n这里指定了一个对象，里面定义了生产环境和开发环境的浏览器要求。上面的 development 就是指定开发环境中支持最后一个版本的 chrome、Firefox、safari 浏览器。这个属性是不同的前端工具之间共用目标浏览器和 node 版本的配置工具，被很多前端工具使用，比如 Babel、Autoprefixer 等。\n","categories":["解析"]},{"title":"react面试题","url":"/2021/09/13/react/","content":"React面试题props接受任意参，那具体使用场景都有哪些\n1.基础数组类型，复合数据类型\n2.直接传递一组件\n3.可以通过函数接收Html一个片段\n4.props.children\n5.{…obj}\n6.cakkback 子传父\n\ncontext的使用场景有哪些，分别是什么？与props的区别是什么？\n1.基础数组类型，复合数据类型\n2.直接传递一组件\n3.可以通过函数接收Html一个片段\n4.callback子传父\n5.{…obj}区别解决propse一代传一代问题，context可以跨组件数据通信\n\nReact中事件this邦定的实现方法有哪些?\n1.调用时使用this.set.bind(this)\n2.在constructor中绑定this.set&#x3D;this.set.bind(this)\n3.使用箭头函数进行绑定\n4.onClick&#x3D;{()&#x3D;&gt;{this.set()}}\n\nReact组件生命周期的阶段是什么？常用生命周期方法有哪些？挂载、更新、卸载挂载 constructor  render  componentDidMount更新componentDidUpdate render卸载componentWillUnmountconstructor 用来设置state默认值的componentDidMount ajax 请求 定时器设置的componentWillUnmount  清定时器、取消ajax请求\nstate 修改的三种方式1、this.setState(&#123;    &#x27;a&#x27;:&#x27;3&#x27;&#125;)2、this.setState((state,props)=&gt;(&#123;    a:state.a+1&#125;))3、this.setState(&#123;    obj:&#123;        ...this.state.obj,        &#x27;a&#x27;:&#x27;3&#x27;    &#125;,    obj:Object.assign(&#123;&#125;,this.state.obj,&#123;&#x27;a&#x27;:&#x27;3&#x27;&#125;)&#125;)&lt;select multiple=&#123;true&#125; value=&#123;[&#x27;B&#x27;, &#x27;C&#x27;]&#125;&gt;              &lt;option value=&quot;B&quot;&gt;葡萄柚&lt;/option&gt;              &lt;option value=&quot;C&quot;&gt;酸橙&lt;/option&gt;              &lt;option value=&quot;E&quot;&gt;酸橙&lt;/option&gt;              &lt;option value=&quot;F&quot;&gt;酸橙&lt;/option&gt;&lt;/select&gt;\n\n函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对应类组件生命周期的？props接收方式不一样render渲染方式不一样函数组件没有state函数组件也没有生命周期\n\n生命周期挂载、更新、卸载\n挂载 constructor render componentDidMount\n更新 componentDidUpdate render\n卸载componentWillUnmount\n\n\n\nuseEffectuseEffect(()=&gt;&#123;&#125;,[])componentDidMount useEffect(()=&gt;&#123;&#125;,[count])componentDidUpdate useEffect(()=&gt;&#123;return()=&gt;&#123;    &#125; componentWillUnmount  &#125;,[])\n\nreact是单向数据流，如何实现数据双向绑定通过onChange事件进行实时监听来获取value值 通过serState来实现数据双想绑定\nvue、react打包的项目自定义路径 是否可以正常使用无法正常使用需要在nginx进行url重写\n我js中会使用return false来组件默认事件，react中有合成事件想阻止默认事件以及阻止冒泡事件应该怎么做？e.preventDefault()、e.stopPropagation();\n在react开发中会涉及到多个组件交互操作，如果当前组件有ajax未请求完成，这时直接跳到另一个组件会报错，我们如何来阻止报错。在componentWillUnmount（）组件中取消或终止ajax请求\n当前组件引入一个子组件，如何在子组件中获取到这个data的值，并且使用es6进行改写this.props.data&lt;App {…data}&#x2F;&gt;\n路由中NavLink 与Link什么区别？NavLink 当前选中会增加默认一个classname 而link直接就是链接跳转\n路由传参的三种方式？params,query,statereact路由传参(3种方式)\n1、params传参(刷新页面后参数不消失，参数会在地址栏显示)上文的动态路由实现方式\n&lt;Route exact path=&quot;/ceshi&quot; component=&#123;Ceshi&#125; /&gt;&lt;Route exact path=&#123;`/ceshi/:page`&#125; component=&#123;Ceshi&#125; /&gt;&lt;Route path=&#123;`/ceshi/:page/:id`&#125; component=&#123;Ceshi&#125; /&gt;路由跳转并传递参数：链接方式：&lt;Link to=&#123;`/ceshi/tg`&#125;&gt;通过&lt;/Link&gt;或：&lt;Link to=&#123;&#123;pathname:`/ceshi/tg`&#125;&#125;&gt;通过&lt;/Link&gt;js方式：this.props.history.push(`/ceshi/tg`)或：this.props.history.push(&#123;pathname:`/ceshi/tg`&#125;)页面获取参数：this.props.match.params.pagethis.props.match.params.id//注意这里是match而非history\n\n2、query传参(刷新页面后参数消失)\n路由页面：&lt;Route path=&#x27;/ceshi&#x27; component=&#123;CeShi&#125;/&gt;  //无需配置路由跳转并传递参数：链接方式：&lt;Link to=&#123;&#123;pathname:`/ceshi`,query:&#123;id:6,url:&#x27;tg&#x27;&#125;&#125;&#125;&gt;通过&lt;/Link&gt;js方式：this.props.history.push(&#123;pathname:`/ceshi`,query:&#123;id:6,url:&#x27;tg&#x27;&#125;&#125;)---获取参数： this.props.location.query.name\n\n3、state传参( 刷新页面后参数不消失，state传的参数是加密的，比query传参好用)注：state 传参的方式只支持Browserrouter路由，不支持hashrouter\n路由页面：&lt;Route path=&#x27;/demo&#x27; component=&#123;Ceshi&#125;/&gt;  //无需配置路由跳转并传递参数：链接方式： &lt;Link to=&#123;&#123;pathname:`/ceshi`,state:&#123;id:12,url:&#x27;tg&#x27;&#125;&#125;&#125;&gt;通过&lt;/Link&gt;js方式：this.props.history.push(&#123;pathname:`/ceshi`,state:&#123;id:12,url:&#x27;tg&#x27;&#125;&#125;)---获取参数： this.props.location.state.url\n\n如何在组件更新时再发起一个ajax 请求，在更新时需要注意什么？使用if判断某个值是否改变，当此值改变后在调用ajax函数\n已知对象boj,jajx返回一个后如何合并原有对象，使用至少两种方式实现ajax(url,fn(res))&#123;  // 假设res为对象  this.setState(&#123;    obj:&#123;this.state.obj,...res&#125;  &#125;)  Object.assign(&#123;&#125;,obj,res)&#125;\n\n路由值系页面可以使用history，那非值系，隔代页面中如何使用路由相关信息withrouter\nreact是单向数据流，如何实现数据双向邦定？如何修改state自身值而使其可以累加？\n通过onChange事件进行时时监听来获取value值 通过setState来实现数据双向邦定this.setState((state,props)=&gt;(&#123;         page:state.page+1&#125;))\n\n在使用react项目开发时，你是如何与后端进行接口连调的在src中的react&#x2F;first-react&#x2F;src&#x2F;setupProxy.js配置在线接口的url，从而使用在线接口代理 到本地3000下\nprops接收任意参，那具体使用场景都有哪些？context的使用场景有哪些，分别是什么props\n\n基础数组类型，复合数据类型\n直接传递一组件\n可以通过函数接收Html一个片段\nprops.children\ncallback 子传父\n\nContext解决props一代传一代问题，context可以跨页面数据通信\n\n基础数组类型，复合数据类型\n直接传递一组件\n可以通过函数接收Html一个片段\ncallback 子传父\n\n函数组件和类组件的区别是什么？说说类组件的生命周期？hook中的useEffect如何对类组件生命周期的？区别：props接受方式不一样render渲染方式不一样函数没有state函数组件也没有state函数组件也没有生命周期生命周期挂载、更新、卸载挂载 constructor render componentDidMount更新 componentDidUpdate render卸载 componentWillUnmount\nuseEffect：useEffect(()&#x3D;&gt;{},[])componentDidMountuseEffect(()&#x3D;&gt;{},[count])componentDidUpdateuseEffect(()&#x3D;&gt;{return()&#x3D;&gt;{  }componentWillUnmount},[])\nMobx\n简述一下你对mobx的理解，以及你在项目中使用mobx的流程是什么(类组件与函数组件)\n\n结合react的State和setState 把moxb简单概括为三点1.定义一个observable 相当于我们的state2.想要更改observable需要使用action 相当于我们setState3.在视图中我们通过@observer 来响应数据变化项目中使用：\n\n安装\n安装mobx mobx-React\n解决@修饰符\n\n\nrouter.js\n引入 Provider\n引入store.js\n合并拆分 生成大store\nApp 外使用 Provider 并且…store\n\n\nstore.js\n包引入\noberservale\naction\n\n\n页面获取\n包引入\n@withrouter\n@inject\n@observer\n\n\nhookimport &#123;observer,MobXProviderContext&#125; from &#x27;mobx-react&#x27;;import &#123; withRouter&#125; from &#x27;react-router-dom&#x27;;function useStores(name)&#123;  return React.useContext(MobXProviderContext)[name]&#125;const &#123; tradeCfg &#125; = useStores(&#x27;FirstStore&#x27;)const &#123; name &#125; =  useStores(&#x27;SecondStore&#x27;);export default withRouter(observer(View));\n\n简述一下你对redux的理解，以及你在项目中使用redux的流程是什么（类组件与函数组件）？结合react 的State 可以把redux 简单概括为三点1、通过Store.getState()来获取整个数据源2、通过触发action 来修改State ,而修改action的唯一途径就是dispatch3、使用一个reducer 纯函数来接收state 和action 从面生成新的state,再使用createStore来创建一个Redux 的Store而在项目中使用流程是：1、安装2、router.js3、store.js4、view&#x2F;home&#x2F;redux    actions.js    actointypes.js    reducer.js    _index.js5、页面\nimport &#123;connect&#125; from &#x27;react-redux&#x27;;import &#123;actions&#125; from &#x27;./_index.js&#x27;;function mapStateToProps(state) &#123;    return &#123;        addList:state.add    &#125;&#125;const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;    return &#123;        onAddFn:()=&gt;dispatch(actions.add())    &#125;&#125;;export default connect(mapStateToProps,mapDispatchToProps)(View);this.props\n函数\nimport &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;const state = useSelector((state)=&gt;state);const add = useSelector((state)=&gt;state.add);const dispatch = useDispatch();useEffect(()=&gt;&#123;    dispatch(actions.add())&#125;,[])\n\n\nReact是什么，它的优缺点，它和vue的区别React是什么\nReact是一个JavaScript库，用于构建高效、快速的用户界面。React主要用于构建Ui\n\n它的优缺点优点\n\nReact速度快\n在React并不会直接对DOM进行操作，而是引入了一个叫虚拟DOM的概念，安插在javascript逻辑和实际的DOM之间，性能很好\n\n\n性能好&#x2F;跨浏览器兼容\n虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没有问题的\n\n\n一切都是component&#x2F;代码模块化\n代码模块化，重用代码更容易\n\n\n单向数据流\nFlux是一个用于在JavaScript应用程序中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化\n\n\n兼容性好\n比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用，它们使得那些艰难的任务不再让人望人生畏。\n\n\n同构、纯粹的JavaScript\n因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化\n\n\n\n缺点\n\nReact只是视图层的一个框架，如果需要做其他事情，需要依赖它的生态系统；比如使用路由需要用到Router，处理数据需要用到Redux\n\n学习成本高\n\n\n开发工具 react-devtool 安装⚙️ 如何手动添加一个chrome扩展\n\n解压 react-devtools.zip 到磁盘一个用来保存 chrome 扩展的文件夹中\n打开 chrome 浏览器…菜单，更多工具 &#x2F; 扩展程序\n打开开发者模式\n将 react-devtools 文件夹拖入到当前界面中，完成\n\n\n\n其他 -扩展react Hooks状态库\nahooks (阿里巴巴出品的的一个react Hooks库)\n\nredux与rtk的区别\n1、reduxjs&#x2F;tookit相对于react-redux来说比较方便，集成了redux-devtools-extension，不需要额外的配置，非常方便\n2、reduxjs&#x2F;tookit集成immutable-js的功能，不需要安装配置使用，提升了开发效率\n3、reduxjs&#x2F;tookit集成了redux-thunk的功能\n4、reduxjs&#x2F;tookit将types、actions、reducers放在一起组成了全新的slices，简化了我们的使用\n\n如何在react中使用sass\n首先安装依赖 npm install –save-dev node-sass\n\ncreate-react-app 创建的react项目默认就是支持Sass的，使用只要安装node-sass即可使用\n\n\n","categories":["react"],"tags":["jQuery","表格","表单验证"]},{"title":"从零开始react Native","url":"/2022/02/13/reactNative/","content":"\n\n\n基础expo\nexpo是什么？\nexpo是基于expo框架与react-native语法的App开发\n\n\n\n","categories":["RN"]},{"title":"webpack文件解析","url":"/2022/10/30/webpack/","content":"什么是webpackwebpack本身是，node的一个第三方模块包，用于打包代码\nwebpack执行流程\nwebpack默认只能打包.js结尾的文件，处理不了其它后缀的文件\n由于代码中包含了index.css这个文件，因此webpack默认处理不了\n当webpack发现某个文件处理不了的时候，会查找webpack.config.js这个配置文件，看module.rules数组中，是否配置了对应的loader加载器\nwebpack把index.css这个文件，先转交给最后一个loader进行处理(先转交给css-loader)。\n当css-loader处理完毕后，会把处理结果，转交给下一个loader(转交给styule-loader)\n当style-loader处理完毕后，发现没有下一个loader了，于是把处理的结果，转交给了webpack\nwebpack把style-loader的处理结果，合并到&#x2F;dist&#x2F;bundle.js中，最终生成打包好的文件。\n\nwebpack能做什么把很多文件打包整合到一起，缩小项目体积，提高加载速度栗子：\n\n打包前200MB\n打包后2MB\n\n\n其中功能：\nless&#x2F;sass -&gt;css\nES6&#x2F;7&#x2F;8 -&gt;ES5处理js兼容\n支持js模块化\n处理css兼容性\nhtml&#x2F;css&#x2F;js -&gt; 压缩合并\n\nwebpack的使用1.初始化包环境\nyarn init\n2.安装依赖包\n安装项目yarn add webpack webpack-cli -D   安装全局yarn add webpack webpack-cli -g  \n3.创建webpack.config.js跟src目录同级或packjson文件同级\n// 因为webpack是基于nodejs构建的// 所以支持commonjs规范 暴露对象使用module.exportsconst path = require(&#x27;path&#x27;) // 导出配置项module.exports= &#123;    // 指定模式伪开发者模式    mode:&#x27;development&#x27;,    // 入口    entry: &#x27;./src/index.js&#x27;,    // 出口    output:&#123;        // 打开的文件路径  打包后存放文件的位置        path :path.resolve(__dirname, &#x27;./dist&#x27;),        // 打包的文件名        filename:&#x27;tt.js&#x27;    &#125;,    module:&#123;        // 配置规则        rules:[            // 每一个对象代表一个规则            &#123;                // 匹配以css结尾的文件                test:/\\.css$/,                // 使用一个lpader处理                // loader:&#x27;css-loader&#x27;                // use:[&#x27;css-loader&#x27;],                // 使用多个loader处理                // use属性来告知webpack使用什么样的loader                // 注意：因为loader的执行顺序是从右向左(或者说从下到上，或者说从后到前的)，所以我们需要将style-loader写到css-loader的前面                use:[                    &#123;                        loader:&#x27;style-loader&#x27;                    &#125;,                    &#123;                        loader:&#x27;css-loader&#x27;,                        // loader配置                        // options:&#123;&#125;                    &#125;                ]            &#125;        ]    &#125;&#125;\n4.配置scripts(自定义命令)\nscripts: &#123;\t&quot;build&quot;: &quot;webpack&quot;&#125;\n5.运行打包命令\nyarn build或者 npm run build\n总结：src同级目录，生成默认dist目录和打包默认main.js文件，默认会打包src下的index.js\nwebpack更新打包代码变更\n\n重新打包 yarn build\n\n总结：src下开发环境，dist是打包后，分别独立总结：打包后格式压缩，变量压缩等\nwebpack配置webpack的入口和出口从哪开始打包，打包后输入到哪里\n默认出口：.&#x2F;src&#x2F;index.js默认出口：.&#x2F;dist&#x2F;main.js\nwebpack配置 - webpack.config.js(默认)\n\n新建src同级处，webpack.config.js\n填入配置项const path = require(&quot;path&quot;)module.exports = &#123;    entry: &quot;./src/main.js&quot;, // 入口    output: &#123;         path: path.join(__dirname, &quot;dist&quot;), // 出口路径        filename: &quot;bundle.js&quot; // 出口文件名    &#125;&#125;\n修改package.json，自定义打包命令 - 让 webpack使用配置文件&quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;webpack&quot;&#125;,\n打包观察效果\n\n打包流程图所有要被打包的资源都要跟入口产生直接&#x2F;间接的引用关系\n插件-自动生成html文件 html-webpack-plugin插件, 让webpack打包后生成html文件并自动引入打包后的js\n\n下载插件yarn add html-webpack-plugin  -D\nwebpack.config.js配置// 引入自动生成 html 的插件const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    // ...省略其他代码    plugins: [        new HtmlWebpackPlugin()    ]&#125;\n重新打包后观察dist下是否多出html并运行看效果  打包后的index.html自动引入打包后的js文件\n自定义打包的html模版，和输出文件名字  plugins: [  new HtmlWebpackPlugin(&#123;    template: &#x27;./public/index.html&#x27;,    filename: &#x27;index.html&#x27;  &#125;)]\n\nmode模式\nmode模式分为开发阶段和发布阶段\ndevelopment开发阶段，建议打包，打包速度快\nproduction发布阶段，打包精细，打包速度慢(不会经常production)mode: &#x27;development || production&#x27;\n\nwebpack开发服务器-为何学?文档地址: https://webpack.docschina.org/configuration/dev-server/\n栗子：每次修改代码, 都需要重新 yarn build 打包, 才能看到最新的效果, 实际工作中, 打包 yarn build 非常费时 (30s - 60s) 之间为什么费时?1.构建依赖2.磁盘读取对应的文件到内存，才能加载3.将处理完的内容，输出到磁盘指定目录\n解决方法： 起一个开发服务器, 在电脑内存中打包, 缓存一些已经打包过的内容, 只重新打包修改的文件, 最终运行加载在内存中给浏览器使用\nwebpack-dev-server启动本地服务, 可实时更新修改的代码, 打包变化代码到内存中, 然后直接提供端口和网页访问\n1.下载包\nyarn add webpack-dev-server -D\n2.配置自定义命令\nscripts: &#123;\t&quot;build&quot;: &quot;webpack&quot;,\t&quot;serve&quot;: &quot;webpack serve&quot;&#125;\n3.运行命令-启动webpack开发服务器\nyarn serve或者npm run serve \n以后更改src下的资源代码，就会直接更新到内存打包，然后反馈到浏览器上\nwebpack-dev-server配置1.package.json\n&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;webpack&quot;,  &quot;serve&quot;: &quot;webpack serve --port 8083 --open&quot;&#125;,\n2.在webpack.config.js中添加服务器配置更多配置参考这里: https://webpack.docschina.org/configuration/dev-server/#devserverafter\nmodule.exports = &#123;    // ...其他配置    devServer: &#123;      port: 3000, // 端口号      open: true    &#125;&#125;\n\n加载器 - 处理css文件问题\n新建css文件夹\n编写样式\n引入到入口文件才会被webpack打包\n执行打包命令观察效果\n\n结尾：webpack默认只能处理js类型文件\n加载器 - 处理css文件loaders加载器，可以让webpack处理其他类型的文件，打包到js中因为：webpack默认只认识js文件和json文件style-loader文档css-loader文档1.安装依赖\nyarn add style-loader css-loader -D\n2.webpack.config.js配置\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    // ...其他代码    module: &#123;         rules: [ // loader的规则          &#123;            test: /\\.css$/, // 匹配所有的css文件            // use数组里从右向左运行            // 先用 css-loader 让webpack能够识别 css 文件的内容并打包            // 再用 style-loader 将样式, 把css插入到dom中            use: [ &quot;style-loader&quot;, &quot;css-loader&quot;]          &#125;        ]    &#125;&#125;\n万物皆模块, 引到入口, 才会被webpack打包, css打包进js中, 然后被嵌入在style标签插入dom上\n加载less问题less-loader让webpack处理less文件, less模块翻译less代码less-loader文档\n\n安装less-loaderyarn add less less-loader -D\nwebpack.config.js配置module: &#123;  rules: [ // loader的规则    // ...省略其他    &#123;    \ttest: /\\.less$/,    \t// 使用less-loader, 让webpack处理less文件, 内置还会用less翻译less代码成css内容        use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, &#x27;less-loader&#x27;]    &#125;  ]&#125;\n\n加载器 - 图片问题\n定义盒子结构&lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;div class=&quot;main1&quot;&gt;&lt;/div&gt;\n通过样式设置背景图.main &#123;  width: 100px;  height: 100px;  background-image: url(../img/1.png);&#125;.main1 &#123;  width: 100px;  height: 100px;  background-image: url(../img/2.png);&#125;\n\n加载器 - 处理图片asset module文档\nasset module(超级棒)在webpack5之前要经常用到\n\nraw-loader将文件导入为字符串\nurl-loader将文件作为dataURL内联到bundle中。\nfile-loader将文件发送到输出目录。\n\n在webpack5，资源模块类型(asset module type)，通过添加4种新的模块类型，来替换了一些loader\n\nasset&#x2F;resource 发送一个单独的文件并导出URL。之前通过使用file-loader实现\nasset&#x2F;inline 导出一个资源的data URL。之前通过使用url-loader实现\nasset&#x2F;source 导出资源的代码。之前通过raw-loader实现\nasset在导出一个data URL和发送一个单独的文件之间选择。之前通过url-loader，并且配置资源体积限制实现\n\nwebpack5版本，直接可以再webpack.config.js中的rules里即可\n&#123;    test: /\\.(png|jpg|gif|jpeg)$/i,    type: &#x27;asset&#x27;&#125;\nyarn build 打包之后看效果\nwebpack4及以前的版本url-loader文档file-loader文档\n\n下载依赖包\nyarn add url-loader file-loader -D\n\n\nwebpack.config.js 配置&#123;  test: /\\.(png|jpg|gif|jpeg)$/i,  use: [    &#123;      loader: &#x27;url-loader&#x27;, // 匹配文件, 尝试转base64字符串打包到js中      // 配置limit, 超过8k, 不转, file-loader复制, 随机名, 输出文件      options: &#123;        limit: 8 * 1024,      &#125;,    &#125;,  ],&#125;\nsrc&#x2F;img&#x2F;准备2个图片\n在css&#x2F;less&#x2F;index.less - 把小图片用做背景图body&#123;    background: url(../img/1_min.png) no-repeat center;&#125;\n在src&#x2F;main.js - 把大图插入到创建的img标签上, 添加body上显示// 引入图片-使用import imgUrl from &#x27;./assets/1.gif&#x27;const theImg = document.createElement(&quot;img&quot;)theImg.src = imgUrldocument.body.appendChild(theImg)\n打包运行dist&#x2F;index.html观察2个图片区别总的说：url-loader 把文件转base64 打包进js中, 会有30%的增大, file-loader 把文件直接复制输出\n\nwebpack加载文件优缺点\n\n以8kb进行区分，小于8kb图片转成 base64 字符串\n好处就是浏览器不用发请求了，直接可以读取\n坏处就是如果图片太大，再转base64就会让图片的体积增大 30% 左右\n\n\n\n扩展—webpack4&#x2F;5对比\n// webpack4 url-loadermodule.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.(png|jpg|gif)$/i,        use: [          &#123;            loader: &#x27;url-loader&#x27;,            options: &#123;              limit: 8192,            &#125;,          &#125;,        ],      &#125;,    ],  &#125;,&#125;;\n// webpack 5 asset modulemodule.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.(png|jpg|gif)$/i,        type: &#x27;asset&#x27;,        parser: &#123;          dataurlCondition: &#123;            maxSize: 8192          &#125;        &#125;      &#125;,    ],  &#125;,&#125;;\n// webpack4 中三个loader的使用module.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.png$/i,        use: &#x27;file-loader&#x27;      &#125;,      &#123;        test: /\\.ico$/i,        use: &#x27;url-loader&#x27;      &#125;,      &#123;        test: /\\.text$/i,        use: &#x27;raw-loader&#x27;      &#125;,    ],  &#125;,&#125;;\n// webpack 5 中使用的方法module.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.png$/i,        use: &#x27;asset/resource&#x27;      &#125;,      &#123;        test: /\\.ico$/i,        use: &#x27;asset/inline&#x27;      &#125;,      &#123;        test: /\\.text$/i,        use: &#x27;asset/source&#x27;      &#125;,    ],  &#125;,&#125;;\n\n在webpack5中使用老版本的loader和asset模块时，会导致asset重复，所以你可能想阻止webpack5内置的asset模块的处理\n// 你可以通过将 asset 模块的类型设置为 ‘javascript/auto’ 来解决module.exports = &#123;  module: &#123;   rules: [      &#123;        test: /\\.(png|jpg|gif)$/i,        use: [          &#123;            loader: &#x27;url-loader&#x27;,            options: &#123;              limit: 8192,            &#125;          &#125;,        ],       type: &#x27;javascript/auto&#x27;      &#125;,   ]  &#125;,&#125;\n\n\n加载器 - 处理字体文件实现效果用asset module技术, asset&#x2F;resource直接输出到dist目录下\n\nsrc&#x2F;assets&#x2F; - 放入字体库fonts文件夹\n在main.js引入iconfont.css// 引入字体图标文件import &#x27;./assets/fonts/iconfont.css&#x27;\n在public&#x2F;index.html使用字体图标样式&lt;i class=&quot;iconfont icon-weixin&quot;&gt;&lt;/i&gt;\n\nwebpack5使用这个配置,也可以不配置\n&#123; // webpack5默认内部不认识这些文件, 所以当做静态资源直接输出即可    test: /\\.(eot|svg|ttf|woff|woff2)$/,    type: &#x27;asset/resource&#x27;,    generator: &#123;    \tfilename: &#x27;font-[name].[hash:6][ext]&#x27;    &#125;&#125;\n1.webpack4及以前使用下面的配置\n&#123; // 处理字体图标的解析    test: /\\.(eot|svg|ttf|woff|woff2)$/,        use: [            &#123;                loader: &#x27;url-loader&#x27;,                options: &#123;                    limit: 2 * 1024,                    // 配置输出的文件名                    name: &#x27;[name].[ext]&#x27;,                    // 配置输出的文件目录                    outputPath: &quot;fonts/&quot;                &#125;            &#125;        ]&#125;\n2.执行打包命令-观察打包后网页效果url-loader和file-loader 可以打包静态资源文件\n加载器 - 处理高版本js语法\n在main.js中使用箭头函数(高版本js)class App &#123;  static a = 123&#125;console.log(App.a)\n打包后观察lib&#x2F;bundle.js效果：让webpack对高版本 的js代码, 降级处理后打包\n\n高版本的js代码(箭头函数，类),打包后，直接原封不动打入js文件中，遇到一些低版本的浏览器就会报错原因：webpack 默认仅内置了 模块化的 兼容性处理 import exportbabel 的介绍 &#x3D;&gt; 用于处理高版本 js语法 的兼容性 babel官网解决: 让webpack配合babel-loader 对js语法做处理\n@babel&#x2F;core：@babel&#x2F;core是babel的核心库，所有的核心Api都在这个库里，这些Api供babel-loader调用\n@babel&#x2F;preset-env：这是一个预设的插件集合，包含了一组相关的插件，Bable中是通过各种插件来指导如何进行代码转换。该插件包含所有es6转化为es5的翻译规则\nbabel-loader文档\n\n安装包yarn add -D babel-loader @babel/core @babel/preset-env\n规则配置module: &#123;  rules: [    &#123;        test: /\\.js$/,        exclude: /(node_modules)/,        use: &#123;            loader: &#x27;babel-loader&#x27;,            options: &#123;                presets: [&#x27;@babel/preset-env&#x27;] // 预设:转码规则(用bable开发环境本来预设的)            &#125;        &#125;    &#125;  ]&#125;\n\n加载器 vue-loadervue-loader配置\n每个 vue 包的新版本发布时，一个相应版本的 vue-template-compiler 也会随之发布。编译器的版本必须和基本的 vue 包保持同步，这样 vue-loader 就会生成兼容运行时的代码。这意味着你每次升级项目中的 vue 包时，也应该匹配升级 vue-template-compiler。\nnpm install -D vue-loader vue-template-compiler\n\nvue-loader配置\n// webpack.config.jsconst &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)module.exports = &#123;  module: &#123;    rules: [      // ... 其它规则      &#123;        test: /\\.vue$/,        loader: &#x27;vue-loader&#x27;      &#125;    ]  &#125;,  plugins: [    // 请确保引入这个插件！    new VueLoaderPlugin()  ]&#125;// vue-loader是将你定义过的其他规则复制并应用到.vue文件里相应语言的快\n// webpack.config.jsconst &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)module.exports = &#123;  mode: &#x27;development&#x27;,  module: &#123;    rules: [      &#123;        test: /\\.vue$/,        loader: &#x27;vue-loader&#x27;      &#125;,      // 它会应用到普通的 `.js` 文件      // 以及 `.vue` 文件中的 `&lt;script&gt;` 块      &#123;        test: /\\.js$/,        loader: &#x27;babel-loader&#x27;      &#125;,      // 它会应用到普通的 `.css` 文件      // 以及 `.vue` 文件中的 `&lt;style&gt;` 块      &#123;        test: /\\.css$/,        use: [          &#x27;vue-style-loader&#x27;,          &#x27;css-loader&#x27;        ]      &#125;    ]  &#125;,  plugins: [    // 请确保引入这个插件来施展魔法    new VueLoaderPlugin()  ]&#125;\n其他loader\nbabel-loader 可以让webpack 对高版本js语法做降级处理后打包\n其他webpack.config.js和vue.config.js的区别\nwebpack.config.js是webpack的配置文件，所有使用webpack作为打包工具的项目都可以使用，vue的项目可以使用，react的项目也可以使用。\nvue.config.js是vue项目的配置文件，专用于vue项目。通过vue.config.js中常用功能的配置，简化了配置工作，如果需要更专业的配置工作，两者在vue项目中是可以并存的。\nvue-cli3创建的时候并不会自动创建vue.config.js，因为这个是可选项，所以一般都是修改webpack的时候才会自己创建一个vue.config.js\n然后因为你vue-cli3内部高度集成了webpack，一般来说使用者不需要再去webpack做什么，所以没有暴露webpack的配置文件，但你依然可以创建vue.config.js去修改默认的webpack。\n\n什么是gulp\n一、gulp 是一个基于node的自动化打包构建工具，前端开发者可以使用它来处理常见任务：搭建web服务器；文件保存时自动重载浏览器；使用预处理器如Sass、LESS；优化资源，比如压缩CSS、JavaScript、压缩图片；类似Gulp的工具，我们通常称之为构建工具或者叫自动化构建工具；强调的是前端开发的流程，通过配置一系列的task，定义task处理的事物，然后定义执行顺序，来让Gulp执行task，从而构建前端项目的流程，说白了就是用来打包项目；基于 node 强大的流(stream)能力，gulp 在构建过程中并不把文件立即写入磁盘，从而提高了构建速度；不管做什么功能，都有一个统一的接口进行管理，必须去注册一个任务，然后去执行，这也是它的特点之一，即“任务化”。\n\n二、基本使用\n1.创建项目目录  打开命令行工具(package.json文件为npm init -y自动生成，切勿手动创建)  使用cd命令行进入项目目录，如：cd mygulp  创建项目配置文件：npm init -y2.gulp的安装  在命令行工具，依次执行：    全局安装：npm i gulp -g    局部安装：npm i gulp -D    检测安装版本：gulp -v  注： gulp -v 命令得到两个版本号，一个全局，一个局部，代表安装成功3.gulp配置文件(src同级)  在项目中创建gulp配置文件--&gt;gulpfile.js4.定义指令  在gulpfile.js文件中定义gulp指令，使用gulp实现功能    const gulp = require(&quot;gulp&quot;); // 引入gulp模块    function testFn()&#123;            // 准备指令功能        console.log(&quot;test&quot;);    &#125;    exports.test = testFn;         // 定义指令（暴露模块）\n三、gulp常用插件以下插件使用格式为：npm（空格）i（空格）插件名（空格）-D清空文件夹：gulp-clean编译css：gulp-sass压缩图片：gulp-imagemin深度压缩图片：imagemin-pngquant压缩css：gulp-cssmincss前缀：gulp-autoprefixer压缩js：gulp-uglify\nES6转ES5：gulp-babel套件1：@babel&#x2F;core套件2：@babel&#x2F;preset-env\n压缩html：gulp-htmlmin服务器插件：gulp-webserver文件重命名：gulp-rename合并js文件：gulp-concat\n\n四、gulp常用项目流程操作及部分插件使用方法\n\n开始之前先引入将来要使用到的插件模块const gulp = require(&quot;gulp&quot;);const cssmin = require(&quot;gulp-cssmin&quot;);const autoprefixer = require(&quot;gulp-autoprefixer&quot;);const uglify = require(&quot;gulp-uglify&quot;);const babel = require(&quot;gulp-babel&quot;);const htmlmin = require(&quot;gulp-htmlmin&quot;);const webserver = require(&quot;gulp-webserver&quot;);\ncss处理方式// 处理css的指令：压缩，添加兼容前缀function cssFn()&#123;    return gulp.src(&quot;./project/css/**/*&quot;)            .pipe(autoprefixer(&quot;last 2 version&quot;,&quot;safari 5&quot;,&quot;ie 8&quot;,&quot;ie 9&quot;,&quot;opera 12.1&quot;,&quot;ios 6&quot;,&quot;android 4&quot;))            .pipe(cssmin())            .pipe(gulp.dest(&quot;./server/css&quot;))&#125;module.exports.css = cssFn;    // module.可省略\njs处理方式// 处理js的指令：ES6编译ES5，压缩function jsFn()&#123;    return gulp.src(&quot;./project/js/**/*&quot;)        .pipe(babel(&#123;            presets:[&quot;@babel/env&quot;]        &#125;))        .pipe(uglify())        .pipe(gulp.dest(&quot;./server/js&quot;))&#125;exports.js = jsFn;\nhtml处理方式// 处理html的指令：压缩function htmlFn()&#123;    return gulp.src(&quot;./project/pages/**/*&quot;)        .pipe(htmlmin(&#123;            removeEmptyAttributes:true,            collapseWhitespace:true        &#125;))        .pipe(gulp.dest(&quot;./server/pages&quot;))&#125;exports.html = htmlFn;\n处理静态资源\n\n\n\nfunction staticFn()&#123;    // 找到要处理的静态资源文件    return gulp.src(&quot;./src/static/**&quot;)            // 直接转存           .pipe(gulp.dest(&quot;./dist/static&quot;))&#125;// 暴露调用方式exports.static = staticFn;\n\n删除文件夹function cleanFn()&#123;    // 找到要删除的文件目录    return gulp.src(&quot;./ded&quot;)            // 直接删除           .pipe(clean())&#125;// 暴露调用方式exports.clean = cleanFn;\n服务器配置function serverFn()&#123;    // 找到要指定为根目录的文件夹    return gulp.src(&quot;./ded&quot;)        // 执行服务器方式，并开始配置信息        .pipe(webserver(&#123;            // 指定访问地址            host:&quot;localhost&quot;,            // 指定端口            port:3000,            // 开启自动刷新            livereload:true,            // 服务器开启后，自动打开的页面            open:&quot;./pages/index.html&quot;,            proxies:[&#123;                // 代理之后的请求地址                source:&quot;./chapters&quot;,                // 被代理的跨域地址                target:&quot;http://wanandroid.com/wxarticle/chapters/json&quot;                            &#125;]        &#125;))&#125;// 暴露调用方式exports.server = serverFn;\n开启监听function watchFn()&#123;    // 监听所有css文件    gulp.watch(&quot;./src/css/**&quot;,cssFn);    // 监听所有js文件    gulp.watch(&quot;./src/js/**&quot;,jsFn);    // 监听所有html文件    gulp.watch(&quot;./src/pages/**&quot;,htmlFn);    // 监听所有static文件    gulp.watch(&quot;./src/static/**&quot;,staticFn);&#125;// 暴露调用方式exports.watch = watchFn;\n批量执行\n注意事项：\ngulp.series()：同步执行内部命令\ngulp.parallel()：异步执行内部命令exports.all = gulp.series(    gulp.parallel(cssFn,jsFn,htmlFn,staticFn),    gulp.parallel(serverFn,watchFn));\n\n\n\n\n\n","categories":["解析"]},{"title":"VUe","url":"/2021/07/20/vue/","content":"\n\n\"># VUE.js框架是什么？为什么要学它- vue作为国人开发的一款前端框架，不仅有强大的社区支持，很多API都是中文的，学习难度相对较小- 接收用户输入的同时，很可能要及时更新视图，比如用户输入不同的内容，页面就会相对应进行更新，点击不同的选项，显示不同的状态等交互效果。（用vue更便捷）## 视图层视图数据混在一起冗繁复杂，把html中的dom与其他部分独立开来划分出一个层次，这个层次就叫做视图层，vue的核心库只关注视图层## BTW——API- 例：电脑需要调用手机里的信息，用数据线进行连接，电脑和手机连接数据线的接口就是API### API与上述例子类似又不尽相同- 定义：应用程序接口，是一些预先定义的接口（如函数，http接口），或软件系统不同组成部分衔接的约定）- 应用场景：    - 接口：前后端交互    - 提供应用程序与开发人员基于某软件或硬件得以访问的一组历程，而又无需访问源码    例：程序员B想调用A中的部分功能又不想从头看一遍A的源码和功能实现过程，这时候把A需要的功能打包好，写成一个函数！！！按照B说的流程把函数放在B中就可以直接使用功能了# vue是什么？- 定义：以数据驱动视图的MVVM渐进式框架    - 数据：对象    - 视图：dom标签 --&gt; 虚拟dom    - MVVM：M model模型，V view视图。就是一种框架架构，model-view view-model， 这样的结构，主要优势在于监控者数据双向绑定的特性，vue和model之间是双向数据传递的。视图改变数据就可以改变，数据改变视图就可以改变。    - 渐进式：轻量级框架，可以选择性的，只使用vue中很少的一部分，而不是必须使用全部## BTW——MVC和MVVM- MVVM有两个方向：    1. 将model（模型）转化成 view（视图），即后端传递的数据转化成所看到的页面。实现方式为数据绑定    2. 将view（视图）转化成 model（模型），即将所看的页面转化成后端的数据。实现方式为dom监听事件- 什么是mvc?    - MVC是model-view-controller的缩写，即模型——视图——控制器。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。- 区别：    - MVC和MVVM的区别并不是VM完全取代了C，只是在MVC的基础上增加了一层VM，只不过是弱化了C的概念，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。    - View更新的时候，必须要通过Controller去更新一遍Model；同样的Model更新的时候，也要去更新一遍视图。[!MVVM优点]:实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。## vue.js核心？- 官方定义：通过尽可能简单的API实现响应的数据绑定和组合的视图组件## 数据驱动- 传统js手动改变DOM来改变视图，vue.js只需要改变数据就会自动改变视图，就是MVVM思想的实现## 视图组件化- 定义：把网页拆分一个个区块，每个区块我们可以看成一个组件。网页由多个组件拼接或嵌套组成## vue的特点- 响应式编程：编写代码基于对变化的反应- 组件化### 组件和模块- 组件：把重复代码提取出来合并成为一个组件，组件最重要的是复用，位于框架最底层，其他功能依赖于组件，可供不同功能使用，独立性强- 模块：分属同一功能/业务的代码进行隔离（分装）成独立的模块，可以独立运行，以页面、功能或其他不同粒度划分程度不同的模块。位于业务框架层，模块间通过接口调用，目的是降低模块间的耦合，由之前的主应用与模块耦合，变为主应用与接口耦合，接口与模块耦合[比喻]模块就像有多个USB插口的充电宝，可以和多部手机充电，接口可以随意插拔。复用性很强，可以独立管理。- 组件化模块化区别？    - 1. 组件相当于库，把一些能在项目里或者不同类型项目中可复用的代码进行封装    - 2. 而模块相当于业务逻辑模块，把同一类型项目里的功能逻辑进行需求性的封装- 为什么要用组件和模块    - 开发和调式效率高    - 可维护性强    - 避免阻断    - 版本管理更容易## vue的优缺点？- 优点：轻量级框架，数据双向绑定，组件化，虚拟dom，运行速度快- 缺点：    - 不支持ie678    - 生态环境差不如angular和react    - 社区不大    - 无高阶书籍    - 首屏加载速度满，加载时，将所有的css,js文件进行加载### BTW——首屏加载慢解决方式- 减少入口文件体积- UI框架按需引入- 静态资源本地缓存- 图片资源压缩- 组件重复打包- 使用SSR（通过对文件、目录、进程、注册表和服务的强制访问控制，有效的制约和分散了原有系统管理员的权限）### BTW——粒度和耦合- 粒度：计算机中常指系统内存扩展增量的最小值。粒度问题是设计数据仓库的一个最重要方面。粒度是指数据仓库的数据单位中保存数据的细化或综合程度的级别。细化程度越高，粒度级就越小；相反，细化程度越低，粒度级就越大。数据的粒度一直是一个设计问题。- 耦合：两个东西通过某种作用连接在了一起# vue核心的底层原理- Object.defineProperty数据劫持的API- Object.defineProperty定义新属性或修改原有的属性，vue的数据双向绑定原理就是Object.defineProperty，里面定义了setter和getter方法，通过观察者模式(发布订阅模式)来监听数据变化，从而做相应的逻辑处理- 监听对象属性变化，只关心数据不关心视图- 三个参数- 三个参数Object.defineProperty(object,propName,descriptor)    - object 对象=&gt;给谁加    - propName 属性名=&gt;需要加的属性的名字[类型:String]    - descriptor 属性描述=&gt;加的这个属性有什么特性[类型：Object]    - 方法就是直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象- 属性描述符    - configurable: true 配置可删除，默认false        - 两个作用：            1. 目标属性是否可以使用delete删除            2. 目标属性是否可以再次设置特性    - writable：true 配置可修改，默认false    - enumerable:true 可枚举，使用(for...in或Object,keys())默认false    - value属性对应的值，可以是任意类型的值，默认undefined    - 缺点：数组的长度### 语法```js    // writable应用        let Person = &#123;&#125;        Object.defineProperty(Person,&#x27;name&#x27;,&#123;value:&#x27;Jack&#x27;,            // writable:true // 加上这个就可以输出&#123;name:&#x27;Rose&#x27;&#125;        &#125;)        console.log(Person) // &#123;name:&#x27;Jack&#x27;&#125;        Person.name = &#x27;Rose&#x27;        console.log(Person) //undefined,因为writable默认false    // enumerable应用        var user=&#123;name:&#x27;小五&#x27;,age:&#x27;24&#x27;&#125;;        // es6            var keys = Object.keys(user)            console.log(keys) // [&#x27;name&#x27;,&#x27;age&#x27;]        // es5            var Key = []            for(key in user) &#123;                Key.push(Key)            &#125;            console.log(Key) // [&#x27;name&#x27;,&#x27;age&#x27;]    // configurable应用        var human=&#123;name:&#x27;李白&#x27;,age:&#x27;不详&#x27;&#125;；        // 定义一个性别，不可被删除和重新定义特性            Object.defineProperty(human,&#x27;gender&#x27;,&#123;                value:&#x27;男&#x27;,                enumerable:true,                configurable:false            &#125;)        // 删除一下            delete human.gender            console.log(human)//&#123;name:&quot;李白&quot;,age:&quot;不详&quot;,gender:&quot;男&quot;&#125; 并没有删除        // 重新定义特性            Object.defineProperty(human,&#x27;gender&#x27;,&#123;                value:&#x27;男&#x27;,                enumerable:true,                configurable:true            &#125;)            delete human.gender;            console.log(human) // &#123;name:&quot;李白&quot;,age:&quot;不详&quot;&#125;\n\n存取描述符  get  一个给属性提供 getter 的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。getter就是获取属性值  set  一个给属性提供 setter 的方法，如果没有setter则为undefined。该方法将接收唯一参数，并将该参数的新值分配给属性。默认为undefined。setter就是设置属性值\n\n[!注意]：1. 当使用getter或setter方法，不允许使用writable和value这两个属性        2. get或set不是必须成对出现，任写其一就行。如果不设置方法，get和set默认undefined\n语法var username = &#123;name:&quot;不想起名了&quot;&#125;;var num = 12// 定义一个age获取值时返回定义好的变量    Object.defineProperty(username,&#x27;age&#x27;,&#123;        get:function() &#123;            return num        &#125;    &#125;)    console.log(username.age);//12// 定义一个age获取值时返回定义好的变量num    Object.defineProperty(username,&#x27;age&#x27;,&#123;        get:function() &#123;            return num        &#125;        set:function(newVal) &#123;            num = newVal        &#125;    &#125;)    console.log(username.age);// 12    username.age = 145    console.log(username.age); // 145    console.log(num); // 145\n\n兼容性：IE8以下不行\n使用Object.defineProperty的优点\n减少代码（少了dom,不需要写很多dom）\n开发速度快\n\n\n\nBTW——数据劫持\n定义：修改或访问对象的属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果\n\nvue环境搭建\n环境需要:nodejs 检测cmd:node-v\n安装全局脚手架:npm i -g @vue/cli 检测：vue-Vyarn global add @vue/cli\n脚手架网站:cli.vuejs.org\nvue官网: vuejs.org\n\n创建vue项目【注意】:项目名称不能是中文，不能是大写字母，不能用vue做名字\n命令运行方式vue create name\ngui图形化方式vue ui\nvue脚手架\n定义:vue的cli脚手架底层是webpack,也就是基于webpack封装的  [官网]（http://cli.vuejs.org）\n\nBTW——是脚手架？\n什么是脚手架？\n构建基于数据库的应用，进行增、删、改、查数据库的操作\n\n\nVue-CLi是什么？\n是vuejs脚手架工具，就是自动帮你生成好项目目录，配置好webpack，以及各种依赖包工具\n为什么要用？可以帮助你快速开启一个vue项目，给你一套文件结构，包含基础的依赖库，只需要npm install 一下就可以安装，不需要为编译或其他琐碎事而浪费时间，而且不会限制到你发挥\n\n\n\n脚手架配置\nvue.config.js文件是脚手架配置文件，该文件必须放在项目的根目录里\n\n请求代理【跨域方案】脚手架-&gt;webpack-&gt;nodejs【后端】使用后端转发请求【注意】只能在开发环境中使用【使用场景】在公司里和后端的测试接口进行接口调式使用\n语法module.exports=&#123;    devServer:&#123;        // 浏览器自动打开        open:true,        // 代理        proxy:&#123;            &quot;/api&quot;:&#123;                target:&quot;http://xx.com&quot;,                changeOrigin:true,                pathRewrite:&#123;                    &quot;^/api&quot;:&quot;&quot;,                &#125;,            &#125;,        &#125;,    &#125;&#125;\n关闭源码映射【性能优化】\nproductionSourceMap:false  打包的时候，每一个js文件对应生成一个map源码映射文件，它在生产环境中时没有用的。它会增加打包时间，浪费磁盘空间，以及容易造成代码泄漏等问题，因此需要在生产环境中关闭，只允许开发环境中开启\n\n关闭eslint代码校验\nlintOnSave:false\n\nAIA：脚手架配置有哪些？\n代码校验\n代码映射的开启与关闭\n请求代理vue.config.js\n\nvue项目结构运行命令\n项目根目录里有一个package.json文件，该文件有一个script对象，里面就是自定义运行命令。（是这三个里唯一一个可以删的）\nserve开发环境，写代码时的环境\nbuild生产环境，打包发布时的环境\n\n结构\n\nnode_modules它是项目运行时必须依赖\n\n\npublic公共目录，存放着唯一的html模板\nsrc【核心-源码】项目所有代码\n.gitignore过滤掉git仓库里不需要的文件清单\nbabel.config.js把es6转成es5\npackage.lock.json(可以删但一般留着)，锁定依赖版本号\npackage.json【核心】依赖包管理文件\nREADME.md说明书\n\nsrc源码结构\nassets存放静态资源：图片，css,js脚本\ncomponent放组件\nApp.vue根组件，第一个被加载的组件\nmain.js入口文件，第一个被执行的文件\n\n模块化开发【vue核心亮点】把一切重复使用的资源，无论是图片，样式还是js代码抽离出来，作为单独的’模块’进行复用\n\n模块包含：vue 组件，图片，js 脚本，css 样式，字体等都可以是模块。\n\nvue里的模块化组件开发\n\n组件必须使用import引入到当前组件\n\n\n\n当前组件的components必须挂载引入的组件\n\n\n\n在当前组件的template里用标签的形式使用挂载的组件\n\n\n\n插值\n渲染文本\n写在两个大括号中间\n\n插值语法可以写哪些值\n对象、字符串、数字、数组、布尔值、三元表达式、自执行函数等，凡是具有返回值的都可以，全部变成文本渲染出来\n\nBTW——自执行函数和快速删除文件自执行函数后面+（）&#123;function()&#123;return 1000()&#125;&#125;\n为什么用自执行函数而不是函数用函数也可以，只不过返回时function(){return 1000},而不是1000\n插值语法的作用\n四则运算 100+(200*300)&#x2F;2\n插值里存放变量 (详情请找baseVue.html)\n\nnpkill和rimraf快速删除node_modules包\n全局安装npm i -g npkill\n进入想清理的文件夹\ncd文件路径\n输入npkill\n会自动查找文件中node_modules\n光标上下移动来选择要清理的目录，释放宝贵的空间\n按空格删除\n\n内置方法$set添加或修改对象和数组添加&#x2F;修改对象的属性 $set(obj,&#39;name&#39;,1)添加或修改数组成员$set(arr,index,val)\n$delete删除对象和数组\n删除对象属性$delete(obj,name)\n删除数组成员$delete(arr,index)\n\n$emit派发一个动作向上级通信$mount手动挂载方法属性绑定\nprops接收上游绑定的属性\n\n语法\n数组：[&#39;list&#39;]\n对象:props:&#123;    list:&#123;        type:Array,        // 针对数组或对象需要函数        default:() =&gt; [] //default是没有任何值的时候默认的值，保证你需要该属性的时候不是undefined    &#125;&#125;\n父组件要正向地向子组件传递数据或参数，子组件收到后，根据传递过来的数据不同，渲染不同的页面内容，或者执行操作。这个正向传递数据的过程是通过props来实现的。子组件使用props来声明需要从父组件接收的数据[!注意]：\n\n\n不应该在一个子组件内部改变 prop，这样会破坏单向的数据绑定，导致数据流难以理解。如果有这样的需要，可以通过 data 属性接收或使用 computed 属性进行转换。\n\n如果 props 传递的是引用类型(对象或者数组)，在子组件中改变这个对象或数组，父组件的状态会也会做相应的更新，利用这一点就能够实现父子组件数据的“双向绑定”，虽然这样实现能够节省代码，但会牺牲数据流向的简洁性，令人难以理解，最好不要这样去做。\n\nprop只读不可修改\n\n想要实现父子组件的数据“双向绑定”，可以使用 v-model 或 .sync\n\n\n两种常见的试图变更一个prop的情形\n这个prop用来传递一个初始值这个子组件接下来希望将其作为一个本地的prop数据来使用。在这种情况下，最好定义一个本地的data property并将这个prop用作其初始值\n这个prop以一种原始的值传入且需要转换。在这种情况下，最好使用这个prop的值来定义一个计算属性\n\nscss动态生成类名（待写11.26scss动态生成类名.vue）例如：有一p标签，起一个class名为m-l-10     \nv-指令什么是指令？是带有v-前缀的特殊属性，通过属性来操作元素\nv-model\n因为vue是单向数据流，所以v-model在input上只是语法糖而已&lt;!-- 第一行代码是第二行的语法糖 --&gt;&lt;input v-model=&quot;sth&quot;/&gt;&lt;input v-bind:value=&quot;sth&quot; v-on:input=&quot;sth=$event.target.value&quot;/&gt;&lt;!-- 理解上述代码    input本身有个oninput事件，这是h5新增，类似onchange,每当输入框内容发生变化的时候，就会触发oninput，把最新的value传递给sth--&gt;&lt;!-- 所以在给&lt;input/&gt;元素添加v-model属性时，默认会把value作为元素的属性，然后把&#x27;input&#x27;事件作为实时传递value的触发事件 --&gt;\n用在组件上 给组件加v-model，默认会把value作为组件的属性，然后把’input’值作为给组件绑定事件的事件名\n\n语法 &lt;Cur-input v-model=&quot;price&quot;&gt;&lt;/Cur-input&gt;  &lt;input ref=&quot;input&quot; :value=&quot;value&quot; @input=&quot;$emit(&#x27;input&#x27;)$event.target.value&quot;&gt;export default &#123;    data:&#123;price:100&#125;,    props:[&#x27;value&#x27;]&lt;!-- 这里为什么用value？--&gt;&#125;【问题解答】：&lt;Cur-input :value=&quot;price&quot; @input=&quot;price=arguments[0]&quot;&gt;&lt;/Cur-input&gt;\nv-model缺点及解决办法\n在创建类似复选框或单选框这种常见的组件时，v-model就不好用了。因为不需要value属性而是checked属性，并且当你点击这个单选框的时候不会触发oninput事件，它只会触发onchange事件。[解决办法]:&lt;!-- input上 --&gt;    &lt;input type=&quot;checkbox&quot; :checked=&quot;status&quot; @change=&quot;status=$event.target.checked&quot;/&gt;&lt;!-- 组件上 --&gt;    &lt;input type=&quot;checkbox&quot; @change=&quot;$emit(&#x27;suibian&#x27;,$event.target.checked)&quot;    :checked=&quot;value&quot;    /&gt;    props:[&#x27;checked&#x27;][!注意]v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。应通过 JavaScript 在组件的 data 选项中声明初始值。\n\n表单的使用——专用指令:v-modelv-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：\n\ntext 和 textarea 元素使用 value 属性和 input 事件；（默认）\nradio单选框\ncheckbox 和 radio 使用 checked 属性和 change 事件；(单个复选框，绑定到布尔值，多个复选框，绑定到同一个数组：)\n语法：&lt;input type=&#39;radio&#39; v-model=&#39;radio&#39; value=&#39;1&#39;/&gt;\n\n\nselect下拉菜单\nselect 字段将 value 作为 prop 并将 change 作为事件。\n语法&lt;select v-model=&#x27;selected&#x27;&gt;    &lt;option value=&#x27;1000&#x27;&gt;北京&lt;/option&gt;&lt;/select&gt;\n\n\n\nBTW——语法糖 onchange @input\n语法糖：用更简练的言语表达较复杂的含义\nonchange事件\n定义：事件会在域的内容改变时发生\n可用于单选框与复选框改变后触发的事件\n语法:input type&#x3D;”text” onchange&#x3D;”myFunction()\n\n\n@input一般用于监听事件，只要输入的值变化了就会触发input，而@click是事件触发事件\n\nv-show\n控制元素显示与隐藏，但是元素的dom节点一直存在页面中的，他的底层原理是控制css的display属性\n当频繁切换元素显示隐藏的时候，优先使用v-show&lt;template&gt;    &lt;!-- 条件渲染v-show    控制css display样式，dom节点是存在于页面中的 --&gt;    &lt;div&gt;        &lt;p @click=&quot;flag()&quot;&gt;&lt;/p&gt;        &lt;h1 v-show=&quot;see&quot;&gt;我可以被显示吗&lt;/h1&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        data:&#123;            return &#123;                see:false                &#125;            &#125;,        methods:&#123;            flag() &#123;                this.see =! this.see            &#125;        &#125;    &#125;&lt;/script&gt;\n\nv-if\n它是控制元素的加载(渲染)和销毁，底层是删除或者加载出dom\n它还有v-else-if和v-else但是后面两个不能单独使用\n它是条件控制语句，它只要有一个符合条件，则后面的v-else-if和v-else就不执行判断\n适合用于多条件判断渲染&lt;template&gt;    &lt;div&gt;        &lt;!-- 多条件切换的时候使用 v-if --&gt;        &lt;button v-on:click=&quot;index=1&quot;&gt;首页&lt;/button&gt;        &lt;button v-on:click=&quot;index=2&quot;&gt;新闻&lt;/button&gt;        &lt;button v-on:click=&quot;index=3&quot;&gt;关于&lt;/button&gt;        &lt;!-- 面板 --&gt;        &lt;h1 v-if=&quot;index==1&quot;&gt;我是首页&lt;/h1&gt;        &lt;h1 v-else-if=&quot;index==2&quot;&gt;我是新闻&lt;/h1&gt;        &lt;h1 v-else&gt;我是关于&lt;/h1&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        data()&#123;            return&#123;                //1.首页 2.新闻 3.关于                index:1,            &#125;;        &#125;,    &#125;&lt;/script&gt;\n\nv-bind\n定义：绑定属性的，可以绑定原生属性和自定义属性\n缩写:\n修饰符\nprop把标签上的属性隐藏\nsync把数据变成为双向绑定(与v-model类似，v-model只能用于对象否则会警告，这个可以解决基本数据类型不是双向绑定问题)\n\n\n\n &lt;p v-bind:title=&quot;doc.title&quot; v-on:update:title=&quot;doc.title=$event&quot;&gt;&lt;/p&gt;&lt;!-- 上述代码用.sync可以写为 --&gt;&lt;p v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/p&gt;&lt;!-- 在子组件中，可以通过下面代码实现对prop重新赋值 --&gt;this.$emit(&#x27;update:title&#x27;,newTitle)\n[AIA]\n\n父组件使用 sync 修饰绑定的属性  v-bind:prop.sync=data\n子组件使用固定语法  $emit(&#39;update:prop&#39;,value)\n\nBTW——$emit $mount\n$emit  派发一个动作向上级通信\n\n$mount 手动挂载方法\n\n语法\n\n绑定样式  &lt;div :class=&quot;&#123;&#123;name:true|false&#125;&#125;&quot;&gt;&lt;/div&gt;\n绑定自定义  &lt;Son :data=&quot;data&quot;&gt;&lt;/Son&gt;\n\n\n样例\n&lt;template&gt;    &lt;div&gt;        &lt;!-- v-bind:绑定属性的指令 --&gt;        &lt;img v-bind:src=&quot;logo&quot; kkk=&quot;hahah&quot;/&gt;        &lt;!--             img标签?dom元素=dom对象            src 对于img原始的属性            kkk 对于img，自定义属性            v-bind:既可以绑定原始和自定义属性             --&gt;        &lt;!-- 绑定背景图 --&gt;        &lt;div style=&quot;height:500px;border:1px solid red&quot; v-bind:style=&quot;&#123;background:`url($&#123;logo&#125;)`&#125;&quot;&gt;        &lt;/div&gt;        &lt;!-- 绑定class类名        v-on:click=&#x27;回调函数/表达式&#x27; --&gt;        &lt;button v-bind:class=&#x27;&#123;active:n&#125;&#x27; v-on:click=&#x27;n=n ? false :1&#x27;&gt;点我&lt;/button&gt;            &lt;!-- 用对象包着是因为，对象里可以绑定很多class名 --&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//引入图片import src from &#x27;../../assets/logo.png&#x27;// console.log(src)//若引入很多张图片 脚手架-&gt;基于webpack-&gt;基于nodejs 所以可以使用nodejs里的requirevar img= require(&#x27;../../assets/logo.png&#x27;);// 直接在export中输出require(&#x27;../../assets/logo.png&#x27;)不用写这个export default &#123;    data() &#123;        // 任何文件都是模块        return &#123;            n:false,//true是绑定，false是不要            // logo:&#x27;../../assets/logo.pn&#x27;,这个卸载这里出不来放到import中，这里logosrc            logo:src,// 对应import            logo:require(&#x27;../../assets/logo.pn&#x27;)        &#125;    &#125;&#125;&lt;/script&gt;&lt;style&gt;    /* 高亮颜色 */    .active&#123;        background:red;        color:white;    &#125;&lt;/style&gt;\n\nv-on\n定义：事件绑定指令，可以绑定原生事件和自定义事件\n缩写：@\n语法：v-on:click=&#39;callBack&#39;\n修饰符：\n.stop 清除事件冒泡\n.prevent 阻止默认行为\n.once 绑定一次函数\n.native 绑定原始事件\n.passive 告诉浏览器不想阻止默认行为\n\n\nevent事件对象\ntarget 事件触发的元素\ncurrentTarget 事件绑定的元素\n\n\n\n自定义事件\n由程序决定触发时机的自定义事件\n语法:绑定：@myEvent=&#39;callBack&#39;调用：$emit(&#39;callBack&#39;,参数)\n应用场景：父子组件通信的时候\n\nv-text\n底层是innerText\n定义：渲染文本内容，无论写入什么值，最后都被渲染成文本内容\n和插值&#123;&#123;&#125;&#125;基本一致\n为什么有v-text还要有插值语法？v-text覆盖内容，插值语法就是个占位符，用插值偏多\n\nv-html\n定义：用于渲染dom片段的\n底层：innerHTML二者区别：v-html可以转义标签和渲染数据，v-text不能转义标签只能渲染数据  v-html 你好  v-text $lth2$gt你好$lt&#x2F;h2$gt\n\nv-for循环渲染\n基础语法:v-for=&#39;val in data&#39; key=&#39;val&#39;\n获取下标:v-for=&#39;(val,index) in data&#39; :key=&#39;index&#39;\n遍历对象：v-for=(val,key,index) in obj\n[!注意]key一定不可以是随机数，时间戳，因为值不固定，随时发生改变，key的值必须唯一。随机数时间戳不固定，刷新一次改变一次\ndata:对象，数组，数字，字符串\nkey&#x3D;’值必须唯一’当前元素的身份，标识，用来优化diff算法进行dom修改\n虚拟dom和diff算法\n虚拟dom是js动态生成的，是js根据算法得出的\ndiff算法，执行规则：同层对比，新旧dom对比，当发现有不同之处，直接用新的dom替换旧的dom部分，diff算法超级快\n\n\n\nv-slot(详情搜索插槽)\n绑定插槽的指令\n作用域插槽、具名插槽和默认插槽\n缩写：#\n\nv-once永远只显示第一次渲染的值，让数据失去双向响应。它会让被绑定的元素不再进入diff对比，不更新。从而节省了虚拟dom的计算\nv-pre原格式输出内容，不会让元素内的内容解析\nv-clock防止插值语法的闪烁问题，插值里的数据如果默认是空的，需要等接口返回才显示的话，页面内容的高随着内容撑开导致页面抖动\n&lt;div&gt;    &lt;p v-clock&gt;&#123;message&#125;&lt;/p&gt;&lt;/div&gt;&lt;style&gt;    [v-clock] &#123;display:none;&#125;&lt;/style&gt;\n\n生命周期定义\n广义：事物发展的阶段\n具体例子：人的生老病死\n页面加载的过程：初始化，渲染，更新，销毁\n官方定义：钩子函数(生命周期就等于钩子函数)\n\n页面加载的过程：初始化，渲染，更新，销毁诞生：入口函数，当页面完全加载出来，才执行\n    window.onload\n去世：当页面被关闭的时候执行，卸载\n    window.onunload\n更新：重新加载，页面要发生变化\n    window.onreload\n\n生命周期作用是什么？Vue 所有的功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。\nvue生命周期创建阶段预加载资源，骨架屏，上传日志等操作\n创建前 beforeCreate\nvue对象创建之前触发的函数\n此阶段为实例化初始后，this指向创建的实例，数据观察，数据监听事件机制都未形成，不能获dom节点。data，computed，watch，methods上的方法和数据都不能访问\n因为data和methods数据都还未初始化\n\n创建后 created\nvue对象创建完成触发的函数\n实例初始化之后，data，props，computed导入完成\n要调用methods方法，或者操作data的数据最早只能在created中操作\n可以访问watch、methods、computed、data上的数据和方法\n\n挂载阶段\n挂载前 beforeMount\nvue对象开始挂载数据的时候触发的函数\n这个阶段是过渡性的，一般一个项目只能用到一两次。\n\n挂载后 mounted\nvue对象挂载完成的时候触发的函数\n完成创建vm.$el，和双向绑定只要执行完mounted,就表示整个Vue实例已经初始化完成了，此时组件已经脱离里了创建阶段， 进入到了运行阶段。\n这个时候dom在页面呈现了，你可以获取dom，一般用于ajax自动发起请求数据\n\n更新阶段更新前还可以对数据进行二次修改，更新后只能是观察数据变化。当data或者props更新或者上游组件更新的时候触发\n更新前 beforeUpdate\nvue对象中的data数据发生改变之前触发的函数\n当执行beforeUpdate的时候，页面中显示的数据还是旧的，此时date数据是最新的，页面尚未和最新数据数据保持同步。但是DOM中的数据会改变，这是vue双向数据绑定的作用，可在更新前访问现有的DOM，如手动移出添加的事件监听器。\n\n更新后 updated\nvue对象中的data数据发生改变完成触发的函数\nUpdated执行时数据已经保持同步了，都是最新的，完成虚拟DOM的重新渲染和打补丁。\n组件DOM已完成更新，可执行依赖的DOM操作。\n不要在此函数中操作数据（修改属性），否则就会陷入死循环。\n\n销毁阶段主要用于销毁常驻内存的垃圾，比如定时器，或者全局变量\n销毁前 beforeDestroy\nvue对象销毁之前触发的函数\n该组件还存在\n当执行beforeDestroy的时候，Vue实例就已经从运行阶段进入到销毁阶段了。实例上的所有date和methods以及过滤器和指令都是处于可用状态，此时还没有真正的执行销毁过程。\n\n销毁后 destroyed\nvue对象销毁完成触发的函数\n指令解绑和事件解绑以及子组件销毁完毕\n\nerrorCaptured捕获后代组件错误\n当组件发生错误时，会被该函数捕获\n该函数有三个参数，第一个错误本身信息，第二个是发生错误的组件实例对象，第三个是发生错误的触发信息\n该函数如果写return false则阻止错误继续向上传递\n\n插槽\n什么是插槽？vue为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽\n更高级的组件复用方式。接收dom片段或内容，加工处理后返回显示\n\nVue插槽的作用vue插槽是vue中常见的一种组件间的相互通信方式，作用是子组件中某个位置插入父组件的自定义html结构和data数据，在要接收数据的组件页面通过标签来表示。简单来说，就是通过此标签来起到占位的作用，而要插入的内容也会对应到标签所在的位置三种插槽的定义默认插槽（匿名插槽）\n定义：默认插槽是将父组件的结构和数据插入子组件中，默认插槽只有一个插入位置，要插入的html结构和data数据必须在父组件中，不过css可以在子组件中\n特点： 父组件决定结构和数据\n\n// 父组件    &lt;template&gt;        &lt;Child&gt;             &#123;/* Child为子组件标签             插槽内容，可以是template标签也可以是其他标签,比如&lt;img src=&quot;图片地址&quot; /&gt;  */&#125;            &lt;template&gt;要插入的html内容&lt;/template&gt;        &lt;/Child&gt;    &lt;/template&gt;// 子组件    &lt;template&gt;        &lt;div&gt;            &#123;/* 插槽位置            插槽通俗的说就是：挖个坑，等组件的使用者进行填充 */&#125;            &lt;slot&gt;这里可以写默认值，当使用者没有传递具体结构时，会显示此内容&lt;/slot&gt;        &lt;/div&gt;    &lt;/template&gt;\n\n具名插槽\n定义：简单地说就是具有名字的插槽，只是默认插槽只有一个插入位置，具名插槽可以有多个插入位置，根据名字来识别对应的插槽\n特点： 父组件决定结构和数据\n\n// 父组件&lt;template&gt;    &lt;Child&gt;         &#123;/* Child为子组件标签        插槽内容 */&#125;       &lt;template v-slot:one&gt;        &lt;testchart&gt;&lt;/testchart&gt;        //这是为了验证，子组件中的插槽可以填充任何结构的内容，所以在one插槽中插入一个组件        &lt;/template&gt;        &lt;template v-slot:two&gt;            我是要给two插槽的信息        &lt;/template&gt;    &lt;/Child&gt;&lt;/template&gt;export default&#123;    components:&#123;        testchart,        child    &#125;&#125;// 子组件&lt;div&gt;    &lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt;    &lt;slot name=&quot;two&quot;&gt;&lt;/slot&gt;&lt;/div&gt;\n\n作用域插槽\n定义：作用域插槽的data数据固定写在子组件中，数据的html结构根据父组件传入的html结构来决定\n简述： 根据父组件中不同的html结构解析data中的数据\n特点： 子组件决定数据，父组件决定结构\n父组件中的插槽模版template里，其作用域属于插槽组件&lt;slot :自定义name&#x3D;data中的属性或者对象&gt;\n\n  // 父组件  &lt;template&gt;      &lt;Child&gt;            &#123;/* Child为子组件标签           插槽内容，作用域插槽必须要写template   */&#125;          &lt;template slot=&quot;header&quot;&gt;              &lt;span v-for=&quot;m in data.msg&quot; :key=&quot;m&quot;&gt;&lt;/span&gt;          &lt;/template&gt;          &lt;template slot=&quot;center&quot;&gt;              &lt;div v-for=&quot;m in data.msg&quot; :key=&quot;m&quot;&gt;&lt;/div&gt;          &lt;/template&gt;          &lt;template slot=&quot;footer&quot;&gt;              &lt;label v-for=&quot;m in data.msg&quot; :key=&quot;m&quot;&gt;&lt;/label&gt;          &lt;/template&gt;      &lt;/Child&gt;  &lt;/template&gt;  // 子组件  &lt;template&gt;   &lt;div&gt;&#123;/* 插槽位置 插槽的结构是由使用者决定的 */&#125;&lt;slot :msg=&quot;msg&quot;&gt;插槽未被调用时会显示此内容&lt;/slot&gt;   &lt;/div&gt;  &lt;/template&gt;  &lt;script&gt;      export default &#123;          name: &#x27;Child&#x27;,          // 公用数据          data() &#123;              return &#123;                  msg: [&quot;火锅&quot;, &quot;红烧肉&quot;, &quot;烤羊腿&quot;]              &#125;          &#125;      &#125;  &lt;/script&gt;\n\n父传子：父组件使用v-bind 向插槽组件传参\n子传父：插槽组件在slot组件上使用v-bind 反向传参父组件使用v-slot=&#39;参数&#39; 接收数据[AIA]一句话概括就是v-slot:后边是插槽名称，&#x3D;后边是组件内部绑定作用域值的映射\n\nvue组件\n凡是以.vue做文件后缀的都是组件\n\n局部组件\n作用域只限于当前使用该组件的环境中生效\n\n语法// App.vueimport Com from &quot;./Com.vue&quot;components:&#123;    Com&#125;&lt;Com&gt;&lt;/Com&gt;\n\n全局组件\n该组件生效环境为整个项目，任何组件内使用都可以直接使用该组件，且不用单独导入\n\n语法 // main.jsimport MySon from &quot;./MySon.vue&quot;;Vue.component(&quot;my-son&quot;,MySon);// 每次只能挂载一个\n\n全局组件局部组件对比\n全局组件在使用上比局部组件更简单，更快，更省代码\n全局组件可能会污染全局环境，比如命名重复，被替换覆盖等问题，并且造成代码冗余，后期维护不方便\n所以要合理的使用全局组件，当一个组件被重复使用3次及以上则考虑全局组件\n\n组件通信\n定义：两个组件及以上进行数据交互，叫做组件通信\n分为两类\n\n\n父子之间通信\n非父子之间的通信\n\n父传子\n父组件使用 v-bind 给子组件绑定属性\n子组件使用 $emit接收父组件给的属性\n\n子传父\n父组件使用 v-on 给子组件绑定自定义事件函数\n子组件使用 $emit调用父组件传递的函数\n\n&lt;!-- 父组件 --&gt;    &lt;template&gt;        &lt;child :msg=&quot;articleList&quot; @changeMsg=&quot;changeMsg&quot;&gt;&lt;/child&gt;    &lt;/template&gt;    &lt;script&gt;        import child from &#x27;./child.vue&#x27;        export default &#123;            data() &#123;                return &#123;                    msg:&#x27;巧克力&#x27;                &#125;            &#125;,            methods:&#123;                changeMsg() &#123;                    this.msg = msg                &#125;            &#125;        &#125;    &lt;/script&gt;\n\n&lt;!-- 子组件 --&gt;    &lt;template&gt;        &lt;div&gt;            &lt;!-- 这里两个大括号中间放msg --&gt;            &lt;button @click=&quot;change&quot;&gt;改变字符串&lt;/button&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default &#123;            props:&#123;                msg:&#x27;&#x27;            &#125;,            methods:&#123;                change() &#123;                    this.$emit(&#x27;changeMsg&#x27;,&#x27;蛋挞&#x27;)                &#125;            &#125;        &#125;    &lt;/script&gt;\n兄弟\n使用父组件作为媒介，父组件充当中转站\n\n$parent和$children(不可控不推荐)\n通过$parent和$children可以访问组件实例，拿到实例代表什么？代表可以访问此组件的所有方法和data\nparent 获取直接父组件实例对象\nchildren 获取所有渲染的(必须要渲染在template里才能获取到)子组件集合\n\n&lt;!-- 父组件 --&gt;    &lt;template&gt;        &lt;div&gt;            &lt;!-- 这里两个大括号中间放msg --&gt;            &lt;button @click=&quot;changeA&quot;&gt;&lt;/button&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default &#123;            data() &#123;                return &#123;                    msg:&#x27;Welcome&#x27;                &#125;            &#125;,            methods:&#123;                changeA() &#123;                    // 获取到子组件A                    this.$children[0].messageA = &#x27;this is a new value&#x27;                &#125;            &#125;        &#125;    &lt;/script&gt;\n&lt;!-- 子组件 --&gt;    &lt;template&gt;        &lt;div&gt;            &lt;span&gt;两个大括号中间写messageA&lt;/span&gt;            &lt;p&gt;获取父组件的值为:两个大括号中间写parentVal&lt;/p&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default &#123;            data() &#123;                return &#123;                    messageA:&#x27;this is old&#x27;                &#125;            &#125;,            computed:&#123;                parentVal() &#123;                    return this.$parent.msg;                &#125;            &#125;        &#125;    &lt;/script&gt;\n\n[!注意]：注意边界，如果在#app上拿$parent得到的是new Vue()的实例，在这实例上再拿$parent得到的是undefined，而在最底层的子组件拿$children是个空数组。也要注意得到parent和parent和parent和children的值不一样，$children 的值是数组，而$parent是个对象。$children获取到的实例不保证顺序，因此当有多个子组件时可能获取到的不是自己想要的那一个。当组件嵌套多级时，可能会出现$parent.$parent.$parent…的情况，对于后续维护不友好。\n\nprops $emit 、 $parent $children两种方式用于父子组件之间的通信， 而使用props进行父子组件通信更加普遍，二者皆不能用于非父子组件之间的通信。\n\n跨层级$attrs 跨层级传递数据\n通过v-bind&#x3D;”$attrs”传入内部组件——在创建高级别的组件时非常有用\n$attrs可以收集父组件中的所有传过来的属性除了那些在组件中没有通过props定义的。不包括样式class 和 style。【Tip】什么时候用它以及为什么用它？我们如果使用props的话，最里面的组件想要获取最外层组件的数据，就要通过中间的组件的props来传递，但是这个props对于中间的这个组件没啥用处，它就是做了一个桥梁而已。所以就有了这个$attrs来帮助我们，不必在中间组件中写props就可以让最里面的组件拿到最外面组件传进来的数据。\n具体使用\n\n//grandfather    import father from &#x27;./father&#x27;    export default &#123;        components: &#123;            father        &#125;,    data()&#123;        return&#123;            time: new Date().getTime()        &#125;    &#125;&#125;\n&lt;!-- father --&gt;&lt;div style=&quot;background: red&quot;&gt;    child in father    &lt;div&gt;      &lt;span&gt;father age:&lt;/span&gt;      &lt;!-- 两个大括号包着fatherAge --&gt;    &lt;/div&gt;    &lt;child v-bind=&quot;$attrs&quot;&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt;    import child from &#x27;./child&#x27;    export default &#123;    components: &#123;        child    &#125;,    props: &#123;        fatherAge: &#123;            type: Number,            default: 0        &#125;    &#125;    &#125;&lt;/script&gt;\n&lt;!-- child --&gt;&lt;div style=&quot;background: green&quot;&gt;    &lt;div&gt;child&lt;/div&gt;    &lt;div&gt;time:         &lt;!-- 双括号中包着childTime --&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    export default &#123;        props: &#123;            childTime: &#123;            type: String,            default: &#x27;&#x27;            &#125;        &#125;    &#125;&lt;/script&gt;\n\n$listeners跨层级传递事件vue1.0以前，没有vuex，想全局管理共享的数据，需要使用“黑魔法”，单独的new一个vue实例对象，基于该对象做数据通信\n\n通过v-on&#x3D;”$listeners”传入内部组件时非常有用\n它是一个对象，里面包含了作用在这个组件上的所有监听器\n适用场景用.native修饰符可以把”focus”这个原生事件绑定在这个组件上。如果组件的根元素不能使用focus事件时，这个绑定会失效。比如:input 所以为了在input元素上绑定”focus”这个事件，必须在input上用v-on绑定原生事件\n\ninheritAttr默认情况下被父作用域的不被认作props的特性绑定，将会“回退”且作为普通的HTML特性应用在子组件的根元素上\n\n当设置inheritAttrs: true（默认）时，子组件的顶层标签元素中会渲染出父组件传递过来的属性\n不管inheritAttrs为true或者false，子组件中都能通过$attrs属性获取到父组件中传递过来的属性。\n\nbus中央事件总线$on和$event\n$on是事件派发\n$event事件监听\nbus无论是嵌套还是兄弟，他们都可以互相通信  A -&gt; A1  B和A1通信\n\n步骤\n全局定义bus:新建src&#x2F;eventBus.js文件// main.jsimport Vue from &#x27;vue&#x27;export const EventBus= new Vue()\n在组件中引入bus的引用import eventBus from &#x27;./bus/eventBus&#x27;Vue.prototype.$eventBus = eventBus\n通过$emit触发事件传值，在另一个组件中的mounted中用on监听事件从而获取值// 组件1var Event = new Vue()// 准备一个空的实例对象，相当于又new了一个vue实例，Event中含有vue的全部办法Event.$emit(&#x27;msg&#x27;,this.msg);// 发送数据，触发当前实例上的事件，要传递的数据会传递给监听器。第一个参数是发送数据名称，接收时还用这个名字接收，第二个参数是这个数据现在的位置// 组件2mounted:&#123;    Event.$on(&#x27;msg&#x27;,function(msg)&#123;// 接收数据，第一个参数是数据的名字，与发送时的名字对应，第二个参数是一个方法，要对数据进行操作    &#125;)&#125;\n\n[AIA]\n\nvue原型挂载总线Vue.prototype.bus &#x3D; new Vue()\n子组件发送数据this.bus.$emit(“change”,data)\n子组件接收数据this.bus.$on(“change”,function(data){})\n\nref&#x2F;$refs\nref:如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据，被用来给元素或子组件注册信息，引用信息将会注册在父组件的 $refs 对象上。\n适用场景：当使用element-ui组件时，可用于调用组件方法，例如el-table组件的选择表格项，排序等等。// 子组件export default &#123;    data() &#123;        return &#123;            name:&#x27;vue.js&#x27;        &#125;    &#125;,    methods:&#123;        sayHello:() &#123;            console.log(&#x27;hello&#x27;)        &#125;    &#125;&#125;\n\n&lt;!-- 父组件 app.vue --&gt;&lt;template&gt;    &lt;component ref=&quot;comA&quot;&gt;&lt;/component&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        mounted() &#123;            const comA = this.$ref.comA;            console.log(comA.name);//vue.js            comA.sayHello(); //hello        &#125;    &#125;&lt;/script&gt;\n\nref 这种方式，就是获取子组件的实例，然后可以直接子组件的方法和访问操作data的数据，就是父组件控制子组件的一种方式，子组件想向父组件传参或操作，只能通过其他的方式了\nprovide&#x2F;inject\n官方描述：选项需一起使用，允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效\n父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量\n\n应用provide\n\n一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。inject\n一个字符串数组\n一个对象\n\n//祖先组件 提供foo// 第一种export default &#123;    name:&quot;father&quot;,    provide() &#123;        return &#123;            foo:&#x27;hello&#x27;        &#125;    &#125;&#125;// 第二种export default &#123;    name:&quot;father&quot;,    provide:&#123;        foo:&#x27;hello~&#x27;    &#125;&#125;// 后代组件注入foo,直接当作this.foo来用export default &#123;    inject:[&#x27;foo&#x27;]&#125;/*    第一二种区别在哪儿？        如果需要this对象属性的值，        例如：            provide() &#123;                return &#123;                    test:this.msg                &#125;            &#125;        那么第二种是传不了的，后代组件拿不到数据。所以建议只写第一种 */\n[注意]一旦注入了某个数据，比如上面示例中的 foo，那这个组件中就不能再声明 foo 这个数据了，因为它已经被父级占有。\nprovide 和 inject 绑定并不是可响应的这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。因为对象是引用类型。\n\n先来个值类型的数据（也就是字符串）例子，不会响应\n\n    provide() &#123;        return &#123;            test:this.msg        &#125;    &#125;,    data() &#123;        return &#123;            msg:&quot;Welcome to Your Vue.js App&quot;        &#125;    &#125;,    mounted() &#123;        setTimeout(() =&gt; &#123;            this.msg = &quot;hello world&quot;            console.log(this._provided.msg) //Welcome to Your Vue.js App        &#125;,3000)    &#125;// 这样做是不行的，打印出来的 _provided 中的数据并没有改，子组件取得值也没变。若直接给 this._provided.msg 赋值，但是即使是_provided.msg 里面的值改变了，子组件的取值，依然没有变。\n\n\n但参数如果是对象，就可以响应了provide() &#123;    return &#123;        test:this.activeData    &#125;&#125;,data() &#123;    return &#123;        activeData:&#123;name:&#x27;xxxx&#x27;&#125;    &#125;&#125;,mounted() &#123;    setTimeout(() =&gt; &#123;        this.activeData.name = &#x27;aaaa&#x27;    &#125;,3000)&#125;\n\n用project与inject实现全局变量\n将其绑定到最顶层的组件app.vue，所有后代都接收到了，就是当做全局变量来用了。\n\n// app.vueexport default &#123;    name:&#x27;App&#x27;,    provide() &#123;        return &#123;            app:this        &#125;    &#125;,    data() &#123;        return &#123;            text:&quot;weiweiwei&quot;        &#125;    &#125;,    methods:&#123;        say() &#123;            console.log(&quot;enenen&quot;)        &#125;    &#125;&#125;// 其他所有子组件，需要全局变量的，只需按需注入app即可export default &#123;    inject:[&#x27;foo&#x27;,&#x27;app&#x27;],    mounted() &#123;        console.log(this.app.text);// 获取app中的变量        this.app.say();// 可以执行app中的方法，变身为全局方法    &#125;&#125;\n\nprovide&#x2F;inject实现页面刷新，不闪烁\n用vue-router重新路由到当前页面，页面是不进行刷新的\n采用window.reload()，或者router.go(0)刷新时，整个浏览器进行了重新加载，闪烁，体验不好上述办法都太行，那怎么办？\n\n\n控制路由的组件中写一个函数（使用v-if控制router-view的显示隐藏），然后把这个函数传递给后代，然后在后代组件中调用这个方法即可刷新路由啦。\n\n&lt;!-- app.vue --&gt;&lt;router-view v-if=&quot;isShowRouter&quot;/&gt;&lt;script&gt;export default &#123;    name:&#x27;App&#x27;,    provide() &#123;        return &#123;            reload:this.reload        &#125;    &#125;,    data() &#123;        return &#123;            isShowRouter:false        &#125;    &#125;,    methods:&#123;        reload() &#123;            this.isShowRouter = false            this.$nextTick(() =&gt; &#123;                this.isShowRouter = true            &#125;)        &#125;    &#125;&#125;// 后代组件export default &#123;    inject:[&#x27;reload&#x27;]&#125;//这里 provide 使用了函数传递给后代，然后后代调用这个函数，这种思路，也是可以做子后代向父组件传参通讯的思路了。这里的原理，和 event 事件订阅发布就很像了&lt;/script&gt;\n\n内置组件\n定义：除了原生标签是纯小写以外，非自定义组件纯小写标签都是内置组件\n\ntemplatevue内置模板组件，它不会渲染成任何真实的dom\nslot插槽组件，它也不会渲染成任何真实的dom,只是用于接收渲染插入的内容\nkeep-alive缓存状态组件，不会渲染成真实dom，只是将被包裹的自定义组件的状态缓存到内存中\n\n多用与缓存表单填写的组件\n它不能缓存v-for循环渲染出来的组件\n如果它包含多个子元素的话，需要使用v-if控制显示一个子元素【props】\ninclude 该属性控制keep-alive只缓存被指定的组件，不被指定的不缓存\nexclude 该属性控制keep-alive不缓存被指定的组件，不被指定的组件缓存\nmax 数字，限制keep-alive缓存组件的最大个数【生命周期】被keep-alive包裹的组件，才拥有该生命周期\nactivated被keep-alive激活的生命周期\ndeactivated被keep-alive销毁时候的生命周期\n\nkeep-alive使用\n几种常见用法\n&lt;script&gt;    export default &#123;        name:&#x27;test-keep-alive&#x27;,        data() &#123;            return &#123;                includedComponents:&quot;test-keep-alive&quot;            &#125;        &#125;    &#125;&lt;/script&gt;&lt;!-- 第一种 将缓存name为test-keep-alive的组件 --&gt;    &lt;keep-alive include=&quot;test-keep-alive&quot;&gt;        &lt;component&gt;&lt;/component&gt;    &lt;/keep-alive&gt;&lt;!-- 第二种 将缓存name为a或b的组件，结合动态组件使用 --&gt;    &lt;keep-alive include=&quot;a,b&quot;&gt;        &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;&lt;!-- 第三种 使用正则表达式，需使用v-bind --&gt;    &lt;keep-alive :include=&quot;/a|b/&quot;&gt;        &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;&lt;!-- 第四种 动态判断 --&gt;    &lt;keep-alive :include=&quot;includeComponents&quot;&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;&lt;!-- 第五种 将不缓存name为test-keep-alive的组件 --&gt;    &lt;keep-alive exclude=&quot;test-keep-alive&quot;&gt;        &lt;component&gt;&lt;/component&gt;    &lt;/keep-alive&gt;\n\n结合router，缓存部分页面[使用$route.meta的keepAlive属性]\n\n\n&lt;keep-alive&gt;    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;script&gt;    // router/index.js    export default new Router(&#123;        routes:[            &#123;                path:&#x27;/&#x27;,                name:&#x27;Hello&#x27;,                component:Hello,                meta:&#123;                    keepAlive:false // 不需要缓存                &#125;            &#125;,            &#123;                path:&#x27;/page1&#x27;,                name:&#x27;Page1&#x27;,                component:Page1,                meta:&#123;                    keepAlive:true // 需要被缓存                &#125;            &#125;        ]    &#125;)&lt;/script&gt;&lt;!-- page1页面 --&gt;&lt;template&gt;    &lt;div class=&quot;hello&quot;&gt;        &lt;h1&gt;Vue&lt;/h1&gt;        &lt;h2&gt;两个大括号包着msg&lt;/h2&gt;        &lt;input placeholder=&quot;输入框&quot;/&gt;    &lt;/div&gt;&lt;/template&gt;&lt;!-- hello页面 --&gt; &lt;template&gt;    &lt;div class=&quot;hello&quot;&gt;        &lt;h1&gt;两个大括号包着msg&lt;/h1&gt;    &lt;/div&gt;&lt;/template&gt;&lt;!--     结果：在page1页面输入框输入sss,然后手动跳转到hello页面，回到page1页面之前输入的sss依然保留，说明页面信息成功保存在内存中 --&gt;\n\n或者也可以通过动态设置route.meta的keepAlive属性来实现其他需求【要求】：首页是A页面 B页面跳转到A，A页面需要缓存，C页面跳转到A，A页面不需要被缓存 [思路]：思路是在每个路由的beforeRouteLeave(to, from, next)钩子中设置to.meta.keepAlive：\n\nto:Route 即将要进入目标路由对象\nfrom:Route 当前导航正要离开的路由\nnext：Function 一定要调用该方法来resolve这个钩子。执行效果依赖 next 方法的调用参数\nnext() 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed(确认的)\nnext(false) 中断当前的导航。如果浏览器的URL改变了(可能是用户手动或者浏览器后退按钮)，那么URL地址会重置到from路由对应的地址\nnext(‘&#x2F;‘) 或者next({path:’&#x2F;‘}):跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航\nnext(error) 如果传入next的参数是一个error实例，则导航会被终止且该错误会被传递给router.onError()注册过的回调\n\n\n\n // A的路由&#123;    path:&#x27;/&#x27;,    name:&#x27;A&#x27;,    component:A,    meta:&#123;        keepAlive:true // 需要缓存    &#125;&#125;export default &#123;    beforeRouteLeave(to,from,next) &#123;        // 设置下一个路由的meta        to.meta.keepAlive = true; //B跳转到A时，让A缓存，即不刷新        next()    &#125;&#125;export default &#123;    beforeRouteLeave(to,from,next) &#123;        // 设置下一个路由的meta        to.meta.keepAlive = false; // C 跳转到 A 时让A不缓存，即刷新        next();    &#125;&#125; \n\ncomponent动态加载组件\n特点\n必须使用动态绑定的is属性来加载组件\nis属性值必须是components里注册组件的名字\n让代码更简洁，更可控\n它的工作形式和v-if一致，使组件加载与销毁\n\n\n实现两个子组件动态切换&lt;!-- son1 --&gt;&lt;div&gt;    &lt;h1&gt;我是子组件1&lt;/h1&gt;    &lt;slot&gt;子组件1的默认内容&lt;/slot&gt;&lt;/div&gt;&lt;!-- son2 --&gt;&lt;div&gt;    &lt;h1&gt;我是子组件2&lt;/h1&gt;    &lt;slot&gt;子组件2的默认内容&lt;/slot&gt;&lt;/div&gt;&lt;!-- 父组件 --&gt;&lt;button @click=&quot;change1&quot;&gt;son1&lt;/button&gt;&lt;button @click=&quot;change2&quot;&gt;son2&lt;/button&gt;&lt;component :is=&#x27;state&#x27;&gt;&lt;/component&gt;&lt;script&gt;    data() &#123;        return &#123;state:&#x27;son1&#x27;&#125;    &#125;,    methods:&#123;        change1() &#123;this.state=&#x27;son1&#x27;&#125;,        change2() &#123;this.state=&#x27;son2&#x27;&#125;    &#125;,    components:&#123;        son1,son2    &#125;&lt;/script&gt;\n\n【Tip】\n\nson1,son2切换时，另一组件被销毁，所以，当两个组件进行动态切换时，组件的状态是：不断创建与销毁的过程\n如果想把组件缓存下来，可以在动态组件上使用vue另一个内置组件keep-alive \n     \n \n\n父子组件执行顺序的问题：\n问：我们在父组件和子组件son中分别定义个生命周期钩子mounted，页面加载到完成，父组件先渲染完成还是子组件先渲染完成呢？\n答：结果是父组件挂载完成前提：需等到子组件挂载完成后\n问：子组件先挂载完成，父组件才能挂载完成，下边代码我们在父组件中获取子组件的dom元素\n\n&lt;div id=&quot;app&quot;&gt;    &lt;son ref=&#x27;son&#x27;&gt;&lt;/son&gt;&lt;/div&gt;&lt;script&gt;    // 子组件    var son = &#123;        template:        &lt;div&gt;            &lt;h1&gt;双括号里包着name&lt;/h1&gt;        &lt;/div&gt;        ,        data() &#123;            return &#123;name:&#x27;hhh&#x27;&#125;        &#125;,        mounted() &#123;            this.name = &#x27;lll&#x27;        &#125;    &#125;    // 父组件(根实例)    var vm = new Vue(&#123;        el:&quot;#app&quot;,        mounted() &#123;            console.log(this.$refs.son.$el.innerText)        &#125;,        components:&#123;son&#125;    &#125;)&lt;/script&gt;&lt;!-- 上边代码，在子组件的mounted中我们修改了原来data对象中的数据，页面渲染完全没问题，但是在父组件mouted中输出子组件dom元素的内容时，不是新数据 &quot;lll&quot;，而是原来的数据 &quot;hhh&quot;  --&gt;\n\n【结论】子组件生命周期钩子mounted和父组件的mounted都是同步执行的，但是子组件渲染却是异步渲染的，所以在父组件的mounted中获取dom元素是原来的子组件数据！！[解决上述bug] 用vm.$nextTick中去获取dom元素\n// 子组件    .......// 父组件(根实例)var vm = new Vue(&#123;    el:&quot;#app&quot;,    mounted() &#123;        this.$nextTick(function() &#123;            console.log(this.$refs.son.$el.innerText)        &#125;)    &#125;,    components:&#123;son&#125;&#125;)\nBTW——el和$el\nel是Vue实例的挂载目标，实例挂载后，元素可以用xx.$el访问。挂载阶段还没开始的时候,$el属性是不可见的。vue生命周期mounted阶段，el被新创建的xx.$el替换，这个时候Vue实例的挂载目标确定，DOM渲染完毕\n\ntransition动画组件组件出现过度&#x2F;动画效果的原因【当插入或删除包含在transition组件中的元素时，Vue将会做以下处理】：\n\n自动嗅探目标元素是否应用里css过度或动画，如果是，在恰当的时机添加&#x2F;删除css类名\n如果过度组件提供了JS钩子函数，这些钩子函数将在恰当时机被调用\n如果没有找到JS钩子函数也没有检测到css过渡&#x2F;动画，DOM操作(插入&#x2F;删除)在下一帧中立即执行。(注意：此浏览器逐帧动画机制，和Vue的nextTick概念不同)\n\ntransition组件在什么情况下可以生成动画效果？【Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入&#x2F;离开过渡动画效果】\n\n条件渲染(使用v-if)，可以使用key代替v-if\n条件展示(使用v-show)\n动态组件 \n组件根节点 transition&#x2F;transition-group作为跟组件，形成可服用动态组件\n\ntransition组件生成动画效果的方式【Vue在插入、更新或者移除DOM 时，提供了以下不同方式的应用过渡效果】：\n\n在css过渡和动画中自动应用class\n可以配合使用第三方css动画库，如animate.css\n在过渡钩子函数中使用javascript 直接操作 dom\n可以配合使用第三方 JavaScript 动画库，如 Velocity.js\n\n分别详细介绍\n【css过渡】：常用的过渡都是使用 CSS 过渡，也就是 组件和css3属性transition连用\n\napi\nname 指定自己写的动画类名前缀\nv-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。\nenter-class-active 进入动画的类名\nleave-class-active 离开动画的类名\nduration 设置动画执行的间隔时间\nv-enter-active: 定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition&#x2F;animation 完成之后移除。 这个类可以被用来定义过渡的过程时间，延迟和曲线函数。\nv-enter-to: 定义进入过渡的结束状态。在元素被插入一帧后生效（于此同时 v-enter 被删除），在 transition&#x2F;animation 完成之后移除。\nv-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。\nv-leave-active: 定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition&#x2F;animation 完成之后移除。 这个类可以被用来定义过渡的过程时间，延迟和曲线函数。\nv-leave-to: 定义离开过渡的结束状态。在离开过渡被触发一帧后生效（于此同时 v-leave 被删除），在transition&#x2F;animation 完成之后移除。\n\n&lt;div id=&quot;app4&quot;&gt;    &lt;button @click=&quot;show = !show&quot;&gt;        toggle coustom class    &lt;/button&gt;    &lt;transition         name=&quot;bounce&quot;        enter-active-class=&quot;animated tada&quot;        leave-active-class=&quot;animated bounceOutRight&quot;&gt;        &lt;p v-if=&quot;show&quot;&gt;自定义过渡类名&lt;/p&gt;    &lt;/transition&gt;&lt;/div&gt;&lt;!-- 样式如此设置，只需要控制show是false还是true，即可有淡入淡出效果 --&gt;&lt;style&gt;    .fade-enter-active,.fade-leave-active&#123;        transition: opacity 0.5s;           &#125;    .fade-enter,.fade-leave-to&#123;        opacity:0    &#125;&lt;/style&gt;&lt;script&gt;    data:&#123;        return &#123;            show:true        &#125;    &#125;&lt;/script&gt;&lt;!-- 对于这些enter/leave过渡中切换的类名，v-是这些类名的前缀。使用使用&lt;transition name=&quot;my-transition&quot; 可以重置前缀，比如 v-enter 替换为 my-transition-enter。 --&gt;\n\n\n【过渡可以和其他第三方 CSS 动画库连用】\n\n&lt;transition     name=&quot;bounce&quot;    enter-active-class=&quot;animated tada&quot;    leave-active-class=&quot;animated bounceOutRight&quot;&gt;    &lt;p v-if=&quot;show&quot;&gt;自定义过渡类名&lt;/p&gt;&lt;/transition&gt;export default&#123;    data:&#123;        show:true    &#125;&#125; // 不需要设置样式，只需要控制show是false还是true，即可有动画效果\n\n\n【CSS 动画】\n\n\nCSS 动画是transition组件和css3属性animation连用，用法和 CSS 过渡相同\n区别是：在动画中 v-enter 类名在节点插入DOM后不会立即删除，而是在 animationend 事件触发时删除。\n\n&lt;transition name=&quot;bounce&quot;&gt;     &lt;p v-if=&quot;show&quot;&gt;使用animation做动画效果&lt;/p&gt;&lt;/transition&gt;&lt;style&gt;     .bounce-enter-active&#123;animation:bounce-in 0.5s&#125;    .bounce-leave-active&#123;animation:bounce-in 0.5s reverse&#125;    @keyframes bounce-in&#123;        0%&#123;transform:scale(0)&#125;        50%&#123;transform:scale(1.5)&#125;        100%&#123;transform:scale(1)&#125;    &#125;&lt;/style&gt;\n\n\n【transition组件和JavaScript 钩子连用】\n\n\n当只用js过渡的时候，在enter和leave中必须使用done进行回调。否则，它们将被同步调用，过渡会立即完成\n推荐对于仅使用JS过渡的元素v-bind:css&#x3D;”false”,Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。\n\n&lt;transition    @before-enter=&quot;beforeEnter&quot;    @enter=&quot;enter&quot;    @after-enter=&quot;afterEnter&quot;    v-on:before-leave=&quot;beforeLeave&quot;    v-on:leave=&quot;leave&quot;    v-on:after-leave=&quot;afterLeave&quot; &gt;&lt;div id=&quot;ball&quot; v-show=&quot;show&quot;&gt;hello&lt;/div&gt;    &lt;/transition&gt;&lt;script&gt;    data:&#123;show:true&#125;    methods:&#123;    //el 即操作的元素对象    beforeEnter(el)&#123;        el.style.transform=&#x27;translate(80px,80px)&#x27;;    &#125;    enter(el,done)&#123;        // 必须下面加下面一行，否则不会出现应有的效果        el.offsetWidth;//这里可以理解成强制浏览器刷新，也可以写成el.offsetHeight        el.style.transition=&#x27;all 1.5s ease&#x27;        el.style.transform=&#x27;translate(0,0)&#x27;;        done()    &#125;,    afterEnter(el)&#123;        cnosole.log(&#x27;afterEnter&#x27;)        // this.flag=false;//隐藏小球    &#125;,    beforeLeave:function(el)&#123;        el.style.transform=&#x27;translate(0,0)&#x27;    &#125;,    // 当与CSS结合时    // 回调函数done是可选的    leave:function(el,done)&#123;        el.offsetWidth;//这里可以理解成强制浏览器刷新，也可以写el.offsetHeight        el.style.transition=&#x27;all 3s ease&#x27;        el.style.transform=&#x27;translate(80px 80px)&#x27;        // 这是直接调用done的话由于会立即删除元素导致动画不执行        done()        // 解决办法        方法1：不调用done可以进行动画，但是元素依旧存在，并且afterLeave函数钩子不执行        方法2：        //setTimeout可以解决这个问题，让done不立即执行，过几秒后再执行setTimeout(done,3000);//时间根据自己设定的动画时间确定    &#125;,    afterLeave:function(el)&#123;        console.log(&#x27;afterLeave&#x27;)    &#125;&#125;&lt;/script&gt; \n\n[注意]：在leave函数钩子中，直接调用done函数，会立即删除元素导致动画不执行\n\n和JS动画库Velocity一起使用// &lt;div id=&quot;app5&quot;&gt;//     &lt;button @click=&quot;show = !show&quot;&gt;toggle hook&lt;/button&gt;//     &lt;transition @before-enter=&quot;beforeEnter&quot;//                 @enter=&quot;enter&quot;//                 @leave=&quot;leave&quot;//                 :css=&quot;false&quot;&gt;//             &lt;p v-if=&quot;show&quot;&gt;javascript 钩子使用&lt;/p&gt;//     &lt;/transition&gt;// &lt;/div&gt;    methods:&#123;        beforeEnter:function (el) &#123;            console.log(el);            alert(&quot;beforeEnter&quot;);            el.style.opacity = 0            el.style.transformOrigin = &#x27;left&#x27;        &#125;,        enter:function (el, done) &#123;            alert(&quot;enter&quot;);        //    console.log(done);            Velocity(el, &#123;opacity:1, fontSize:&#x27;1.4em&#x27;&#125;, &#123;duration:300&#125;);            Velocity(el, &#123;fontSize:&#x27;1em&#x27;&#125;, &#123;complete:done&#125;);            Velocity(el,&quot;reverse&quot;, &#123; duration: 6000 &#125;);            Velocity(el,&#123;                        borderBottomWidth: [ &quot;2px&quot;, &quot;spring&quot; ], // Uses &quot;spring&quot;                    width: [ &quot;100px&quot;, [ 250, 15 ] ], // Uses custom spring physics                        height: &quot;100px&quot; // Defaults to easeInSine, the call&#x27;s default easing                    &#125;, &#123;                            easing: &quot;easeInSine&quot; // Default easing                    &#125;);        &#125;,        leave:function (el, done) &#123;            Velocity(el, &#123;translateX:&#x27;15px&#x27;, rotateZ:&#x27;50deg&#x27;&#125;, &#123;duration:600&#125;)            Velocity(el, &#123;rotateZ:&#x27;100deg&#x27;&#125;, &#123;loop:2&#125;)            Velocity(el,&#123;                rotateZ:&#x27;45deg&#x27;,                translateY:&#x27;30px&#x27;,                translateX:&#x27;30px&#x27;,                opacity:0            &#125;, &#123;complete:done&#125;)        &#125;       &#125;\n\n\n【组件间切换的动态效果实现】组件的过渡-不需要使用key attribute。使用动态组件component，进行切换\n【元素间切换的动态效果实现】\n\n\n6.1原生标签可以使用 v-if&#x2F;v-else \n    \n      Save\n    \n    \n      Edit\n    \n  \n\n[注意]：当有相同标签名的元素切换时(比如两个div元素)，必须通过 key attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容（也就是不会有动画效果）。\n\n6.2设置key代替v-if&#x2F;v-else\n  \n    \n    双括号中间包着isEdting ? 'Save':'Edit'\n    \n  \n\n6.3两种过渡模式多个元素间的过度动画（一个元素离开，一个元素进入），是同时生效的。这种情形不能满足所有要求，所以 Vue 提供了过渡模式。\n\nin-out：新元素先进行过渡，完成之后当前元素过渡离开。\nout-in：当前元素先进行过渡，完成之后新元素过渡进入  \n  \n  \n\n\n\n\n【可复用过渡组件】过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将  或者  作为根组件，然后将任何子组件放置在其中就可以了。\n\n    Vue.component(&#x27;my-special-transition&#x27;, &#123;        template: &#x27;\\ name=&quot;very-special-transition&quot;\\        mode=&quot;out-in&quot;\\        v-on:before-enter=&quot;beforeEnter&quot;\\        v-on:after-enter=&quot;afterEnter&quot;\\    &gt;\\\\\\&#x27;,methods: &#123;beforeEnter: function (el) &#123;// ...                        &#125;,afterEnter: function (el) &#123;// ...                        &#125;    &#125;&#125;)函数组件更适合完成这个任务：Vue.component(&#x27;my-special-transition&#x27;, &#123;functional: true,render: function (createElement, context) &#123;var data = &#123;    props: &#123;    name: &#x27;very-special-transition&#x27;    mode: &#x27;out-in&#x27;&#125;,on: &#123;beforeEnter: function (el) &#123;// ...                            &#125;,afterEnter: function (el) &#123;// ...                            &#125;    &#125;&#125;    return createElement(&#x27;transition&#x27;, data, context.children)    &#125;&#125;)\nBTW——当内置组件混合使用时的嵌套顺序transition&gt;keep-alive&gt;component\n递归组件用不同的输入参数一次又一次地执行相同的代码块，直到达到结束点[注意点]\n\n数据源必须来自上游\n递归组件必须要有”name”属性，且值与组件文件名一致\n必须要有v-if的终止渲染条件v-if &#x3D;”activeld” &amp;&amp; datalist[activeld].children即需要 datalist[activeId] 存在 &amp;&amp; datalist[activeId] &lt;!-- 假设我们在windows中绑定了一个arr --&gt;&lt;div v-if=&quot;arr.length&gt;0||arr!=null&quot;&gt;hhh&lt;/div&gt;&lt;div v-else&gt;xxx&lt;/div&gt;&lt;!-- 报错出现在我们的前半条判断中，在我们判断数组的长度是否大于零的时候，需要先判断我们是否有数组，如果没有数组的话，那么这条数据就会发生报错 --&gt;\n\nBTW——自定义组件要么首字母大写，要么用中划线的方式\nnextTick\n等所有dom更新完毕后触发(执行其指定的回调)，因为vue中dom更新是异步的才有这个东西\n语法    this.$nextTick(() =&gt; &#123;        // 获取更新后的dom内容    &#125;)    this.$nextTick().then(() =&gt; &#123;\t// 获取更新后的dom内容&#125;);\n应用场景\n\n\ncreated()进行DOM操作一定要放在Vue.nextTick()的回调函数\n在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中\n\n过滤器在不修改原始数据的情况下，对数据进行计算并返回新数据，该方法只能用在插值语法中\n\n双大括号插值和v-bind 表达式（后者从2.1.0+开始支持）\n\n过滤器函数总接收表达式的值作为第一个参数   \n两个大括号中间写着 message |\n\n\n在上述例子汇总，filter过滤器函数将会收到message的值作为第一个参数\n\n过滤器可以串联\n两个大括号中间写着 message | filterA | filterB在这个例子中，filterA被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将filterA的结果传递到filterB中\n\n过滤器是javascript 函数可以接收参数\n两个大括号中间写着 message | filterA(‘arg1’,arg2filterA被定义为接收三个参数的过滤器函数。其中message的值作为第一个参数，普通字符串’arg1’作为第二个参数，表达式arg2作为第三个参数\n\n全局过滤器filter 每次只能写一个\nVue.filter(&quot;prefix&quot;,(n) =&gt; &quot;¥&quot;+n)\n使用| 叫管道符号\n\n语法：Vue.filter(filterName,() =&gt; &#123;return //数据处理结果&#125;)\n实际开发使用\nstep1 用在数据修饰上，通常我们把函数抽离出去，统一放在个.js文件中\n\n// filter.jslet filterPrice=(value) =&gt; &#123;    return &#x27;已收款&#x27; + value.&#x27;元&#x27;&#125;let filterDate=(value) =&gt; &#123;    return value + &#x27;天&#x27;&#125;export default&#123;filterPrice,filterDate&#125;\n\nstep2 在main.js中导入上边filter.js文件，也可以在任何组件中导入filter.js这个文件，但对于全局过滤器来说，最好是在main.js中定义，导入的是一个对象，所以使用Object.keys()方法，得到一个由key组成的数组，遍历数组，让key作为全局过滤器的名字，后面的是key对应的处理函数，这样在任何一个组件中都可以使用全局过滤器了\n\n// main.js    // 两种导入方式 推荐第一种    import * as filters from &#x27;./filter&#x27;    import &#123;filterPrice,filterDate&#125; from &#x27;./filter&#x27;    Object.keys(filters.default).forEach((item) =&gt; &#123;        Vue.filter(item,filters.default[item])    &#125;)    new Vue(&#123;        router,        store,        render:h =&gt; h(App)    &#125;).$mount(&#x27;#app&#x27;)\n\nstep3在组件中使用 全局过滤器\n\n&lt;template&gt;    &lt;div&gt;        &lt;input type=&quot;text&quot; v-model=&quot;filterCount&quot;&gt;        &lt;div&gt;两个大括号中间写 filterCount | filterPrice&lt;/div&gt;        &lt;div&gt;两个大括号中间写 filterCount | filterDate&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        data() &#123;            return &#123;                filterCount:1500            &#125;        &#125;    &#125;&lt;/script&gt;\n\n组件过滤器filters可以写很多个\nfilters:&#123;n1(n)&#123;    return n+2&#125;&#125;\n样例&lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;filterCount&quot; /&gt;    &lt;div class=&quot;filter&quot;&gt;两个大括号中间写 filterCount | changeCapitalLetter&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    export default &#123;        data() &#123;            return &#123;                filterCount:&#x27;hello&#x27;            &#125;        &#125;,    filters:&#123;        changeCapitalLetter(value) &#123;            // value是输入框的内容也是要显示的            if(value) &#123;                let str = value.toString();                // 获取英文，以空格分组把字符串转为数组，遍历每一项第一项转为大写字母                let newArr = str.split(&quot;&quot;).map(ele =&gt; &#123;                    return ele.charAt(0).toUppeCase()+ele.slice(1)                &#125;);                return newArr.join(&quot;&quot;) // 数组转字符串以空格输出                &#125;            &#125;        &#125;    &#125;&lt;/script&gt;\n\n常见使用场景：格式日期(时间)，金钱单位，保留小数位\n\n模块化\n定义:[简单来说]就是模块化就是将变量和函数,放入不同的文件中\n\n模块的优点?\n可维护性强:因为模块独立，代码依赖小，自己可以独立更新和改进\n命名空间:一般一个变量在最顶级的函数外声明，可以全局使用，易出现命名冲突的情况。使用模块化开发来封装变量，可以避免全局污染\n重用代码：通过模块引用的方式，来复用代码\n\nCommonJS AMD&#x2F;CMD\n定义：CommonJS是一种规范语法，内容有很多种，nodejs是这种规范的实现【扩展】：1.SeaJS是模块加载器，是用CMD规范    2.AMD&#x2F;CMD是从 CommonJS 讨论中诞生的    3.RequireJS 遵循 AMD（异步模块定义）规范    4.Sea.js 遵循 CMD （通用模块定义）规范  规范的不同，导致了两者 API 不同。  [AMD] 提前执行：提前异步并行加载      优点：尽早执行依赖可以尽早发现错误      缺点：易产生浪费  [CMD] 延迟执行：延迟按需加载      优点：减少资源浪费      缺点：等待时间长、出错时间延后\n\n// CMD 依赖就近 define(function(require,exports,module)&#123;// 定义模块    var demo=require(&#x27;demo&#x27;)    var x=demo.demo()    var web=&#123;        add:function(x)&#123;            return x+y        &#125;    &#125;;    return &#123;        web:web    &#125;;&#125;);\n[RequireJS] 前端模块化管理工库\n        详解：通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新函数(模块)，我们所有关于新模块的业务代码都在这个函数内部操作，其内部也可以无限制的使用已经加载进来的模块\n\n// main.jsrequire.config(&#123;    abc:&#123;        &#x27;boostrap&#x27;:&#123;            deps:[&#x27;jquery&#x27;],            exports:&#x27;boostrap&#x27;        &#125;    &#125;,    paths:&#123;        &quot;jquery&quot;:&quot;路径&quot;,        &quot;boostrap&quot;:&quot;路径&quot;,        &quot;index&quot;:&quot;index&quot;    &#125;&#125;);require([&#x27;jquery&#x27;,&#x27;boostrap&#x27;,&#x27;index&#x27;],function($,bootstrap,index)&#123;    console.log(index.web.add(11));    $(&quot;.p1&quot;).text(index.web.add(11))&#125;)\nES6模块\n导入导出var name = &#x27;AI&#x27;;var phone = &#x27;3571678&#x27;var hobby = &#x27;购物&#x27;;// 普通导出导入    export &#123;name, phone, hobby&#125;;    // 导入    import &#123;name, phone, hobby&#125; from &#x27;./views/moduleA&#x27; // 导出export别名    export &#123; name as v1, age as v2, hobby as v3&#125;;    // 导入    import &#123;v1, v2, v3&#125; from &#x27;./views/moduleA&#x27;;//导出export default仅有一个    export default &#123;name:&#x27;lll&#x27;,hobby:&#x27;games&#x27;&#125;    // 导入    import obj from &#x27;./views/moduleD&#x27;// 定义公共数据    // 性别    export const sexData=[        &#123;key:&#x27;man&#x27;,value:&#x27;男&#x27;&#125;,        &#123;key:&#x27;woman&#x27;,value:&#x27;女&#x27;&#125;    ]    //用户    export const userData = [        &#123;id:&#x27;1&#x27;,value:&#x27;name1&#x27;&#125;,        &#123;id:&#x27;2&#x27;,value:&#x27;name2&#x27;&#125;     ];    // 导入    import &#123;sexData,userData&#125; from &#x27;./views/moduleB&#x27; \n图片的导入// 1.直接导入 &lt;img src=&#x27;&#x27;&gt;// 2.通过import    import img1 from &#x27;./assets/img/1.jpg&#x27; //导入图片    &lt;img :src=&quot;img1&quot; /&gt;&lt;/div&gt; // 3.通过require的方式   data()&#123;       return&#123;           img:[               require(&quot;@/assets/img/1.jpg&quot;),               require(&quot;@/assets/img/2.jpg&quot;)           ]       &#125;   &#125;\n\ncommon.js和es6模块的区别？node使用的是commonjs 在使用模块的时候是运行时同步加载的，拷贝模块中的对象，模块可以多次加载，但只会在第一次加载，之后会被缓存，引入的是缓存中的值\n\ncommonjs输出的是一个值的拷贝，而es6输出的是值的引用\ncommonjs是运行时加载，es6是编译时输出接口\n\n混入mixins\n定义：将多个组件内重复使用的js部分抽离出来，作为混入文件，哪里复用插哪里\n\n语法// mixins.js    export default &#123;      // ...组件内所有的配置，这里都有        data()&#123;&#125;,        props:[],        methods:&#123;&#125;,        // 生命周期        mixins:[],        components:&#123;&#125;,    &#125;\n// App.vue    import mixins from &quot;./mixins&quot;;    export default&#123;        mixins:[mixins,p,p]//为什么要写成数组形式？因为这里面有顺序,若函数有重复会依次合并，    &#125;\n为了复用代码，复用js，三个组件，每个组件内都有同一个业务，同一个事件，并且事件的处理内容都一样\n特点只能复用js，且组成部分与vue组件中的script完全一致\n混入的优缺点优点节省代码量，让代码高复用，降低了代码的重复率。让vue组件’瘦身’\n缺点容易冲突，不好控制，后期维护成本高\n执行顺序及特性执行顺序是先执行混入文件后执行组件。如果mixins里有多个混入的话，会按照顺序依次执行\n特性\n数据、函数，如果组件内和混入里的命名重复了则使用组件内的覆盖混入里的\n如果混入里和组件内有相同的生命周期，则两个生命周期都会执行，先执行混入后执行组件\n\nextends扩展扩展执行表现形式和混入完全一样\nextends和mixins区别\n扩展只能挂载一个\n而混入可以使用数组的方式挂载很多个混入\n\n数据监听方法一：利用keyup事件来实现 // 定义一个getFullName函数        // &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot; @keyup =&quot;getFullName&quot;&gt; +        // &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot; @keyup=&quot;getFullName&quot;&gt; =        // &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot; @keyup=&quot;getFullName&quot;&gt; // 在vm中定义方法    el:&quot;#app&quot;,    data() &#123;        lastname:&#x27;&#x27;,        firstname:&#x27;&#x27;,        fullname:&#x27;&#x27;    &#125;,    methods:&#123;        getFullName() &#123;            this.fullname = this.lastname+&#x27;-&#x27;+this.firstname        &#125;    &#125;\nwatch侦听器\n专门用于监听数据变化的  使用这个属性，可以监视data中指定数据的变化，然后触发这个watch中对应的function可以不用绑定事件\n\n特性\n在watch中可以对另外一个数据修改\n可以对监听的数据进行固定值赋值，因为watch会新旧值对比，发现一致则不会再触发监听了\n监听数据，赋值如果是递增或递减则会报错\n默认只能是监听基本数据类型和数组的值\n如果监听的是对象，则需要对象写法\n不需要返回值\n它可以执行异步操作：定时器、ajax\n\nwatch–监听数据变化 &lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; +    &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; =    &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt;&lt;script&gt;    el:&quot;#app&quot;,    data()&#123;        lastname:&#x27;&#x27;,        firstname:&#x27;&#x27;,        fullname:&#x27;&#x27;    &#125;,    methods:&#123;&#125;,    watch:&#123;        &#x27;lastname&#x27;:function(newVal)&#123;            this.fullname=newVal+&#x27;-&#x27;+this.firstname        &#125;        &#x27;firstname&#x27;:function(newVal)&#123;            this.fullname=newVal+&#x27;-&#x27;+this.lastname        &#125;    &#125;&lt;/script&gt;\n三个选项\nhandler 平时的写法，就默认写的是handler\nimmediate\n默认false，在进入页面，第一次绑定值，不会立刻执行监听，只有数据发生改变才会执行handler中的操作\n为true时，handler在第一次绑定值时就触发\n\n\ndeep 用来进行深度监听，监听到对象属性的变化\n\n语法格式// 1.监听基本数据类型watch:&#123;    name(val,oldVal) &#123;         // val是新值，oldVal是旧值    &#125;,    // 等价于    name:function() &#123;&#125;,    // 不能写箭头函数，因为箭头函数中的this值的是函数定义时所在的对象而不是函数运行时所在的对象    // name: () =&gt; &#123;&#125; // error xxx// 2. 监听对象watch:&#123;    obj:&#123;        // 深度监听        deep:true,        // 执行函数        handler(val) &#123;&#125;,        // 自动执行一次        immediate:true    &#125;&#125;// 只监听对象中的某一个属性值// 点语法只限于对象使用，数组不可以    &#x27;obj.age&#x27;(val,old)&#123;&#125;    &#x27;obj.age&#x27;:function()&#123;&#125;&#125;\n\nwatch–监听路由变化&lt;router-link to=&quot;/login&quot;&gt;登陆&lt;/router-link&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;script&gt;    watch:&#123;        &#x27;$route.path&#x27;:function(val,oldVal)&#123;            if(newVal===&#x27;/login&#x27;) &#123;                console.log(&#x27;欢迎进入login&#x27;)            &#125;else if(newVal===&#x27;/register&#x27;) &#123;                console.log(&#x27;欢迎进入register&#x27;)            &#125;        &#125;    &#125;    // router/index.js    const router = new VueRouter(&#123;        routes:[            &#123;path:&#x27;/&#x27;,redirect:&#x27;/login&#x27;&#125;,            &#123;path:&#x27;login&#x27;,component:login&#125;,            &#123;path:&#x27;register&#x27;,component:register&#125;        ]    &#125;)&lt;/script&gt;\n\ncomputed计算属性\n定义：监听一个值返回一个新值，且新值必须使用才能监听成功\n\n特性\n由于计算属性需要立即返回新值，因此不能处理异步操作\n计算属性不受数据类型限制，任何数据都可以被监听\n默认计算属性的值是只读的，不可以直接修改\n如果要修改计算属性，则需要使用对象写法\n计算属性可以监听多个值\n有缓存，提高渲染性能\n如果在页面上需要用到 对现有的数据进行加工得到新数据，则是要使用计算属性\n想要给计算属性赋值，则需要使用set方法\n计算属性和data一样，都需要设置return，当没有输出结果时，需要排查是不是return漏掉了\n\n&lt;div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; +    &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; =    &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot;&gt; &lt;/div&gt;&lt;script&gt;    data()&#123;        lastname:&#x27;&#x27;,        firstname:&#x27;&#x27;    &#125;,    computed:&#123;        &#x27;fullname&#x27;:function()&#123;            return this.lastname+&#x27;-&#x27;+this.firstname        &#125;    &#125;&lt;/script&gt;\n\n[!注意]\n\nfullname没有在data中定义，在computed定义fullname后直接return出去就好\n计算属性的求值结果，会被缓存起来，方便下次直接使用\n不会因为页面中调用几次函数去执行几次，只会根据函数执行来调用函数(比如页面放入很多插值,例如fullname，在function中console.log(ok),刷新页面时，后台只会出现一个OK和初始就在的OK)\n\n语法格式computed:&#123;    // 基础使用    newStr() &#123;        return this.str+&#x27;xxx&#x27;    &#125;,    // 修改写法    myData:&#123;        get() &#123;            return this.my        &#125;,        set(value) &#123;            this.my = value        &#125;    &#125;&#125;\n\nwatch computed methods 对比\ncomputed属性结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用\nmethods 方法表示一个具体的操作，主要书写业务逻辑\nwatch一个对象，键时需要观察的表达式，值对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体\n\nwatch computed 区别\nwatch不支持缓存，computed有缓存\nwatch支持异步，computed不支持异步\nwatch不需要返回新值，computed需要返回新值\nwatch只能监听一个属性，computed能监听多个属性\nwatch只能监听基本数据类型和数组的值，computed不受数据类型限制\n\n自定义指令扩展了vue没有的操作dom的指令，比如登录页的用户名输入框自动获取焦点，根据用户权限控制某些元素的是否可见等。\n组件内directives\n&lt;script&gt;    // 声明    directives:&#123;        focus:&#123;            // 绑定的时候初始化            bind(el,binding)&#123;&#125;,            // 元素的父集已经呈现，用于指令的操作            inserted(el,binding)&#123;&#125;,            // 更新：自己更新，不能保证子元素更新完            update(el,binding)&#123;&#125;,             // 等待当前组件的所有元素全部更新完毕            componentUpdate(el,binding)&#123;&#125;            // 指令解绑，当组件被销毁的时候触发            unbind(el,binding)&#123;&#125;        &#125;    &#125;&lt;/script&gt;&lt;!-- 使用 --&gt;    &lt;input type=&#x27;text&#x27; v-focus=&#x27;show&#x27;/&gt;\n全局directive 每次只能声明一个。\nVue.directive(&quot;hidden&quot;,&#123;    inserted(el,binding,vnode)&#123;        // binding.value是指令绑定入参        if(binding.value)&#123;            el.style.display=&quot;none&quot;        &#125;else&#123;            el.style.display=&quot;block&quot;        &#125;    &#125;&#125;)\n\n路由根据URL分配到对应的应用程序；作用就是解析URL，调用对应的控制器。简而言之，路由是指把数据从一个地方传送到另一个地方的行为和动作vue路由有助于在浏览器的URL或历史记录与Vue组件之间建立链接用法&lt;div&gt;    &lt;!-- 使用router-link组件来导航 --&gt;    &lt;!-- 通过传入`to`属性指定链接 --&gt;    &lt;!-- router-link 默认会被渲染成一个&lt;a&gt;&lt;/a&gt;标签 --&gt;    &lt;router-link to=&quot;/home&quot;&gt;home&lt;/router-link&gt;    &lt;router-link to=&quot;/news&quot;&gt;news&lt;/router-link&gt;&lt;/div&gt;&lt;!-- 路由出口 --&gt;&lt;!-- 路由匹配到的组件渲染在这里 --&gt;&lt;router-view&gt;&lt;/router-view&gt;\n[1.定义路由组件]:\n&lt;script&gt;     var Home = &#123; template: &#x27;#home&#x27;&#125;    var News = &#123; template: &#x27;#news&#x27;&#125;   &lt;/script&gt;    &lt;!-- 对应的模块内容： --&gt;    &lt;template id=&quot;home&quot;&gt;         &lt;div&gt;             &lt;h3&gt;组件home&lt;/h3&gt;         &lt;/div&gt;    &lt;/template&gt;    &lt;template id=&quot;news&quot;&gt;         &lt;div&gt;             &lt;h3&gt;组件news&lt;/h3&gt;         &lt;/div&gt;    &lt;/template&gt;\n\n[2.定义路由]：\n// router/index.js    const routes = [        &#123;path: &#x27;/home&#x27;, component: Home&#125;,        &#123;path: &#x27;/news&#x27;, component: News&#125;,         &#123;path: &#x27;/&#x27;, redirect: &#x27;/home&#x27;&#125;    ];    /*    路由命名：        有时候通过一个名称来标识一个路由显得更方便一些，特别是链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。    */   routes:[       &#123;           path: &#x27;/user/:id&#x27;,name: &#x27;user&#x27;,component: User       &#125;   ]\n\n[3.创建router实例]：\n// main.js    const router=new VueRouter(&#123;        routes,//(缩写)相当于 routes: routes        linkActiveClass: &#x27;active&#x27;// 链接激活时默认使用的css类名，用到linkActiveClass来配置，在路由的构造选项里配置默认类名为active    &#125;)\n\n[4.创建和挂载根实例]：记得要通过 router 配置参数注入路由，从而让整个应用都有路由功能\nwindow.onload=function()&#123;    new Vue(&#123;        el:`#my`,【        router    &#125;)&#125;\n\n设置路由导航的两种方式声明式 \n\n编程式router.push(‘&#x2F;home’)\n声明式的常见方式&lt;router-link :to=&quot;/home&quot;&gt;home&lt;/router-link&gt;&lt;!-- 对象 --&gt;&lt;router-link :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt;home&lt;/router-link&gt;&lt;!-- 路由通过名称 --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;homename&#x27;&#125;&quot;&gt;home&lt;/router-link&gt;&lt;!-- 直接路由带查询 --&gt;&lt;!-- 参数query，地址栏变成/home?id=10 --&gt;&lt;router-link :to=&quot;&#123;    path:&#x27;/home&#x27;,    query:&#123;id:10&#125;    &#125;&quot;&gt;    home&lt;/router-link&gt;&lt;!-- 命名路由带参查询query，地址栏变成/home?id=10 --&gt;&lt;router-link :to=&quot;&#123;    name:&#x27;homename&#x27;,    query:&#123;id:10&#125;    &#125;&quot;&gt;    home&lt;/router-link&gt;\n\n编程式常见方法\n字符串 router.push(‘&#x2F;home’)\n对象 router.push({path:’&#x2F;home’})\n路由通过名称 router.push({name:’homename’})\n直接路由带查询参数query,地址栏变成&#x2F;home?id&#x3D;10\n\nrouter.push(    &#123;        path:&#x27;home&#x27;,        query:&#123;id:10&#125;    &#125;)\n\n\n命名路由带查询query，地址栏变成&#x2F;home?id&#x3D;10\n\nrouter.push(    &#123;name:&#x27;homename&#x27;,    query:&#123;id:10&#125;&#125;)\n\n路由传参传入参数的方式方法1例：http://localhost:8080/user/10user\n\n路由配置const routes=[    &#123;path: &#x27;/home&#x27;, component: Home&#125;,    &#123;path: &#x27;/news&#x27;, component: News&#125;,     &#123;path: &#x27;/user/:id&#x27;, component: User&#125;,     //路由中定义http://localhost:8080/#/user/10 需要定义ID]\n\n方法2例：http://localhost:8080/home?id=10传入参数的方式：\n&lt;router-link :to=&quot;&#123;    path:&#x27;/home&#x27;,    query: &#123;id: id&#125;&#125;&quot;&gt;test&lt;/router-link&gt;\n\n路由中定义：user?id&#x3D;10 不需要在路由配置中定义参数\n常见路由对象在使用vue-router的应用中，路由对象会被注入每个组件中，赋值为this.$route，并且当路由切换时，路由对象会被更新，路由对象暴露了以下属性\n监听单个对象,默认开启深度监听\n扩展(AntV G6)[https://antv-g6.gitee.io/zh]AntV G6是一个图可视化引擎。它提供了图的绘制、布局、分析、交互、动画等基础能力。指让关系变得透明，简单。让用户获得关系数据的Insight(了解)。\n(AntV F6)[https://f6.antv.vision/zh]AntV F6是一个图视化引擎。可以去使用在H5、小程序等平台上，跟G6差不多一个pc一个移动端而已。\n","categories":["vue"],"tags":["面试题"]},{"title":"vue3 学习","url":"/2022/10/20/vue3/","content":"vue3简介\n\n2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）\n耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者\ngithub上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0\n\nVue3带来了什么1.性能的提升\n打包大小减少41%\n\n初次渲染快55%, 更新渲染快133%\n\n内存减少54%\n…\n\n\n2.源码的升级\n使用Proxy代替defineProperty实现响应式\n\n重写虚拟DOM的实现和Tree-Shaking\n…\n\n\n3.拥抱TypeScript\nVue3可以更好的支持TypeScript\n\n4.新的特性\nComposition API（组合API）\nsetup配置\nref与reactive\nwatch与watchEffect\nprovide与inject\n…\n\n\n新的内置组件\nFragment\nTeleport\nSuspense\n\n\n其他改变\n新的生命周期钩子\ndata 选项应始终被声明为一个函数\n移除keyCode支持作为 v-on 的修饰符\n…\n\n\n\n创建vue3项目## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue3_study## 启动cd vue3_studynpm run serve\n\nOptions API的弊端在Vue2中，我们编写组件的方式是 OptionsAPI：\nOptions API的一大特点就是在对应的属性中编写对应的功能模块；\n比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子；\n但是这种代码有一个很大的弊端：\n当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；\n当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散；\n尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）；\n下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分：\n这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题；\n并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；\n\n\n如果我们能将同一个逻辑关注 点相关的代码收集在一起会更好。\n这就是Composition API想要做的事情，以及可以帮助我 们完成的事情。\n也有人把Vue Composition API简称为VCA。\n认识Composition API那么既然知道Composition API想要帮助我们做什么事情，接下来看一下到底是怎么做呢？\n为了开始使用Composition API，我们需要有一个可以实际使用它（编写代码）的地方；\n在Vue组件中，这个位置就是 setup 函数；\nsetup其实就是组件的另外一个选项：\n只不过这个选项强大到我们可以用它来替代之前所编写的大部分其他选项；\n比如methods、computed、watch、data、生命周期等等；\n接下来我们一起学习这个函数的使用：\n函数的参数\n函数的返回值\nsetup函数的参数我们先来研究一个setup函数的参数，它主要有两个参数：\n第一个参数：props\n第二个参数：context\nprops非常好理解，它其实就是父组件传递过来的属性会被放到props对象中，我们在setup中如果需要使用，那么就可以直接通过props参数获取：\n对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义；\n并且在template中依然是可以正常去使用props中的属性，比如message；\n如果我们在setup函数中想要使用props，那么不可以通过 this 去获取（后面我会讲到为什么）；\n因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用即可；\n另外一个参数是context，我们也称之为是一个SetupContext，它里面包含三个属性：\nattrs：所有的非prop的attribute；\nslots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）；\nemit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）；\nsetup函数的返回值setup函数的两种返回值：\n\n若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）\n若返回一个渲染函数：则可以自定义渲染内容。（了解）\n\n注意点：\n\n尽量不要与Vue2.x配置混用\nVue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。\n但在setup中不能访问到Vue2.x配置（data、methos、computed…）。\n如果有重名, setup优先。\n\n\nsetup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）\n\n另外注意：setup不可以使用this\n官方关于this有这样一段描述\n表达的含义是this并没有指向当前组件实例；\n并且在setup被调用之前，data、computed、methods等都没有被解析；\n所以无法在setup中获取this；\n\n其实在之前的这段描述是和源码有出入的：\n之前的描述大概含义是不可以使用this是因为组件实例还没有被创建出来；\n通过阅读源码发现，代码是按照如下顺序执行的：\n调用 createComponentInstance 创建组件实 例；\n调用 setupComponent 初始化component内 部的操作；\n调用 setupStatefulComponent 初始化有状态的组件；\n在 setupStatefulComponent 取出了 setup 函 数；\n通过callWithErrorHandling 的函数执行 setup；\n从上面的代码我们可以看出， 组件的instance肯定是在执行setup函数之前就创建出来了。\n\nreactive函数\n作用: 定义一个对象类型的响应式数据（基本类型不要用它，控制台会报警告，要用ref函数）\n语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象）\nreactive定义的响应式数据是“深层次的”。\n内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n\n为什么就可以变成响应式的呢？\n这是因为当我们使用reactive函数处理我们的数据之后，数据再次被使用时就会进行依赖收集；\n当数据发生改变时，所有收集到的依赖都是进行对应的响应式操作（比如更新界面）；\n事实上，我们编写的data选项，也是在内部交给了reactive函数将其变成响应式对象的；\nref函数\n作用: 定义一个响应式的数据\n\n语法:\nconst xxx = ref(initValue)\n\n\n创建一个包含响应式数据的引用对象（reference对象，简称ref对象）, 其内部的值是在ref.value属性中被维护的 。\nJS中操作数据： xxx.value\n模板中读取数据: vue自动帮我们进行解包操作，不需要.value，直接：&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;\n\n\n备注：\n\n接收的数据可以是：基本类型、也可以是对象类型。\n基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。\n对象类型的数据：内部 求助 了Vue3.0中的一个新函数—— reactive函数。\n\n\n\ntoRefs如果我们使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后无论是修改解构后的变量，还是修改reactive返回的state对象，数据都不再是响应式的：\n\n那么有没有办法让我们解构出来的属性是响应式的呢？\nVue为我们提供了一个toRefs的函数，可以将reactive返回的对象中的属性都转成ref；\n那么我们再次进行结构出来的 name 和 age 本身都是 ref的；\n\n这种做法相当于已经在state.name和ref.value之间建立了 链接，任何一个修改都会引起另外一个变化；\ntoRef如果我们只希望转换一个reactive对象中的属性为ref, 那么可以使用toRef的方法\n\n应用: 要将响应式对象中的某个属性单独提供给外部使用时。\nref的其它APIunref如果我们想要获取一个ref引用中的value，那么也可以通过unref方法：\n如果参数是一个 ref，则返回内部值，否则返回参数本身；\n这是 val &#x3D; isRef(val) ? val.value : val 的语法糖函数；\nisRef判断值是否是一个ref对象。\nshallowRef创建一个浅层的ref对象；\ntriggerRef手动触发和 shallowRef 相关联的副作用\n\nshallowRef\nshallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n什么时候使用?\n如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。\n如果有一个对象数据，后续功能不会修改该对象中的属性，而是产生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。\n\n\n\ncustomRef创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制：\n它需要一个工厂函数，该函数接受 track 和 trigger 函数作为参数；\n并且应该返回一个带有 get 和 set 的对象；\n这里我们使用一个的案例：\n对双向绑定的属性进行debounce(节流)的操作；\n&lt;template&gt;\t&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;\t&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;\timport &#123;ref,customRef&#125; from &#x27;vue&#x27;\texport default &#123;\t\tname:&#x27;Demo&#x27;,\t\tsetup()&#123;\t\t\t// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref\t\t\t//自定义一个myRef\t\t\tfunction myRef(value,delay)&#123;\t\t\t\tlet timer\t\t\t\t//通过customRef去实现自定义\t\t\t\treturn customRef((track,trigger)=&gt;&#123;\t\t\t\t\treturn&#123;\t\t\t\t\t\tget()&#123;\t\t\t\t\t\t\ttrack() //告诉Vue这个value值是需要被“追踪”的\t\t\t\t\t\t\treturn value\t\t\t\t\t\t&#125;,\t\t\t\t\t\tset(newValue)&#123;\t\t\t\t\t\t\tclearTimeout(timer)\t\t\t\t\t\t\ttimer = setTimeout(()=&gt;&#123;\t\t\t\t\t\t\t\tvalue = newValue\t\t\t\t\t\t\t\ttrigger() //告诉Vue去更新界面\t\t\t\t\t\t\t&#125;,delay)\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;\t\t\tlet keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref\t\t\treturn &#123;\t\t\t\tkeyword\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;\n\n响应式原理vue2// vue2.x 双向数据绑定原理是通过Objcet.defineProperty来实现的// 这种方式有缺点: 数组的长度 数组的内容发生变化检测不到let obj = &#123;  name: &#x27;zs&#x27;,  age: 18,  phone: &#123;    name: &#x27;iphone&#x27;  &#125;&#125;// let obj = [1, 2, 3, 4, 5]// 视图更新的方法function render() &#123;  console.log(&#x27;视图更新了 ~&#x27;);&#125;let methods = [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;, &#x27;splice&#x27;]// 将数组的原型保存一份let arrProto = Array.prototype// 创建原型 将数组原型拷贝一份let proto = Object.create(arrProto)// 重写数组的方法methods.forEach(method =&gt; &#123;  proto[method] = function () &#123; // AOP 面向切面编程    // 改变了数组的数据    arrProto[method].call(this, ...arguments)    // 重新渲染视图    render()  &#125;&#125;)// 观察者模式 function observe(obj) &#123;  // 判断一个对象是不是数组  // if(Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;)&#123;  if (Array.isArray(obj)) &#123;    // 让观测的对象的原型和我们自己重写的原型建立关系    obj.__proto__ = proto    return;  &#125;  // 如果观察的是一个对象的话 对其属性进行响应式监听(set、get)  if (Object.prototype.toString.call(obj) === &#x27;[object Object]&#x27;) &#123;    // 取出对象中的每一个键和值    for (let key in obj) &#123;      // 调用响应式处理函数      defineReactive(obj, key, obj[key])    &#125;  &#125;&#125;// 观察obj对象observe(obj)// 响应式处理// Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。function defineReactive(obj, key, val) &#123;  // 检测对象的属性值是否还是对象  observe(val)  Object.defineProperty(obj, key, &#123;    // 获取    get() &#123;      return val    &#125;,    // 设置    set(newVal) &#123;      // 检测设置的值是不是对象      observe(newVal)      // 新值和旧值不相等的时候      if (newVal !== val) &#123;        // 覆盖掉原来的val值        val = newVal        // 通知render函数重新渲染视图        render()      &#125;    &#125;  &#125;)&#125;// obj.name = &#x27;lisi&#x27;// obj.age = 20// console.log(obj.name, obj.age);// 至此 基本可以实现数据发生变化 视图更新的效果// 但是 如果数据有多层呢 也就是属性对应的值也是对象?// obj.phone.name = &#x27;huawei&#x27;// console.log(obj.phone.name);// 修改的值和原来的值一样 不需要重新渲染视图// obj.phone.name = &#x27;iphone&#x27;// 如果重新为对象obj的phone赋值一个新的对象呢? 视图要重新渲染// obj.phone = &#123;name: &#x27;huawei&#x27;&#125;// 并且当修改新的对象的属性值时 视图也要重新渲染// obj.phone.name = &#x27;zs&#x27;// 为对象新增属性值呢? 也是没有办法监测到的// obj.sex = &#x27;man&#x27;// $set来解决这个function $myset(obj, key, val)&#123;  if(Array.isArray(obj))&#123;    return obj.splice(key, val)  &#125;  defineReactive(obj, key, val)&#125;// $myset(obj, &#x27;sex&#x27;, &#x27;man&#x27;)// 修改新增的属性值 视图也能更新// obj.sex = &#x27;woman&#x27;// obj.phone = Object.assign(obj.phone, &#123;price: &#x27;666&#x27;&#125;)// obj.phone.price = 888// obj.phone = &#123;...obj.phone, ...&#123;price: &#x27;666&#x27;&#125;&#125;// obj.phone.price = &#x27;888&#x27;// 以后vue涉及到给data中的对象新增属性时 有三种方式// 1、this.$set() || Vue.set()// 2、obj = Object.assign(原对象, 新对象(新增的属性:值))// 2、obj = &#123;...原对象, ...新对象(新增的属性:值)&#125;// =================== 数组 ======================// 数组的响应式数据处理依赖的并不是Object.defineProperty 而是对数组的能够引起数据变化的方法进行重写// obj.push(6)// obj.length ++ // obj[0] = 88// $myset(obj, &#x27;0&#x27;, 66)\n\nvue3// vue3响应式原理利用了es6提供的proxy Api// 可以直接监听到对象和数组内容及长度的变化// 缺点: 兼容性差 支持就用proxy 不支持就用Objcet.definePropertylet obj = &#123;  name: &#x27;zs&#x27;,  girlFriend: &#123; name: &#x27;刘亦菲&#x27; &#125;,  arr: [1, 2, 3]&#125;function render() &#123;  console.log(&#x27;视图重新渲染 ~&#x27;);&#125;let handler = &#123;  get(target, key) &#123;    // Reflect.get(target, propertyKey[, receiver])    // 获取对象身上某个属性的值，类似于 target[name]。    // 如果属性的值是一个对象的话 则重新进行代理 设置set&amp;get    if(typeof target[key] == &#x27;object&#x27; &amp;&amp; target[key] != null)&#123;      return new Proxy(target[key], handler)    &#125;    return Reflect.get(target, key)  &#125;,  set(target, key, val) &#123;    // if(target[key] == &#x27;length&#x27;) return true    Reflect.set(target, key, val)    render()    // return true表示赋值成功 如果不返回true 在严格模式下可能会报TypeError    return true  &#125;&#125;let proxy = new Proxy(obj, handler)// 使用代理后的对象// console.log(proxy.name);// console.log(proxy.grilFriend);// proxy.name = &#x27;lisi&#x27;// 修改深层次的对象的属性 无法监听到// proxy.grilFriend.name = &#x27;黄圣依&#x27;// console.log(proxy.name);// console.log(proxy.grilFriend);// console.log(obj.name);// console.log(obj.grilFriend);proxy.arr[0] = &#x27;11&#x27;proxy.arr.length ++// console.log(proxy.arr.length);console.log(obj.arr.length);\n\nref &amp; reactive\n从定义数据角度对比：\nref用来定义：基本类型数据。\nreactive用来定义：对象（或数组）类型数据。\n备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。\n\n\n从原理角度对比：\nref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。\nreactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。\n\n\n从使用角度对比：\nref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\nreactive定义的数据：操作数据与读取数据：均不需要.value。\n\n\n\nreadonly我们通过reactive或者ref可以获取到一个响应式的对象，但是某些情况下，我们传入给其他地方（组件）**的这个 响应式对象希望**在另外一个地方（组件）被使用**，但是不能被修改，这个时候如何防止这种情况的出现**呢？\nVue3为我们提供了readonly的方法；\nreadonly会返回原生对象的只读代理（也就是它依然是一个Proxy，这是一个proxy的set方法被劫持，并且不 能对其进行修改）；\n在开发中常见的readonly方法会传入三个类型的参数：\n类型一：普通对象；\n类型二：reactive返回的对象；\n类型三：ref的对象；\n在readonly的使用过程中，有如下规则：\nreadonly返回的对象都是不允许修改的；\n但是经过readonly处理的原来的对象是允许被修改的；\n比如 const info &#x3D; readonly(obj)，info对象是不允许被修改的；\n当obj被修改时，readonly返回的info对象也会被修改；\n但是我们不能去修改readonly返回的对象info；\n其实本质上就是readonly返回的对象的setter方法被劫持了而已；\n应用场景：在我们传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用readonly了；\nreactive 判断的APIisProxy检查对象是否是由 reactive 或 readonly创建的 proxy。\nisReactive检查对象是否是由 reactive创建的响应式代理：\n如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true；\nisReadonly检查对象是否是由 readonly 创建的只读代理。\ntoRaw返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）。\nshallowReactive创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)。\nshallowReadonly创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）。\n只处理对象最外层属性的响应式（浅响应式）。\n深度监听存在的问题： 如果数据量比较大，非常消耗性能。 有些时候我们并不需要对数据进行深度监听。 这个时候就没有必要使用ref和reactive\n其它 Composition APItoRaw &amp; markRaw\ntoRaw：\n作用：将一个由reactive生成的响应式对象转为普通对象。\n使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\n\n\nmarkRaw：\n作用：标记一个对象，使其永远不会再成为响应式对象。\n应用场景:\n有些值不应被设置为响应式的，例如复杂的第三方类库等。\n当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\n\n\n\n\n&lt;template&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;h3&gt;&#123;&#123; oldObj &#125;&#125;&lt;/h3&gt;    &lt;button @click=&quot;changeInfo&quot;&gt;修改&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; toRaw, reactive, markRaw &#125; from &quot;vue&quot;;export default &#123;  setup() &#123;        // let obj = reactive(&#123;    //   name: &#x27;zs&#x27;    // &#125;)        // 获取 reactive 或 readonly 代理的原始对象    // let oldObj = toRaw(obj)    // console.log(oldObj);    // ======= markRaw ========    let obj = &#123;      name: &#x27;zs&#x27;    &#125;    // 标记一个对象，使其永远不会再成为响应式对象。    let oldObj = markRaw(obj)    console.log(oldObj);    // 设置响应式失效    oldObj = reactive(oldObj)    function changeInfo()&#123;      oldObj.name = &#x27;lisi&#x27;      // 数据发生变化 =&gt; 视图没有更新      console.log(oldObj.name );    &#125;        return &#123;      oldObj,      changeInfo    &#125;  &#125;&#125;&lt;/script&gt;\n\nprovide 与 inject\n\n作用：实现祖与后代组件间通信\n\n套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n具体写法：\n\n祖组件中：\nsetup()&#123;\t......    let car = reactive(&#123;name:&#x27;奔驰&#x27;,price:&#x27;40万&#x27;&#125;)    provide(&#x27;car&#x27;,car)    ......&#125;\n\n后代组件中：\nsetup(props,context)&#123;\t......    const car = inject(&#x27;car&#x27;)    return &#123;car&#125;\t......&#125;\n\n计算属性与监视computed&lt;template&gt;  &lt;div&gt;    姓名: &#123;&#123; fullName &#125;&#125;&lt;br&gt;    修改姓名: &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt;&lt;br&gt;    姓:&lt;input type=&quot;text&quot; v-model=&quot;stu.firstName&quot;&gt;&lt;br&gt;    名:&lt;input type=&quot;text&quot; v-model=&quot;stu.lastName&quot;&gt;&lt;br&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; reactive, computed &#125; from &#x27;vue&#x27;;export default &#123;  // vue2的computed简单写法  // computed: &#123;  //   fullName() &#123;  //     return this.stu.firstName + &#x27;-&#x27; + this.stu.lastName  //   &#125;  // &#125;,  // vue2的computed完整写法  // computed: &#123;  //   fullName: &#123;  //     get()&#123;  //       return this.stu.firstName + &#x27;-&#x27; + this.stu.lastName  //     &#125;,  //     set()&#123;  //       console.log(111);  //     &#125;  //   &#125;  // &#125;,   setup() &#123;    let stu = reactive(&#123;      firstName: &#x27;张&#x27;,      lastName: &#x27;三&#x27;    &#125;)    // vu3 computed 简写 =&gt; 修改报警告需要提供setter    // let fullName = computed(()=&gt;&#123;    //   return stu.firstName + &#x27;-&#x27; + stu.lastName    // &#125;)    // 挂载到stu上    // stu.fullName = computed(()=&gt;&#123;    //   return stu.firstName + &#x27;-&#x27; + stu.lastName    // &#125;)    // vue3 computed 完整写法 =&gt; 可读可写    let fullName = computed(&#123;      get() &#123;        return stu.firstName + &#x27;-&#x27; + stu.lastName      &#125;,      set(val)&#123;        let arr = val.split(&#x27;-&#x27;)        stu.firstName = arr[0]        stu.lastName = arr[1]      &#125;    &#125;)    return &#123;      stu,      fullName    &#125;  &#125;&#125;&lt;/script&gt;\n\nwatch\n与Vue2.x中watch配置功能一致\n两个小“坑”：\n监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。\n监视reactive定义的响应式数据中某个属性时：deep配置有效。\n\n\n\n//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据   若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！   若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive定义的对象中的某个属性，所以deep配置有效\n\n在前面的Options API中，我们可以通过watch选项来侦听data或者props的数据变化，当数据变化时执行某一些 操作。\n而在Composition API中，我们可以使用watchEffect和watch来完成响应式数据的侦听；\nwatchEffect用于自动收集响应式数据的依赖；\nwatch需要手动指定侦听的数据源；\nwatchEffect\nwatch的套路是：既要指明监视的属性，也要指明监视的回调。\nwatchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。watchEffect 是默认会执行一次。\nwatchEffect有点像computed：\n但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n\n\nwatchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123;    const x1 = sum.value    const x2 = person.age    console.log(&#x27;watchEffect配置的回调执行了&#x27;)&#125;)\n\nwatchEffect 停止侦听setup() &#123;    // ref定义的响应式数据    let num = ref(0)    let stu = reactive(&#123;      name: &#x27;zs&#x27;,      friend: &#123;        name: &#x27;lisi&#x27;      &#125;    &#125;)    let addNum = () =&gt; &#123;      ++num.value      if (num.value &gt; 5) &#123;        // 停止侦听        stop()      &#125;    &#125;    // 首先，watchEffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖；    // 其次，只有收集的依赖发生变化时，watchEffect传入的函数才会再次执行；    let stop = watchEffect((onInvalidate) =&gt; &#123;      // 没有所谓的深度监视      // console.log(num.value, stu.friend.name);      console.log(num.value);      onInvalidate(()=&gt;&#123;        console.log(&#x27;取消上一次请求~&#x27;);        clearTimeout(timeId)      &#125;)      const timeId = setTimeout(()=&gt;&#123;        console.log(&#x27;发起请求~&#x27;);      &#125;, 2000)    &#125;)    return &#123;      num,      addNum,      ...toRefs(stu)    &#125;  &#125;\n\nwatchEffect 清除副作用什么是清除副作用呢？\n比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器， 或者侦听器侦听函数被再次执行了。\n那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用；\n在我们给watchEffect传入的函数被回调时，其实可以获取到一个参数：onInvalidate\n当副作用即将重新执行 或者 侦听器被停止 时会执行该函数传入的回调函数；\n我们可以在传入的回调函数中，执行一些清除工作；\n代码参上\n\nsetup中使用ref在讲解 watchEffect执行时机之前，我们先补充一个知识：在setup中如何使用ref获取元素或者组件？\n其实非常简单，我们只需要定义一个ref对象，绑定到元素或者组件的ref属性上即可；\n&lt;template&gt;  &lt;div&gt;    &lt;h3 ref=&quot;title&quot;&gt;&lt;/h3&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;;export default &#123;  setup() &#123;    // vue2中的ref是用来获取dom元素或者组件实例的    // vue3中没有 this 获取不到    // console.log(this.$refs.title);    let title = ref(null)    watchEffect(()=&gt; &#123;      console.log(title.value);    &#125;, &#123;      flush: &#x27;post&#x27;    &#125;)    return &#123;        title    &#125;  &#125;&#125;&lt;/script&gt;\n\nwatchEffect的执行时机默认情况下，组件的更新会在副作用函数执行之前：\n如果我们希望在副作用函数中获取到元素，是否可行呢？\n如上代码我们会发现打印结果打印了两次：\n这是因为setup函数在执行时就会立即执行传入的副作用函数，这个时候DOM并没有挂载，所以打印为null；\n而当DOM挂载时，会给title的ref对象赋值新的值，副作用函数会再次执行，打印出来对应的元素；\n调整watchEffect的执行时机如果我们希望在第一次的时候就打印出来对应的元素呢？\n这个时候我们需要改变副作用函数的执行时机；\n它的默认值是pre，它会在元素 挂载 或者 更新 之前执行；\n所以我们会先打印出来一个空的，当依赖的title发生改变时，就会再次执行一次，打印出元素；\nflush 选项还接受 sync，这将强制效果始终同步触发。然而，这是低效的，应该很少需要。\nwatch函数\n与Vue2.x中watch配置功能一致\n\n两个小“坑”：\n\n监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。\n监视reactive定义的响应式数据中某个属性时：deep配置有效。\n\n与watchEffect的比较，watch允许我们：\n懒执行副作用（第一次不会直接执行）；\n更具体的说明当哪些状态发生变化时，触发侦听器的执行；\n访问侦听状态变化前后的值；\n//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据   若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！   若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;\tconsole.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive定义的对象中的某个属性，所以deep配置有效\n\n生命周期函数\nVue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：\nbeforeDestroy改名为 beforeUnmount\ndestroyed改名为 unmounted\n\n\nVue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：\nbeforeCreate&#x3D;&#x3D;&#x3D;&gt;setup()\ncreated&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;setup()\nbeforeMount &#x3D;&#x3D;&#x3D;&gt;onBeforeMount\nmounted&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onMounted\nbeforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdate\nupdated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUpdated\nbeforeUnmount &#x3D;&#x3D;&gt;onBeforeUnmount\nunmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUnmounted\n\n\n\n\n自定义hook函数\n什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。\n类似于vue2.x中的mixin。\n自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。\n\nuseCounter\nimport &#123;ref, computed&#125; from &#x27;vue&#x27;export default function () &#123;  let count = ref(0)  const increment = () =&gt; &#123;    count.value ++   &#125;  const decrement = () =&gt; &#123;    count.value --   &#125;  const doubleCount = computed(()=&gt;&#123;    return count.value * 2  &#125;)  return &#123;    count,    doubleCount,    increment,    decrement  &#125;&#125;\n\nuseTitle\nimport &#123;ref, reactive, watch&#125; from &#x27;vue&#x27;export default function(title=&#x27;默认title&#x27;)&#123;  let titleRef = ref(title)  watch(titleRef, ()=&gt;&#123;    document.title = titleRef.value  &#125;)  return titleRef&#125;\n\nApp.vue\n&lt;template&gt;  &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;  &lt;p&gt;&#123;&#123; doubleCount &#125;&#125;&lt;/p&gt;  &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;  &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import useCounter from &#x27;./hooks/useCounter&#x27;import useTitle from &#x27;./hooks/useTitle&#x27;import &#123; toRefs, reactive &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    let counter = reactive(useCounter())    useTitle().value = &#x27;使用hooks&#x27;    return &#123;      ...toRefs(counter)    &#125;  &#125;&#125;&lt;/script&gt;\n\nsetup的顶层编写方式\n博客：https://blog.csdn.net/weixin_43931876/article/details/120058286\n官网：https://v3.cn.vuejs.org/api/sfc-spec.html#script-setup\n\n新的组件Fragment\n在Vue2中: 组件必须有一个根标签\n在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中\n好处: 减少标签层级, 减小内存占用\n\nTeleport\n什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术\nApp.vue\n&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    App组件    &lt;Father&gt;&lt;/Father&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Father from &#x27;./components/Father.vue&#x27;export default &#123;  components: &#123;    Father,  &#125;,  setup() &#123;  &#125;&#125;&lt;/script&gt;&lt;style&gt;.app &#123;  padding: 40px;  background-color: hotpink;&#125;&lt;/style&gt;\n\nFather.vue\n&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    Father组件    &lt;Son&gt;&lt;/Son&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son from &#x27;./Son.vue&#x27;export default &#123;  components: &#123;    Son  &#125;,  setup(props) &#123;  &#125;&#125;&lt;/script&gt;&lt;style&gt;.father &#123;  padding: 40px;  background-color: skyblue;&#125;&lt;/style&gt;\n\nSon.vue\n&lt;template&gt;  &lt;div class=&quot;son&quot;&gt;    Son组件    &lt;button @click=&quot;isShow = true&quot;&gt;显示弹窗&lt;/button&gt;    &lt;teleport to=&quot;body&quot;&gt;      &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;        &lt;div class=&quot;dialog&quot;&gt;          &lt;h3&gt;我是一个弹窗&lt;/h3&gt;          &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/teleport&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    let isShow = ref(false)    return &#123;      isShow    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.son &#123;  padding: 40px;  background-color: yellow;&#125;body &#123;  position: relative;&#125;.dialog &#123;  width: 300px;  height: 300px;  position: absolute;  left: 50%;  top: 50%;  transform: translate(-50%, -50%);  background-color: azure;  text-align: center;&#125;.mask &#123;  width: 100%;  height: 100%;  background: rgba(0, 0, 0, .5);&#125;&lt;/style&gt;\n\nSuspense\n等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n使用步骤：\nApp.vue\n&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    App组件    &lt;Suspense&gt;      &lt;template v-slot:default&gt;        &lt;Father&gt;&lt;/Father&gt;      &lt;/template&gt;      &lt;template v-slot:fallback&gt;        &lt;h3&gt;精彩内容正在加载中 ...&lt;/h3&gt;      &lt;/template&gt;    &lt;/Suspense&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 静态加载 同步// import Father from &#x27;./components/Father.vue&#x27;// 异步加载import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const Father = defineAsyncComponent(()=&gt;import(&#x27;./components/Father.vue&#x27;))export default &#123;  components: &#123;    Father,  &#125;,  setup() &#123;  &#125;,  &#125;&lt;/script&gt;&lt;style&gt;.app &#123;  padding: 40px;  background-color: hotpink;&#125;&lt;/style&gt;\n\nFather.vue\n&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    Father组件    &#123;&#123; num &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123;  async setup(props) &#123;    let num = ref(0)    // return new Promise((resolve, rejects)=&gt; &#123;    //   setTimeout(function()&#123;    //     resolve(&#123;num&#125;)    //   &#125;, 3000)    // &#125;)    let res = await new Promise((resolve, rejects) =&gt; &#123;      setTimeout(function () &#123;        resolve(&#123; num &#125;)      &#125;, 3000)    &#125;)    return res  &#125;&#125;&lt;/script&gt;&lt;style&gt;.father &#123;  padding: 40px;  background-color: skyblue;&#125;&lt;/style&gt;\n\n其它全局API的转移Vue 2.x 有许多全局 API 和配置。\n\n例如：注册全局组件、注册全局指令等。\n\n//注册全局组件Vue.component(&#x27;MyButton&#x27;, &#123;  data: () =&gt; (&#123;    count: 0  &#125;),  template: &#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;&#125;)//注册全局指令Vue.directive(&#x27;focus&#x27;, &#123;  inserted: el =&gt; el.focus()&#125;\n\nVue3.0中对这些API做出了调整：\n\n将全局的API，即：Vue.xxx调整到应用实例（app）上\n\n\n\n2.x 全局 API（Vue）\n3.x 实例 API (app)\n\n\n\nVue.config.xxxx\napp.config.xxxx\n\n\nVue.config.productionTip\n移除\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use\n\n\nVue.prototype\napp.config.globalProperties\n\n\n\n\n其它改变\ndata选项应始终被声明为一个函数。\n\n过度类名的更改：\n\nVue2.x写法\n.v-enter,.v-leave-to &#123;  opacity: 0;&#125;.v-leave,.v-enter-to &#123;  opacity: 1;&#125;\n\nVue3.x写法\n.v-enter-from,.v-leave-to &#123;  opacity: 0;&#125;.v-leave-from,.v-enter-to &#123;  opacity: 1;&#125;\n\n\n移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes\n\n移除v-on.native修饰符\n\n父组件中绑定事件\n&lt;my-component  v-on:close=&quot;handleComponentEvent&quot;  v-on:click=&quot;handleNativeClickEvent&quot;/&gt;\n\n子组件中声明自定义事件\n&lt;script&gt;  export default &#123;    emits: [&#x27;close&#x27;]  &#125;&lt;/script&gt;\n\n\n移除过滤器（filter）\n\n过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。\n\n\n…\n\n\nh函数Vue推荐在绝大数情况下使用模板来创建你的HTML，然而一些特殊的场景，你真的需要Javascript的完全编程的能力，这个时候你可以使用渲染函数 ，它比模板更接近编译器；\n前面我们讲解过VNode和VDOM的改变：\nVue在生成真实的DOM之前，会将我们的节点转换成VNode，而VNode组合在一起形成一颗树结构，就是虚拟DOM（VDOM）；\n事实上，我们之前编写的 template 中的HTML 最终也是使用渲染函数生成对应的VNode；\n那么，如果你想充分的利用JavaScript的编程能力，我们可以自己来编写 createVNode 函数，生成对应的 VNode；\n那么我们应该怎么来做呢？使用h()函数\nh() 函数是一个用于创建 vnode 的一个函数；\n其实更准确的命名是 createVNode() 函数，但是为了简便在Vue将之简化为 h() 函数；\n如何使用？\n注意事项：\n如果没有props，那么通常可以将children作为第二个参数传入；\n如果会产生歧义，可以将null作为第二个参数传入，将children作为第三个参数传入；\n&lt;script&gt;import &#123; h &#125; from &#x27;vue&#x27;export default&#123;  render()&#123;    return h(&#x27;h4&#x27;, &#123;class: &#x27;title&#x27;&#125;, &quot;hello h函数&quot;)  &#125;&#125;&lt;/script&gt;\n\n实现计数器&lt;script&gt;import &#123; h, ref &#125; from &#x27;vue&#x27;export default &#123;  // data()&#123;  //   return &#123;  //     count: 0  //   &#125;  // &#125;,  setup() &#123;    let count = ref(0)    // return &#123; count &#125;    return () =&gt; &#123;      return h(&#x27;div&#x27;, &#123; class: &#x27;counter&#x27; &#125;, [        h(&#x27;h4&#x27;, null, `当前计数为:$&#123;count.value&#125;`),        h(&#x27;button&#x27;, &#123;          onClick: () =&gt; count.value++        &#125;, &#x27;++&#x27;),        h(&#x27;button&#x27;, &#123;          onClick: () =&gt; count.value--        &#125;, &#x27;--&#x27;)      ])    &#125;  &#125;,  // render()&#123;  //   return h(&#x27;div&#x27;, &#123;class: &#x27;counter&#x27;&#125;, [  //     h(&#x27;h4&#x27;, null, `当前计数为:$&#123;this.count&#125;`),  //     h(&#x27;button&#x27;, &#123;  //       onClick: () =&gt; this.count ++  //     &#125;, &#x27;++&#x27;),  //     h(&#x27;button&#x27;, &#123;  //       onClick: () =&gt; this.count --  //     &#125;, &#x27;--&#x27;)  //   ])  // &#125;&#125;&lt;/script&gt;\n\n渲染插槽\n先了解下插槽的用法，可参照setup顶层编写方式内的博客网址\n\nApp.vue\n&lt;script&gt;import &#123; h &#125; from &#x27;vue&#x27;import Hi from &#x27;./05-Hi&#x27;export default &#123;  setup() &#123;    return () =&gt; &#123;      return h(Hi, null, &#123;        default: props =&gt; h(&#x27;h4&#x27;, null, `05-render函数渲染插槽$&#123;props.title&#125;`)      &#125;)    &#125;  &#125;,&#125;&lt;/script&gt;\n\nHi.vue\n&lt;script&gt;import &#123; h &#125; from &#x27;vue&#x27;  export default &#123;    render() &#123;      return h(&#x27;h4&#x27;, &#123;class: &#x27;title&#x27;&#125;, [        h(&#x27;h2&#x27;,null, &quot;hi ~~&quot;),        this.$slots.default ?         this.$slots.default(&#123;title: &quot;--本手俗手妙手无从下手&quot;&#125;) : h(&#x27;span&#x27;, null, &#x27;Hi组件默认插槽内容&#x27;)      ])    &#125;  &#125;&lt;/script&gt;\n\njsx如果我们希望在项目中使用jsx，那么我们需要添加对jsx的支持：\njsx我们通常会通过Babel来进行转换（React编写的jsx就是通过babel转换的）；\n对于Vue来说，我们只需要在Babel中配置对应的插件即可；\n安装Babel支持Vue的jsx插件：\nnpm install @vue/babel-plugin-jsx -D\n\n在babel.config.js配置文件中配置插件（现在好像不需要配置了）\nmodule.exports = &#123;  presets: [    &#x27;@vue/cli-plugin-babel/preset&#x27;  ],  plugins: [    &quot;@vue/babel-plugin-jsx&quot;  ]&#125;\n\n实现计数器&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123;  data() &#123;    return &#123;      count: 0    &#125;  &#125;,  render() &#123;    const increment = () =&gt; this.count++    const decrement = () =&gt; this.count--    return (      &lt;div&gt;        &lt;h4&gt;当前计数: &#123;this.count&#125;&lt;/h4&gt;        &lt;button onClick=&#123;increment&#125;&gt;++&lt;/button&gt;        &lt;button onClick=&#123;decrement&#125;&gt;--&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;&lt;/script&gt;\n\n组件使用Hi.vue\n&lt;script&gt;export default &#123;  render(h) &#123;    return (      &lt;div&gt;        &lt;h3&gt;Hi组件&lt;/h3&gt;        &#123;this.$slots.default ? this.$slots.default() : &lt;span&gt;哇咔咔&lt;/span&gt;&#125;      &lt;/div&gt;    )  &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\nApp.vue\n&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;import Hi from &#x27;./06-Hi.vue&#x27;export default &#123;  data() &#123;    return &#123;      count: 0    &#125;  &#125;,  render() &#123;    const increment = () =&gt; this.count++    const decrement = () =&gt; this.count--    return (      &lt;div&gt;        &lt;h4&gt;当前计数: &#123;this.count&#125;&lt;/h4&gt;        &lt;button onClick=&#123;increment&#125;&gt;++&lt;/button&gt;        &lt;button onClick=&#123;decrement&#125;&gt;--&lt;/button&gt;        &lt;Hi&gt;          &#123;&#123;default: props =&gt; &lt;button&gt;我是按钮&lt;/button&gt;&#125;&#125;        &lt;/Hi&gt;      &lt;/div&gt;    )  &#125;&#125;&lt;/script&gt;\n\nsetup写法\n&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;import Hi from &#x27;./06-Hi.vue&#x27;export default &#123;  setup() &#123;    let count = ref(0)    const increment = () =&gt; count.value++    const decrement = () =&gt; count.value--    const getVal = (num) =&gt; &#123;      console.log(num)      // vue3需要使用高阶函数来获取到e      return (e)=&gt; &#123;          console.log(e.target.checked)      &#125;    &#125;    return ()=&gt; &#123;      return (        &lt;div&gt;          &lt;input type=&quot;checkbox&quot; checked onChange=&#123; getVal(1) &#125;/&gt;          &lt;h4&gt;当前计数: &#123;count.value&#125;&lt;/h4&gt;          &lt;button onClick=&#123;increment&#125;&gt;++&lt;/button&gt;          &lt;button onClick=&#123;decrement&#125;&gt;--&lt;/button&gt;        &lt;/div&gt;      )    &#125;  &#125;&lt;/script&gt;\n\n自定义指令在Vue的模板语法中我们学习过各种各样的指令：v-show、v-for、v-model等等，除了使用这些指令之外，Vue也允许我们来自定义自己的指令\n注意：在Vue中，代码的复用和抽象主要还是通过组件；\n通常在某些情况下，你需要对DOM元素进行底层操作，这个时候就会用到自定义指令；\n自定义指令分为两种：\n自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用；\n自定义全局指令：app的 directive 方法，可以在任意组件中被使用；\n比如我们来做一个非常简单的案例：当某个元素挂载完成后可以自定获取焦点\n实现方式一：如果我们使用默认的实现方式；\n实现方式二：自定义一个 v-focus 的局部指令；\n实现方式三：自定义一个 v-focus 的全局指令；\n聚焦实现&lt;template&gt;  &lt;input type=&quot;text&quot; ref=&quot;iptRef&quot; v-focus&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, nextTick, onMounted, directives &#125; from &#x27;vue&#x27;export default &#123;  // directives选项  // directives: &#123;  //   focus: &#123;  //     // 指令的生命周期 不是 vue3的生命周期  //     mounted(el) &#123;  //       el.focus()  //     &#125;,  //   &#125;  // &#125;,  setup() &#123;    const iptRef = ref(null)    // nextTick(()=&gt;&#123;    //   iptRef.value.focus()    // &#125;)    // onMounted(()=&gt; &#123;    //   iptRef.value.focus()    // &#125;)    return &#123;      iptRef    &#125;  &#125;&#125;&lt;/script&gt;\n\n局部自定义指令自定义一个 v-focus 的局部指令\n这个自定义指令实现非常简单，我们只需要在组件选项中使用 directives 即可；\n它是一个对象，在对象中编写我们自定义指令的名称（注意：这里不需要加v-）；\n自定义指令有一个生命周期，是在组件挂载后调用的 mounted，我们可以在其中完成操作；\n&lt;template&gt;  &lt;input type=&quot;text&quot; ref=&quot;iptRef&quot; v-focus&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, directives &#125; from &#x27;vue&#x27;export default &#123;  // directives选项  directives: &#123;    focus: &#123;      // 指令的生命周期 不是 vue3的生命周期      mounted(el) &#123;        el.focus()      &#125;,    &#125;  &#125;,&#125;&lt;/script&gt;\n\n全局自定义指令// 全局自定义指令 =&gt; 放在mount之前app.directive(&quot;focus&quot;, &#123;  mounted(el) &#123;    el.focus()  &#125;&#125;)\n\n指令的生命周期一个指令定义的对象，Vue提供了如下的几个钩子函数：\ncreated：在绑定元素的 attribute 或事件监听器被应用之前调用；\nbeforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用；\nmounted：在绑定元素的父组件被挂载后调用；\nbeforeUpdate：在更新包含组件的 VNode 之前调用；\nupdated：在包含组件的 VNode 及其子组件的 VNode 更新后调用；\nbeforeUnmount：在卸载绑定元素的父组件之前调用；\nunmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次；\n指令的参数和修饰符如果我们指令需要接受一些参数或者修饰符应该如何操作呢？\ninfo是参数的名称；\naaa-bbb是修饰符的名称；\n后面是传入的具体的值；\n在我们的生命周期中，我们可以通过 bindings 获取到对应的内容：\n&lt;template&gt;  &lt;input type=&quot;text&quot; v-myDir.aaa.bbb=&quot;&#123;name:&#x27;zs&#x27;&#125;&quot; v-if=&quot;count &lt; 5&quot;&gt;  &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt;  &lt;button @click=&quot;increment&quot;&gt;++&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, directives &#125; from &#x27;vue&#x27;export default &#123;  directives: &#123;    myDir: &#123;      created() &#123;        console.log(&#x27;created&#x27;)      &#125;,      beforeMount() &#123;        console.log(&#x27;beforeMount&#x27;)      &#125;,      mounted(el, binding) &#123;        console.log(binding)      &#125;,      beforeUpdate() &#123;        console.log(&#x27;beforeUpdate&#x27;)      &#125;,      updated() &#123;        console.log(&#x27;updated&#x27;)      &#125;,      beforeUnmount() &#123;        console.log(&#x27;beforeUnmount&#x27;)      &#125;,      unmounted() &#123;        console.log(&#x27;unmounted&#x27;)      &#125;,    &#125;  &#125;,  setup() &#123;    let count = ref(0)    const increment = ()=&gt; &#123;      count.value ++    &#125;    return &#123;      count,      increment    &#125;  &#125;&#125;&lt;/script&gt;\n\n自定义指令练习自定义指令案例：时间戳的显示需求：\n在开发中，大多数情况下从服务器获取到的都是时间戳；\n我们需要将时间戳转换成具体格式化的时间来展示；\n在Vue2中我们可以通过过滤器来完成；\n在Vue3中我们可以通过 计算属性（computed） 或者 自定义一个方法（methods） 来完成；\n其实我们还可以通过一个自定义的指令来完成；\n我们来实现一个可以自动对时间格式化的指令v-format-time：\n这里我封装了一个函数，在首页中我们只需要调用这个函数并且传入app即可；\nformat-time.js\nimport dayjs from &#x27;dayjs&#x27;export default (app) =&gt; &#123;  // 挂载全局自定义指令  app.directive(&#x27;format-time&#x27;, &#123;    mounted(el, binding) &#123;      // 获取到用户指定的格式      let formatStr = binding.value      // 如果用户没有传格式      if(!binding.value)&#123;        // 给个默认的格式        formatStr = &#x27;YYYY-MM-DD hh:mm:ss&#x27;      &#125;      // 拿到组件标签上的时间戳      let timeStamp = el.textContent      if(timeStamp.length == 10)&#123;        // 秒 =&gt; 毫秒        timeStamp = timeStamp * 1000      &#125;      el.textContent = dayjs(parseInt(timeStamp)).format(formatStr)    &#125;,  &#125;)&#125;// main.js 引入自定义指令 import &#123; formatTime &#125; from &#x27;./directives&#x27;formatTime(app)\n\nTime.vue\n&lt;template&gt;  &lt;h3 v-format-time=&quot;&#x27;YYYY/MM/DD&#x27;&quot; &gt; 1654766827786 &lt;/h3&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    let count = ref(0)    const increment = ()=&gt; &#123;      count.value ++    &#125;    return &#123;      count,      increment    &#125;  &#125;&#125;&lt;/script&gt;\n\nplugins通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式：\n对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行；\n函数类型：一个function，这个函数会在安装插件时自动执行；\n插件可以完成的功能没有限制，比如下面的几种都是可以的：\n添加全局方法或者 property，通过把它们添加到 config.globalProperties 上实现；\n添加全局资源：指令&#x2F;过滤器&#x2F;过渡等；\n通过全局 mixin 来添加一些组件选项；\n一个库，提供自己的 API，同时提供上面提到的一个或多个功能；\nApp.vue\n&lt;template&gt;  &lt;h3&gt;哥们 你这睡眠质量不行呀 我一般都8小时后才发现&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;export default &#123;  // mounted()&#123;  //   console.log(this.$msg)  // &#125;  setup()&#123;    // console.log(this.$msg)    // setup中没有this指向 所以不能像vue2获取原型上的数据    // 需要按照下面的方式    let instance = getCurrentInstance()    console.log(instance.appContext.config.globalProperties.$msg)  &#125;&#125;&lt;/script&gt;// main.js引入插件import msgPluginObject from &#x27;./plugins/msgPlugin-object&#x27;import msgPluginFunction from &#x27;./plugins/msgPlugin-function&#x27;// 使用插件// app.use(msgPluginObject)// use相当于 msgPlugin.install(app)app.use(msgPluginFunction)\n\n函数写法export default (app) =&gt; &#123;  app.config.globalProperties.$msg = &quot;听说高考数学卷很难 刚刚试了下 两小时后才发现试卷拿反了&quot;&#125;\n\n对象写法export default &#123;  install(app)&#123;    // 往app原型上添加属性    app.config.globalProperties.$msg = &quot;听说高考数学卷很难 刚刚试了下 两小时后才发现试卷拿反了&quot;  &#125;&#125;\n\n路由待更新 ~\nVuex待更新 ~\nPiniaVuex 作为一个老牌 Vue 状态管理库，大家都很熟悉了\nPinia 是 Vue.js 团队成员专门为 Vue 开发的一个全新的状态管理库，并且已经被纳入官方 github\n为什么有 Vuex 了还要再开发一个 Pinia ？\n先来一张图，看下当时对于** Vuex5 的提案**，就是下一代 Vuex5 应该是什么样子的\n\nPinia 就是完整的符合了他当时 Vuex5 提案所提到的功能点，所以可以说 Pinia 就是 Vuex5 也不为过，因为它的作者就是官方的开发人员，并且已经被官方接管了，只是目前 Vuex 和 Pinia 还是两个独立的仓库，以后可能会合并，也可能独立发展，只是官方肯定推荐的是 Pinia\n因为在 Vue3 中使用 Vuex 的话需要使用 Vuex4，并且还只能作为一个过渡的选择，存在很大缺陷，所以在 Componsition API 诞生之后，也就设计了全新的状态管理 Pinia\nPinia 特性\nPinia 没有 Mutations\nActions 支持同步和异步\n没有模块的嵌套结构\n\nPinia 通过设计提供扁平结构，就是说每个 store 都是互相独立的，谁也不属于谁，也就是扁平化了，更好的代码分割且没有命名空间。当然你也可以通过在一个模块中导入另一个模块来隐式嵌套 store，甚至可以拥有 store 的循环依赖关系\n\n\n更好的 TypeScript 支持\n\n不需要再创建自定义的复杂包装器来支持 TypeScript 所有内容都类型化，并且 API 的设计方式也尽可能的使用 TS 类型推断\n\n\n不需要注入、导入函数、调用它们，享受自动补全，让我们开发更加方便\n无需手动添加 store，它的模块默认情况下创建就自动注册的\nVue2 和 Vue3 都支持\n\n除了初始化安装和SSR配置之外，两者使用上的API都是相同的\n\n\n支持 Vue DevTools\n\n跟踪 actions, mutations 的时间线\n在使用了模块的组件中就可以观察到模块本身\n支持 time-travel 更容易调试\n在 Vue2 中 Pinia 会使用 Vuex 的所有接口，所以它俩不能一起使用\n但是针对 Vue3 的调试工具支持还不够完美，比如还没有 time-travel 功能\n\n\n模块热更新\n\n无需重新加载页面就可以修改模块\n热更新的时候会保持任何现有状态\n\n\n支持使用插件扩展 Pinia 功能\n支持服务端渲染\n\nPinia 和 Vuex上面的也算 ~\n核心区别\nVuex： State、Gettes、Mutations(同步)、Actions(异步)\nPinia： State、Gettes、Actions(同步异步都支持)\n版本支持\nVuex 当前最新版是 4.x\n\nVuex4 用于 Vue3\nVuex3 用于 Vue2\n\nPinia 当前最新版是 2.x\n\n即支持 Vue2 也支持 Vue3\n\n使用场景个人感觉：，由于Pinea是轻量级的，体积很小，它适合于中小型应用。它也适用于低复杂度的Vue.js项目，因为一些调试功能，如时间旅行和编辑仍然不被支持。将 Vuex 用于中小型 Vue.js 项目是过度的，因为它重量级的，对性能降低有很大影响。因此，Vuex 适用于大规模、高复杂度的 Vue.js 项目\npinia使用准备工作想要学习pinia，最好有Vue3的基础，明白组合式API是什么。如果你还不会Vue3，建议先去学习Vue3。\n本篇全部基于Vue3来讲解pinia，至于Vue2中如何使用pinia，大家可以自行去pinia官网学习，毕竟Vue2中使用pinia的还是少数。\n项目搭建我们这里搭建一个最新的Vue3 + TS + Vite项目。\n执行命令：vue create vue-pinia 选择babel、vue3、ts，创建完毕，清空项目，启动项目 ~\n安装pinia执行命令：npm install pinia\n使用pinia安装完成后我们需要将pinia挂载到Vue应用中，也就是我们需要创建一个根存储传递给应用程序，简单来说就是创建一个存储数据的数据桶，放到应用程序中去。\n修改main.js，引入pinia提供的createPinia方法，创建根存储。\n// main.tsimport &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &#123; createPinia &#125; from &quot;pinia&quot;;const pinia = createPinia();const app = createApp(App);app.use(pinia);app.mount(&quot;#app&quot;);\n\n在 store 目录下创建一个 user.ts 为例，我们先定义并导出一个名为 user 的模块\nimport &#123; defineStore &#125; from &#x27;pinia&#x27;export const userStore = defineStore(&#x27;user&#x27;, &#123;    state: () =&gt; &#123;        return &#123;             count: 1,            arr: []        &#125;    &#125;,    getters: &#123; ... &#125;,    actions: &#123; ... &#125;&#125;)\n\ndefineStore 接收两个参数\n第一个参数就是模块的名称，必须是唯一的，多个模块不能重名，Pinia 会把所有的模块都挂载到根容器上第二个参数是一个对象，里面的选项和 Vuex 差不多\n\n其中 state 用来存储全局状态，它必须是箭头函数，为了在服务端渲染的时候避免交叉请求导致的数据状态污染所以只能是函数，而必须用箭头函数则为了更好的 TS 类型推导\ngetters 就是用来封装计算属性，它有缓存的功能\nactions 就是用来封装业务逻辑，修改 state\n\n访问 state比如我们要在页面中访问 state 里的属性 count\n由于 defineStore 会返回一个函数，所以要先调用拿到数据对象，然后就可以在模板中直接使用了\n&lt;template&gt;    &lt;div&gt;&#123;&#123; user_store.count &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; userStore &#125; from &#x27;../store&#x27;const user_store = userStore()// 解构// const &#123; count &#125; = userStore()&lt;/script&gt;\n\n比如像注释中的解构出来使用，是完全没有问题的，只是注意了，这样拿到的数据不是响应式的，如果要解构还保持响应式就要用到一个方法 storeToRefs()，示例如下\n&lt;template&gt;    &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;import &#123; userStore &#125; from &#x27;../store&#x27;const &#123; count &#125; = storeToRefs(userStore)&lt;/script&gt;\n\n原因就是 Pinia 其实是把 state 数据都做了 reactive 处理，和 Vue3 的 reactive 同理，解构出来的也不是响应式，所以需要再做 ref 响应式代理\ngetters这个和 Vuex 的 getters 一样，也有缓存功能。如下在页面中多次使用，第一次会调用 getters，数据没有改变的情况下之后会读取缓存\n&lt;template&gt;    &lt;div&gt;&#123;&#123; myCount &#125;&#125;&lt;/div&gt;    &lt;div&gt;&#123;&#123; myCount &#125;&#125;&lt;/div&gt;    &lt;div&gt;&#123;&#123; myCount &#125;&#125;&lt;/div&gt;&lt;/template&gt;\n\n注意两种方法的区别，写在注释里了\ngetters: &#123;    // 方法一，接收一个可选参数 state    myCount(state)&#123;        console.log(&#x27;调用了&#x27;) // 页面中使用了三次，这里只会执行一次，然后缓存起来了        return state.count + 1    &#125;,    // 方法二，不传参数，使用 this    // 但是必须指定函数返回值的类型，否则类型推导不出来    myCount(): number&#123;        return this.count + 1    &#125;&#125;\n\nactions更新 state 里的数据有四种方法，我们先看三种简单的更新，说明都写在注释里了\n&lt;template&gt;    &lt;div&gt;&#123;&#123; user_store.count &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;handleClick&quot;&gt;按钮&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; userStore &#125; from &#x27;../store&#x27;const user_store = userStore()const handleClick = () =&gt; &#123;    // 方法一    user_store.count++        // 方法二，需要修改多个数据，建议用 $patch 批量更新，传入一个对象    user_store.$patch(&#123;        count: user_store.count1++,        // arr: user_store.arr.push(1) // 错误        arr: [ ...user_store.arr, 1 ] // 可以，但是还得把整个数组都拿出来解构，就没必要    &#125;)        // 使用 $patch 性能更优，因为多个数据更新只会更新一次视图        // 方法三，还是$patch，传入函数，第一个参数就是 state    user_store.$patch( state =&gt; &#123;        state.count++        state.arr.push(1)    &#125;)&#125;&lt;/script&gt;\n\n第四种方法就是当逻辑比较多或者请求的时候，我们就可以封装到示例中 store&#x2F;user.ts 里的 actions 里\n可以传参数，也可以通过 this.xx 可以直接获取到 state 里的数据，需要注意的是不能用箭头函数定义 actions，不然就会绑定外部的 this 了\nactions: &#123;    changeState(num: number)&#123; // 不能用箭头函数        this.count += num    &#125;&#125;\n\n调用\nconst handleClick = () =&gt; &#123;    user_store.changeState(1)&#125;\n\n支持 VueDevtools打开开发者工具的 Vue Devtools 就会发现 Pinia，而且可以手动修改数据调试，非常方便\n模拟调用接口示例：\n我们先定义示例接口 api&#x2F;user.ts\n// 接口数据类型export interface userListType&#123;    id: number    name: string    age: number&#125;// 模拟请求接口返回的数据const userList = [    &#123; id: 1, name: &#x27;张三&#x27;, age: 18 &#125;,    &#123; id: 2, name: &#x27;李四&#x27;, age: 19 &#125;,]// 封装模拟异步效果的定时器async function wait(delay: number)&#123;    return new Promise((resolve) =&gt; setTimeout(resolve, delay))&#125;// 接口export const getUserList = async () =&gt; &#123;    await wait(100) // 延迟100毫秒返回    return userList&#125;\n\n然后在 store&#x2F;user.ts 里的 actions 封装调用接口\nimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; getUserList, userListType &#125; from &#x27;../api/user&#x27;export const userStore = defineStore(&#x27;user&#x27;, &#123;    state: () =&gt; &#123;        return &#123;            // 用户列表            list: [] as userListType // 类型转换成 userListType        &#125;    &#125;,    actions: &#123;         async loadUserList()&#123;            const list = await getUserList()            this.list = list        &#125;    &#125;&#125;)\n\n页面中调用 actions 发起请求\n&lt;template&gt;    &lt;ul&gt;        &lt;li v-for=&quot;item in user_store.list&quot;&gt; ... &lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; userStore &#125; from &#x27;../store&#x27;const user_store = userStore()user_store.loadUserList() // 加载所有数据&lt;/script&gt;\n\n跨模块修改数据在一个模块的 actions 里需要修改另一个模块的 state 数据\n示例：比如在 chat 模块里修改 user 模块里某个用户的名称\n// chat.tsimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; userStore &#125; from &#x27;./user&#x27;export const chatStore = defineStore(&#x27;chat&#x27;, &#123;    actions: &#123;         someMethod(userItem)&#123;            userItem.name = &#x27;新的名字&#x27;            const user_store = userStore()            user_store.updateUserName(userItem)        &#125;    &#125;&#125;)\n\nuser 模块里\n// user.tsimport &#123; defineStore &#125; from &#x27;pinia&#x27;export const userStore = defineStore(&#x27;user&#x27;, &#123;    state: () =&gt; &#123;        return &#123;            list: []        &#125;    &#125;,    actions: &#123;         updateUserName(userItem)&#123;            const user = this.list.find(item =&gt; item.id === userItem.id)            if(user)&#123;                user.name = userItem.name            &#125;        &#125;    &#125;&#125;)\n\n————————————— The End —————————————\n","categories":["vue"]}]