<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="vue3">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="刘小烨">
    
    <title>
        
            vue3 学习 |
        
        小刘博客
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/brands.min.css">
    
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-Hans","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true,"layout":"right"},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.svg","first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"黄色的森林分出两条路 || 我选择人迹更少的那一条，从此决定我一生的道路","hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":true,"preload":false},"code_block":{},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{},"post":{},"website_count":{},"version":"3.7.3"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container border-box">

    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               小刘博客
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">

                

                    <div class="fade-in-down-animation">
    <div class="post-page-container border-box">

        <div class="article-content-container border-box">

            <div class="article-title">
                <span class="title-hover-animation">vue3 学习</span>
            </div>

            
                <div class="article-header border-box">
                    
                        <div class="avatar-box border-box">
                            <img src="/images/avatar.svg">
                        </div>
                    
                    <div class="info-box">
                        <div class="author">
                            <span class="name">刘小烨</span>
                            
                        </div>
                        <div class="meta-info border-box">
                            

<div class="article-meta-info-container border-box post">
    <div class="article-meta-info border-box">
        


        
            <span class="meta-info-item article-create-date">
                <i class="icon fa-solid fa-calendar-check"></i>&nbsp;
                <span class="pc">2022-10-20 11:30:53</span>
                <span class="mobile">2022-10-20 11:30</span>
            </span>

            <span class="meta-info-item article-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="pc">2023-08-17 11:08:11</span>
            </span>
        

        
            <span class="meta-info-item article-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul>
                    
                            <li class="category-item">
                                
                                <a href="/%E6%A0%87%E7%AD%BE/vue/">vue</a>
                            </li>
                        
                    
                </ul>
            </span>
        

        
            <span class="article-tag meta-info-item border-box">
                <i class="icon fas fa-tags"></i>&nbsp;
                <ul>
                    
                </ul>
            </span>
        

        
        
        
        
    </div>

    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h4 id="vue3简介"><a href="#vue3简介" class="headerlink" title="vue3简介"></a>vue3简介</h4><p><img  
                     lazyload
                     alt="image"
                     data-src="/../vue3/image-20220729221023361.png"
                      alt="img"
                ></p>
<ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a class="link"   target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/graphs/commit-activity" >2600+次提交<i class="fas fa-external-link-alt"></i></a>、<a class="link"   target="_blank" rel="noopener" href="https://github.com/vuejs/rfcs/tree/master/active-rfcs" >30+个RFC<i class="fas fa-external-link-alt"></i></a>、<a class="link"   target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+" >600+次PR<i class="fas fa-external-link-alt"></i></a>、<a class="link"   target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/graphs/contributors" >99位贡献者<i class="fas fa-external-link-alt"></i></a></li>
<li>github上的tags地址：<a class="link"   target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0" >https://github.com/vuejs/vue-next/releases/tag/v3.0.0<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h4 id="Vue3带来了什么"><a href="#Vue3带来了什么" class="headerlink" title="Vue3带来了什么"></a>Vue3带来了什么</h4><h5 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h5><ul>
<li><p>打包大小减少41%</p>
</li>
<li><p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li><p>内存减少54%</p>
<p>…</p>
</li>
</ul>
<h5 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h5><ul>
<li><p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li><p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>…</p>
</li>
</ul>
<h5 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h5><ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h5 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h5><ol>
<li>Composition API（组合API）<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>…</li>
</ul>
</li>
<li>新的内置组件<ul>
<li>Fragment</li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li>其他改变<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>…</li>
</ul>
</li>
</ol>
<h4 id="创建vue3项目"><a href="#创建vue3项目" class="headerlink" title="创建vue3项目"></a>创建vue3项目</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上<br>vue --version<br>## 安装或者升级你的@vue/cli<br>npm install -g @vue/cli<br>## 创建<br>vue create vue3_study<br>## 启动<br>cd vue3_study<br>npm run serve<br></code></pre></td></tr></table></figure>

<h4 id="Options-API的弊端"><a href="#Options-API的弊端" class="headerlink" title="Options API的弊端"></a>Options API的弊端</h4><p>在Vue2中，我们编写组件的方式是 <strong>OptionsAPI</strong>：</p>
<p>Options API的一大特点就是在对应的属性中编写对应的功能模块；</p>
<p>比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子；</p>
<p><strong>但是这种代码有一个很大的弊端：</strong></p>
<p>当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；</p>
<p>当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散；</p>
<p>尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）；</p>
<p><strong>下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分：</strong></p>
<p>这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题；</p>
<p>并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；</p>
<!-- |          |          |
| -------- | -------- |
| ![img]() | ![img]() | -->

<p>如果我们能将同一个逻辑关注 点相关的代码收集在一起会更好。</p>
<p>这就是<strong>Composition API</strong>想要做的事情，以及可以帮助我 们完成的事情。</p>
<p>也有人把Vue Composition API简称为<strong>VCA</strong>。</p>
<h4 id="认识Composition-API"><a href="#认识Composition-API" class="headerlink" title="认识Composition API"></a>认识Composition API</h4><p>那么既然知道Composition API想要帮助我们做什么事情，接下来看一下<strong>到底是怎么做</strong>呢？</p>
<p>为了开始使用Composition API，我们需要有一个可以实际使用它（编写代码）的地方；</p>
<p>在Vue组件中，这个位置就是 setup 函数；</p>
<p><strong>setup</strong>其实就是组件的另外一个选项：</p>
<p>只不过这个选项强大到我们可以用它来替代之前所编写的大部分其他选项；</p>
<p>比如methods、computed、watch、data、生命周期等等；</p>
<p><strong>接下来我们一起学习这个函数的使用：</strong></p>
<p>函数的参数</p>
<p>函数的返回值</p>
<h5 id="setup函数的参数"><a href="#setup函数的参数" class="headerlink" title="setup函数的参数"></a>setup函数的参数</h5><p>我们先来研究一个setup函数的参数，它主要<strong>有两个参数</strong>：</p>
<p>第一个参数：props</p>
<p>第二个参数：context</p>
<p>props非常好理解，它其实就是<strong>父组件传递过来的属性</strong>会被放到props对象中，我们在<strong>setup中如果需要使用</strong>，那么就可以直接通过props参数获取：</p>
<p>对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义；</p>
<p>并且在template中依然是可以正常去使用props中的属性，比如message；</p>
<p>如果我们在setup函数中想要使用props，那么不可以通过 this 去获取（后面我会讲到为什么）；</p>
<p>因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用即可；</p>
<p>另外一个参数是<strong>context</strong>，我们也称之为是一个<strong>SetupContext</strong>，它里面<strong>包含三个属性</strong>：</p>
<p><strong>attrs</strong>：所有的非prop的attribute；</p>
<p><strong>slots</strong>：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）；</p>
<p><strong>emit</strong>：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）；</p>
<h5 id="setup函数的返回值"><a href="#setup函数的返回值" class="headerlink" title="setup函数的返回值"></a>setup函数的返回值</h5><p>setup函数的两种返回值：</p>
<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li>若返回一个渲染函数：则可以自定义渲染内容。（了解）</li>
</ol>
<p><strong>注意点：</strong></p>
<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed…）中<strong>可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong>不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
<p><strong>另外注意：setup不可以使用this</strong></p>
<p><strong>官方关于this有这样一段描述</strong></p>
<p>表达的含义是this并没有指向当前组件实例；</p>
<p>并且在setup被调用之前，data、computed、methods等都没有被解析；</p>
<p>所以无法在setup中获取this；</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/../vue3/image-20220731183326486.png"
                      alt="image-20220731183326486"
                ></p>
<p><strong>其实在之前的这段描述是和源码有出入的：</strong></p>
<p>之前的描述大概含义是不可以使用this是因为组件实例还没有被创建出来；</p>
<p>通过阅读源码发现，代码是按照如下顺序执行的：</p>
<p>调用 createComponentInstance 创建组件实 例；</p>
<p>调用 setupComponent 初始化component内 部的操作；</p>
<p>调用 setupStatefulComponent 初始化有状态的组件；</p>
<p>在 setupStatefulComponent 取出了 setup 函 数；</p>
<p>通过callWithErrorHandling 的函数执行 setup；</p>
<p>从上面的代码我们可以看出， <strong>组件的instance肯定是在执行setup函数之前就创建出来了</strong>。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/"
                      alt="image-20220731183456961"
                ></p>
<h4 id="reactive函数"><a href="#reactive函数" class="headerlink" title="reactive函数"></a>reactive函数</h4><ul>
<li>作用: 定义一个<strong>对象类型</strong>的响应式数据（基本类型不要用它，控制台会报警告，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong>代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<p><strong>为什么就可以变成响应式的呢？</strong></p>
<p>这是因为当我们使用reactive函数处理我们的数据之后，数据再次被使用时就会进行依赖收集；</p>
<p>当数据发生改变时，所有收集到的依赖都是进行对应的响应式操作（比如更新界面）；</p>
<p>事实上，我们编写的data选项，也是在内部交给了reactive函数将其变成响应式对象的；</p>
<h4 id="ref函数"><a href="#ref函数" class="headerlink" title="ref函数"></a>ref函数</h4><ul>
<li><p>作用: 定义一个响应式的数据</p>
</li>
<li><p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">const xxx = ref(initValue)<br></code></pre></td></tr></table></figure>

<ul>
<li>创建一个包含响应式数据的<strong>引用对象（reference对象，简称ref对象）, 其内部的值是在ref.value属性中被维护的</strong> 。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: vue自动帮我们进行解包操作，不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li>
</ul>
</li>
<li><p>备注：</p>
<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <strong>求助</strong> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h5 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h5><p>如果我们使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后无论是修改解构后的变量<strong>，还是</strong>修改reactive返回的state对象<strong>，</strong>数据都不再是响应式的：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/../vue3/image-20220801222944169.png"
                      alt="image-20220801222944169"
                ></p>
<p>那么有没有办法<strong>让我们解构出来的属性是响应式</strong>的呢？</p>
<p>Vue为我们提供了一个toRefs的函数，可以将reactive返回的对象中的属性都转成ref；</p>
<p>那么我们再次进行结构出来的 name 和 age 本身都是 ref的；</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/../vue3/image-20220801223009192.png"
                      alt="image-20220801223009192"
                ></p>
<p>这种做法相当于已经在state.name和ref.value之间建立了 链接，任何一个修改都会引起另外一个变化；</p>
<h5 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h5><p>如果我们只希望转换一个<strong>reactive</strong>对象中的属性为ref, 那么可以使用<strong>toRef</strong>的方法</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/../vue3/image-20220801223105290.png"
                      alt="image-20220801223105290"
                ></p>
<p>应用: 要将响应式对象中的某个属性单独提供给外部使用时。</p>
<h5 id="ref的其它API"><a href="#ref的其它API" class="headerlink" title="ref的其它API"></a>ref的其它API</h5><h6 id="unref"><a href="#unref" class="headerlink" title="unref"></a><strong>unref</strong></h6><p>如果我们想要<strong>获取一个ref引用中的value</strong>，那么也可以通过<strong>unref</strong>方法：</p>
<p>如果参数是一个 ref，则返回内部值，否则返回参数本身；</p>
<p>这是 val &#x3D; isRef(val) ? val.value : val 的语法糖函数；</p>
<h6 id="isRef"><a href="#isRef" class="headerlink" title="isRef"></a><strong>isRef</strong></h6><p>判断值是否是一个ref对象。</p>
<h6 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a><strong>shallowRef</strong></h6><p>创建一个浅层的ref对象；</p>
<h6 id="triggerRef"><a href="#triggerRef" class="headerlink" title="triggerRef"></a><strong>triggerRef</strong></h6><p>手动触发和 shallowRef 相关联的副作用</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/../vue3/image-20220801223301726.png"
                      alt="image-20220801223301726"
                ></p>
<h6 id="shallowRef-1"><a href="#shallowRef-1" class="headerlink" title="shallowRef"></a>shallowRef</h6><ul>
<li>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</li>
<li>什么时候使用?<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是产生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h6 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h6><p>创建一个<strong>自定义的ref</strong>，并<strong>对其依赖项跟踪和更新触发</strong>进行<strong>显示控制</strong>：</p>
<p>它需要一个工厂函数，该函数接受 track 和 trigger 函数作为参数；</p>
<p>并且应该返回一个带有 get 和 set 的对象；</p>
<p><strong>这里我们使用一个的案例：</strong></p>
<p>对双向绑定的属性进行debounce(节流)的操作；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;<br>	&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>	import &#123;ref,customRef&#125; from &#x27;vue&#x27;<br>	export default &#123;<br>		name:&#x27;Demo&#x27;,<br>		setup()&#123;<br>			// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref<br>			//自定义一个myRef<br>			function myRef(value,delay)&#123;<br>				let timer<br>				//通过customRef去实现自定义<br>				return customRef((track,trigger)=&gt;&#123;<br>					return&#123;<br>						get()&#123;<br>							track() //告诉Vue这个value值是需要被“追踪”的<br>							return value<br>						&#125;,<br>						set(newValue)&#123;<br>							clearTimeout(timer)<br>							timer = setTimeout(()=&gt;&#123;<br>								value = newValue<br>								trigger() //告诉Vue去更新界面<br>							&#125;,delay)<br>						&#125;<br>					&#125;<br>				&#125;)<br>			&#125;<br>			let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref<br>			return &#123;<br>				keyword<br>			&#125;<br>		&#125;<br>	&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><h5 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// vue2.x 双向数据绑定原理是通过Objcet.defineProperty来实现的<br>// 这种方式有缺点: 数组的长度 数组的内容发生变化检测不到<br><br>let obj = &#123;<br>  name: &#x27;zs&#x27;,<br>  age: 18,<br>  phone: &#123;<br>    name: &#x27;iphone&#x27;<br>  &#125;<br>&#125;<br>// let obj = [1, 2, 3, 4, 5]<br>// 视图更新的方法<br>function render() &#123;<br>  console.log(&#x27;视图更新了 ~&#x27;);<br>&#125;<br><br>let methods = [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;, &#x27;splice&#x27;]<br>// 将数组的原型保存一份<br>let arrProto = Array.prototype<br>// 创建原型 将数组原型拷贝一份<br>let proto = Object.create(arrProto)<br>// 重写数组的方法<br>methods.forEach(method =&gt; &#123;<br>  proto[method] = function () &#123; // AOP 面向切面编程<br>    // 改变了数组的数据<br>    arrProto[method].call(this, ...arguments)<br>    // 重新渲染视图<br>    render()<br>  &#125;<br>&#125;)<br><br>// 观察者模式 <br>function observe(obj) &#123;<br>  // 判断一个对象是不是数组<br>  // if(Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;)&#123;<br>  if (Array.isArray(obj)) &#123;<br>    // 让观测的对象的原型和我们自己重写的原型建立关系<br>    obj.__proto__ = proto<br>    return;<br>  &#125;<br>  // 如果观察的是一个对象的话 对其属性进行响应式监听(set、get)<br>  if (Object.prototype.toString.call(obj) === &#x27;[object Object]&#x27;) &#123;<br>    // 取出对象中的每一个键和值<br>    for (let key in obj) &#123;<br>      // 调用响应式处理函数<br>      defineReactive(obj, key, obj[key])<br>    &#125;<br>  &#125;<br>&#125;<br>// 观察obj对象<br>observe(obj)<br><br>// 响应式处理<br>// Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。<br>function defineReactive(obj, key, val) &#123;<br>  // 检测对象的属性值是否还是对象<br>  observe(val)<br>  Object.defineProperty(obj, key, &#123;<br>    // 获取<br>    get() &#123;<br>      return val<br>    &#125;,<br>    // 设置<br>    set(newVal) &#123;<br>      // 检测设置的值是不是对象<br>      observe(newVal)<br>      // 新值和旧值不相等的时候<br>      if (newVal !== val) &#123;<br>        // 覆盖掉原来的val值<br>        val = newVal<br>        // 通知render函数重新渲染视图<br>        render()<br>      &#125;<br>    &#125;<br>  &#125;)<br>&#125;<br><br>// obj.name = &#x27;lisi&#x27;<br>// obj.age = 20<br>// console.log(obj.name, obj.age);<br>// 至此 基本可以实现数据发生变化 视图更新的效果<br>// 但是 如果数据有多层呢 也就是属性对应的值也是对象?<br>// obj.phone.name = &#x27;huawei&#x27;<br>// console.log(obj.phone.name);<br><br>// 修改的值和原来的值一样 不需要重新渲染视图<br>// obj.phone.name = &#x27;iphone&#x27;<br><br>// 如果重新为对象obj的phone赋值一个新的对象呢? 视图要重新渲染<br>// obj.phone = &#123;name: &#x27;huawei&#x27;&#125;<br><br>// 并且当修改新的对象的属性值时 视图也要重新渲染<br>// obj.phone.name = &#x27;zs&#x27;<br><br>// 为对象新增属性值呢? 也是没有办法监测到的<br>// obj.sex = &#x27;man&#x27;<br>// $set来解决这个<br>function $myset(obj, key, val)&#123;<br>  if(Array.isArray(obj))&#123;<br>    return obj.splice(key, val)<br>  &#125;<br>  defineReactive(obj, key, val)<br>&#125;<br>// $myset(obj, &#x27;sex&#x27;, &#x27;man&#x27;)<br>// 修改新增的属性值 视图也能更新<br>// obj.sex = &#x27;woman&#x27;<br><br>// obj.phone = Object.assign(obj.phone, &#123;price: &#x27;666&#x27;&#125;)<br>// obj.phone.price = 888<br><br>// obj.phone = &#123;...obj.phone, ...&#123;price: &#x27;666&#x27;&#125;&#125;<br>// obj.phone.price = &#x27;888&#x27;<br>// 以后vue涉及到给data中的对象新增属性时 有三种方式<br>// 1、this.$set() || Vue.set()<br>// 2、obj = Object.assign(原对象, 新对象(新增的属性:值))<br>// 2、obj = &#123;...原对象, ...新对象(新增的属性:值)&#125;<br><br>// =================== 数组 ======================<br>// 数组的响应式数据处理依赖的并不是Object.defineProperty 而是对数组的能够引起数据变化的方法进行重写<br>// obj.push(6)<br>// obj.length ++ <br>// obj[0] = 88<br>// $myset(obj, &#x27;0&#x27;, 66)<br></code></pre></td></tr></table></figure>

<h5 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// vue3响应式原理利用了es6提供的proxy Api<br>// 可以直接监听到对象和数组内容及长度的变化<br>// 缺点: 兼容性差 支持就用proxy 不支持就用Objcet.defineProperty<br>let obj = &#123;<br>  name: &#x27;zs&#x27;,<br>  girlFriend: &#123; name: &#x27;刘亦菲&#x27; &#125;,<br>  arr: [1, 2, 3]<br>&#125;<br><br>function render() &#123;<br>  console.log(&#x27;视图重新渲染 ~&#x27;);<br>&#125;<br><br>let handler = &#123;<br>  get(target, key) &#123;<br>    // Reflect.get(target, propertyKey[, receiver])<br>    // 获取对象身上某个属性的值，类似于 target[name]。<br>    // 如果属性的值是一个对象的话 则重新进行代理 设置set&amp;get<br>    if(typeof target[key] == &#x27;object&#x27; &amp;&amp; target[key] != null)&#123;<br>      return new Proxy(target[key], handler)<br>    &#125;<br>    return Reflect.get(target, key)<br>  &#125;,<br>  set(target, key, val) &#123;<br>    // if(target[key] == &#x27;length&#x27;) return true<br>    Reflect.set(target, key, val)<br>    render()<br>    // return true表示赋值成功 如果不返回true 在严格模式下可能会报TypeError<br>    return true<br>  &#125;<br>&#125;<br><br>let proxy = new Proxy(obj, handler)<br>// 使用代理后的对象<br>// console.log(proxy.name);<br>// console.log(proxy.grilFriend);<br><br>// proxy.name = &#x27;lisi&#x27;<br>// 修改深层次的对象的属性 无法监听到<br>// proxy.grilFriend.name = &#x27;黄圣依&#x27;<br>// console.log(proxy.name);<br>// console.log(proxy.grilFriend);<br>// console.log(obj.name);<br>// console.log(obj.grilFriend);<br><br>proxy.arr[0] = &#x27;11&#x27;<br>proxy.arr.length ++<br>// console.log(proxy.arr.length);<br>console.log(obj.arr.length);<br></code></pre></td></tr></table></figure>

<h4 id="ref-amp-reactive"><a href="#ref-amp-reactive" class="headerlink" title="ref &amp; reactive"></a>ref &amp; reactive</h4><ul>
<li>从定义数据角度对比：<ul>
<li>ref用来定义：<strong>基本类型数据</strong>。</li>
<li>reactive用来定义：<strong>对象（或数组）类型数据</strong>。</li>
<li>备注：ref也可以用来定义<strong>对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong>代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<strong>Proxy</strong>来实现响应式（数据劫持）, 并通过<strong>Reflect</strong>操作<strong>源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li>ref定义的数据：操作数据<strong>需要</strong><code>.value</code>，读取数据时模板中直接读取<strong>不需要</strong><code>.value</code>。</li>
<li>reactive定义的数据：操作数据与读取数据：<strong>均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>我们通过<strong>reactive或者ref可以获取到一个响应式的对象</strong>，但是某些情况下，我们<strong>传入给其他地方（组件）**的这个 响应式对象希望**在另外一个地方（组件）被使用**，但是</strong>不能被修改<strong>，这个时候</strong>如何防止这种情况的出现**呢？</p>
<p>Vue3为我们提供了readonly的方法；</p>
<p>readonly会返回原生对象的只读代理（也就是它依然是一个Proxy，这是一个proxy的set方法被劫持，并且不 能对其进行修改）；</p>
<p><strong>在开发中常见的readonly方法会传入三个类型的参数：</strong></p>
<p>类型一：普通对象；</p>
<p>类型二：reactive返回的对象；</p>
<p>类型三：ref的对象；</p>
<p><strong>在readonly的使用过程中，有如下规则：</strong></p>
<p>readonly返回的对象都是不允许修改的；</p>
<p>但是经过readonly处理的原来的对象是允许被修改的；</p>
<p>比如 const info &#x3D; readonly(obj)，info对象是不允许被修改的；</p>
<p>当obj被修改时，readonly返回的info对象也会被修改；</p>
<p>但是我们不能去修改readonly返回的对象info；</p>
<p>其实本质上就是readonly返回的对象的setter方法被劫持了而已；</p>
<p><strong>应用场景</strong>：在我们传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用readonly了；</p>
<h4 id="reactive-判断的API"><a href="#reactive-判断的API" class="headerlink" title="reactive 判断的API"></a>reactive 判断的API</h4><h5 id="isProxy"><a href="#isProxy" class="headerlink" title="isProxy"></a><strong>isProxy</strong></h5><p>检查对象是否是由 reactive 或 readonly创建的 proxy。</p>
<h5 id="isReactive"><a href="#isReactive" class="headerlink" title="isReactive"></a><strong>isReactive</strong></h5><p>检查对象是否是由 reactive创建的响应式代理：</p>
<p>如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true；</p>
<h5 id="isReadonly"><a href="#isReadonly" class="headerlink" title="isReadonly"></a><strong>isReadonly</strong></h5><p>检查对象是否是由 readonly 创建的只读代理。</p>
<h5 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a><strong>toRaw</strong></h5><p>返回 reactive 或 readonly 代理的原始对象（<strong>不</strong>建议保留对原始对象的持久引用。请谨慎使用）。</p>
<h5 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a><strong>shallowReactive</strong></h5><p>创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)。</p>
<h5 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a><strong>shallowReadonly</strong></h5><p>创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）。</p>
<p>只处理对象最外层属性的响应式（浅响应式）。</p>
<p>深度监听存在的问题： 如果数据量比较大，非常消耗性能。 有些时候我们并不需要对数据进行深度监听。 这个时候就没有必要使用ref和reactive</p>
<h4 id="其它-Composition-API"><a href="#其它-Composition-API" class="headerlink" title="其它 Composition API"></a>其它 Composition API</h4><h5 id="toRaw-amp-markRaw"><a href="#toRaw-amp-markRaw" class="headerlink" title="toRaw &amp; markRaw"></a>toRaw &amp; markRaw</h5><ul>
<li>toRaw：<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong>响应式对象</strong>转为<strong>普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;div class=&quot;hello&quot;&gt;<br>    &lt;h3&gt;&#123;&#123; oldObj &#125;&#125;&lt;/h3&gt;<br>    &lt;button @click=&quot;changeInfo&quot;&gt;修改&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; toRaw, reactive, markRaw &#125; from &quot;vue&quot;;<br>export default &#123;<br>  setup() &#123;<br>    <br>    // let obj = reactive(&#123;<br>    //   name: &#x27;zs&#x27;<br>    // &#125;)<br>    <br>    // 获取 reactive 或 readonly 代理的原始对象<br>    // let oldObj = toRaw(obj)<br>    // console.log(oldObj);<br><br><br>    // ======= markRaw ========<br>    let obj = &#123;<br>      name: &#x27;zs&#x27;<br>    &#125;<br><br>    // 标记一个对象，使其永远不会再成为响应式对象。<br>    let oldObj = markRaw(obj)<br>    console.log(oldObj);<br><br>    // 设置响应式失效<br>    oldObj = reactive(oldObj)<br><br>    function changeInfo()&#123;<br>      oldObj.name = &#x27;lisi&#x27;<br>      // 数据发生变化 =&gt; 视图没有更新<br>      console.log(oldObj.name );<br>    &#125;<br>    <br>    return &#123;<br>      oldObj,<br>      changeInfo<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h5 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h5><p><img  
                     lazyload
                     alt="image"
                     data-src="/"
                      alt="image-20220801225915620"
                ></p>
<ul>
<li><p>作用：实现<strong>祖与后代组件间</strong>通信</p>
</li>
<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li><p>具体写法：</p>
</li>
<li><p>祖组件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">setup()&#123;<br>	......<br>    let car = reactive(&#123;name:&#x27;奔驰&#x27;,price:&#x27;40万&#x27;&#125;)<br>    provide(&#x27;car&#x27;,car)<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>后代组件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">setup(props,context)&#123;<br>	......<br>    const car = inject(&#x27;car&#x27;)<br>    return &#123;car&#125;<br>	......<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="计算属性与监视"><a href="#计算属性与监视" class="headerlink" title="计算属性与监视"></a>计算属性与监视</h4><h5 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;div&gt;<br>    姓名: &#123;&#123; fullName &#125;&#125;&lt;br&gt;<br>    修改姓名: &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt;&lt;br&gt;<br>    姓:&lt;input type=&quot;text&quot; v-model=&quot;stu.firstName&quot;&gt;&lt;br&gt;<br>    名:&lt;input type=&quot;text&quot; v-model=&quot;stu.lastName&quot;&gt;&lt;br&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; reactive, computed &#125; from &#x27;vue&#x27;;<br>export default &#123;<br>  // vue2的computed简单写法<br>  // computed: &#123;<br>  //   fullName() &#123;<br>  //     return this.stu.firstName + &#x27;-&#x27; + this.stu.lastName<br>  //   &#125;<br>  // &#125;,<br>  // vue2的computed完整写法<br>  // computed: &#123;<br>  //   fullName: &#123;<br>  //     get()&#123;<br>  //       return this.stu.firstName + &#x27;-&#x27; + this.stu.lastName<br>  //     &#125;,<br>  //     set()&#123;<br>  //       console.log(111);<br>  //     &#125;<br>  //   &#125;<br>  // &#125;, <br>  setup() &#123;<br>    let stu = reactive(&#123;<br>      firstName: &#x27;张&#x27;,<br>      lastName: &#x27;三&#x27;<br>    &#125;)<br>    // vu3 computed 简写 =&gt; 修改报警告需要提供setter<br>    // let fullName = computed(()=&gt;&#123;<br>    //   return stu.firstName + &#x27;-&#x27; + stu.lastName<br>    // &#125;)<br>    // 挂载到stu上<br>    // stu.fullName = computed(()=&gt;&#123;<br>    //   return stu.firstName + &#x27;-&#x27; + stu.lastName<br>    // &#125;)<br><br>    // vue3 computed 完整写法 =&gt; 可读可写<br>    let fullName = computed(&#123;<br>      get() &#123;<br>        return stu.firstName + &#x27;-&#x27; + stu.lastName<br>      &#125;,<br>      set(val)&#123;<br>        let arr = val.split(&#x27;-&#x27;)<br>        stu.firstName = arr[0]<br>        stu.lastName = arr[1]<br>      &#125;<br>    &#125;)<br>    return &#123;<br>      stu,<br>      fullName<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h5 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h5><ul>
<li>与Vue2.x中watch配置功能一致</li>
<li>两个小“坑”：<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//情况一：监视ref定义的响应式数据<br>watch(sum,(newValue,oldValue)=&gt;&#123;<br>	console.log(&#x27;sum变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true&#125;)<br><br>//情况二：监视多个ref定义的响应式数据<br>watch([sum,msg],(newValue,oldValue)=&gt;&#123;<br>	console.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)<br>&#125;) <br><br>/* 情况三：监视reactive定义的响应式数据<br>   若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！<br>   若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 <br>*/<br>watch(person,(newValue,oldValue)=&gt;&#123;<br>	console.log(&#x27;person变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效<br><br>//情况四：监视reactive定义的响应式数据中的某个属性<br>watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;<br>	console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true,deep:true&#125;) <br><br>//情况五：监视reactive定义的响应式数据中的某些属性<br>watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;<br>	console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true,deep:true&#125;)<br><br>//特殊情况<br>watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive定义的对象中的某个属性，所以deep配置有效<br></code></pre></td></tr></table></figure>

<p>在前面的Options API中，我们可以通过watch选项来侦听data或者props的数据变化，当数据变化时执行某一些 操作。</p>
<p>而在Composition API中，我们可以使用watchEffect和watch来完成响应式数据的侦听；</p>
<p>watchEffect用于自动收集响应式数据的依赖；</p>
<p>watch需要手动指定侦听的数据源；</p>
<h5 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h5><ul>
<li>watch的套路是：既要指明监视的属性，也要指明监视的回调。</li>
<li>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。watchEffect 是默认会执行一次。</li>
<li>watchEffect有点像computed：<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。<br>watchEffect(()=&gt;&#123;<br>    const x1 = sum.value<br>    const x2 = person.age<br>    console.log(&#x27;watchEffect配置的回调执行了&#x27;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h5 id="watchEffect-停止侦听"><a href="#watchEffect-停止侦听" class="headerlink" title="watchEffect 停止侦听"></a>watchEffect 停止侦听</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">setup() &#123;<br>    // ref定义的响应式数据<br>    let num = ref(0)<br>    let stu = reactive(&#123;<br>      name: &#x27;zs&#x27;,<br>      friend: &#123;<br>        name: &#x27;lisi&#x27;<br>      &#125;<br>    &#125;)<br>    let addNum = () =&gt; &#123;<br>      ++num.value<br>      if (num.value &gt; 5) &#123;<br>        // 停止侦听<br>        stop()<br>      &#125;<br>    &#125;<br>    // 首先，watchEffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖；<br>    // 其次，只有收集的依赖发生变化时，watchEffect传入的函数才会再次执行；<br>    let stop = watchEffect((onInvalidate) =&gt; &#123;<br>      // 没有所谓的深度监视<br>      // console.log(num.value, stu.friend.name);<br>      console.log(num.value);<br>      onInvalidate(()=&gt;&#123;<br>        console.log(&#x27;取消上一次请求~&#x27;);<br>        clearTimeout(timeId)<br>      &#125;)<br>      const timeId = setTimeout(()=&gt;&#123;<br>        console.log(&#x27;发起请求~&#x27;);<br>      &#125;, 2000)<br>    &#125;)<br>    return &#123;<br>      num,<br>      addNum,<br>      ...toRefs(stu)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h5 id="watchEffect-清除副作用"><a href="#watchEffect-清除副作用" class="headerlink" title="watchEffect 清除副作用"></a>watchEffect 清除副作用</h5><p>什么是清除副作用呢？</p>
<p>比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器， 或者侦听器侦听函数被再次执行了。</p>
<p>那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用；</p>
<p>在我们给watchEffect传入的函数被回调时，其实可以获取到一个参数：onInvalidate</p>
<p>当<strong>副作用即将重新执行</strong> 或者 <strong>侦听器被停止</strong> 时会执行该函数传入的回调函数；</p>
<p>我们可以在传入的回调函数中，执行一些清除工作；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">代码参上<br></code></pre></td></tr></table></figure>

<h5 id="setup中使用ref"><a href="#setup中使用ref" class="headerlink" title="setup中使用ref"></a>setup中使用ref</h5><p>在讲解 watchEffect执行时机之前，我们先补充一个知识：在setup中如何使用ref获取元素或者组件？</p>
<p>其实非常简单，我们只需要定义一个ref对象，绑定到元素或者组件的ref属性上即可；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h3 ref=&quot;title&quot;&gt;&lt;/h3&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;;<br>export default &#123;<br>  setup() &#123;<br>    // vue2中的ref是用来获取dom元素或者组件实例的<br>    // vue3中没有 this 获取不到<br>    // console.log(this.$refs.title);<br>    let title = ref(null)<br>    watchEffect(()=&gt; &#123;<br>      console.log(title.value);<br>    &#125;, &#123;<br>      flush: &#x27;post&#x27;<br>    &#125;)<br>    return &#123;  <br>      title<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h5 id="watchEffect的执行时机"><a href="#watchEffect的执行时机" class="headerlink" title="watchEffect的执行时机"></a>watchEffect的执行时机</h5><p>默认情况下，组件的更新会在副作用函数执行之前：</p>
<p>如果我们希望在副作用函数中获取到元素，是否可行呢？</p>
<p>如上代码我们会发现打印结果打印了两次：</p>
<p>这是因为setup函数在执行时就会立即执行传入的副作用函数，这个时候DOM并没有挂载，所以打印为null；</p>
<p>而当DOM挂载时，会给title的ref对象赋值新的值，副作用函数会再次执行，打印出来对应的元素；</p>
<h5 id="调整watchEffect的执行时机"><a href="#调整watchEffect的执行时机" class="headerlink" title="调整watchEffect的执行时机"></a>调整watchEffect的执行时机</h5><p>如果我们希望在第一次的时候就打印出来对应的元素呢？</p>
<p>这个时候我们需要改变副作用函数的执行时机；</p>
<p>它的默认值是pre，它会在元素 挂载 或者 更新 之前执行；</p>
<p>所以我们会先打印出来一个空的，当依赖的title发生改变时，就会再次执行一次，打印出元素；</p>
<p>flush 选项还接受 sync，这将强制效果始终同步触发。然而，这是低效的，应该很少需要。</p>
<h5 id="watch函数"><a href="#watch函数" class="headerlink" title="watch函数"></a>watch函数</h5><ul>
<li><p>与Vue2.x中watch配置功能一致</p>
</li>
<li><p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<p>与watchEffect的比较，watch允许我们：</p>
<p>懒执行副作用（第一次不会直接执行）；</p>
<p>更具体的说明当哪些状态发生变化时，触发侦听器的执行；</p>
<p>访问侦听状态变化前后的值；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//情况一：监视ref定义的响应式数据<br>watch(sum,(newValue,oldValue)=&gt;&#123;<br>	console.log(&#x27;sum变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true&#125;)<br><br>//情况二：监视多个ref定义的响应式数据<br>watch([sum,msg],(newValue,oldValue)=&gt;&#123;<br>	console.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)<br>&#125;) <br><br>/* 情况三：监视reactive定义的响应式数据<br>   若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！<br>   若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 <br>*/<br>watch(person,(newValue,oldValue)=&gt;&#123;<br>	console.log(&#x27;person变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效<br><br>//情况四：监视reactive定义的响应式数据中的某个属性<br>watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;<br>	console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true,deep:true&#125;) <br><br>//情况五：监视reactive定义的响应式数据中的某些属性<br>watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;<br>	console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true,deep:true&#125;)<br><br>//特殊情况<br>watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive定义的对象中的某个属性，所以deep配置有效<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h4><ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul>
<li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li>
<li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li>
<li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/../vue3/image-20220808210007522.png"
                      alt="image-20220808210007522"
                ></p>
<h4 id="自定义hook函数"><a href="#自定义hook函数" class="headerlink" title="自定义hook函数"></a>自定义hook函数</h4><ul>
<li>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</li>
<li>类似于vue2.x中的mixin。</li>
<li>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</li>
</ul>
<p><strong>useCounter</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import &#123;ref, computed&#125; from &#x27;vue&#x27;<br>export default function () &#123;<br>  let count = ref(0)<br>  const increment = () =&gt; &#123;<br>    count.value ++ <br>  &#125;<br>  const decrement = () =&gt; &#123;<br>    count.value -- <br>  &#125;<br>  const doubleCount = computed(()=&gt;&#123;<br>    return count.value * 2<br>  &#125;)<br><br>  return &#123;<br>    count,<br>    doubleCount,<br>    increment,<br>    decrement<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>useTitle</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import &#123;ref, reactive, watch&#125; from &#x27;vue&#x27;<br><br>export default function(title=&#x27;默认title&#x27;)&#123;<br>  let titleRef = ref(title)<br><br>  watch(titleRef, ()=&gt;&#123;<br>    document.title = titleRef.value<br>  &#125;)<br><br>  return titleRef<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>App.vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;<br>  &lt;p&gt;&#123;&#123; doubleCount &#125;&#125;&lt;/p&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;<br>  &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import useCounter from &#x27;./hooks/useCounter&#x27;<br>import useTitle from &#x27;./hooks/useTitle&#x27;<br>import &#123; toRefs, reactive &#125; from &#x27;vue&#x27;<br>export default &#123;<br>  setup() &#123;<br>    let counter = reactive(useCounter())<br>    useTitle().value = &#x27;使用hooks&#x27;<br>    return &#123;<br>      ...toRefs(counter)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h4 id="setup的顶层编写方式"><a href="#setup的顶层编写方式" class="headerlink" title="setup的顶层编写方式"></a>setup的顶层编写方式</h4><blockquote>
<p>博客：<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43931876/article/details/120058286" >https://blog.csdn.net/weixin_43931876/article/details/120058286<i class="fas fa-external-link-alt"></i></a></p>
<p>官网：<a class="link"   target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/sfc-spec.html#script-setup" >https://v3.cn.vuejs.org/api/sfc-spec.html#script-setup<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h4 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h4><h6 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h6><ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h6 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h6><ul>
<li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术</p>
<p><strong>App.vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;div class=&quot;app&quot;&gt;<br>    App组件<br>    &lt;Father&gt;&lt;/Father&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br><br>import Father from &#x27;./components/Father.vue&#x27;<br>export default &#123;<br>  components: &#123;<br>    Father,<br>  &#125;,<br>  setup() &#123;<br><br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>.app &#123;<br>  padding: 40px;<br>  background-color: hotpink;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>Father.vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;div class=&quot;father&quot;&gt;<br>    Father组件<br>    &lt;Son&gt;&lt;/Son&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import Son from &#x27;./Son.vue&#x27;<br>export default &#123;<br>  components: &#123;<br>    Son<br>  &#125;,<br>  setup(props) &#123;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>.father &#123;<br>  padding: 40px;<br>  background-color: skyblue;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>

<p><strong>Son.vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;div class=&quot;son&quot;&gt;<br>    Son组件<br>    &lt;button @click=&quot;isShow = true&quot;&gt;显示弹窗&lt;/button&gt;<br>    &lt;teleport to=&quot;body&quot;&gt;<br>      &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;<br>        &lt;div class=&quot;dialog&quot;&gt;<br>          &lt;h3&gt;我是一个弹窗&lt;/h3&gt;<br>          &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/teleport&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br>export default &#123;<br>  setup() &#123;<br>    let isShow = ref(false)<br>    return &#123;<br>      isShow<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br><br>&lt;style scoped&gt;<br>.son &#123;<br>  padding: 40px;<br>  background-color: yellow;<br>&#125;<br>body &#123;<br>  position: relative;<br>&#125;<br>.dialog &#123;<br>  width: 300px;<br>  height: 300px;<br>  position: absolute;<br>  left: 50%;<br>  top: 50%;<br>  transform: translate(-50%, -50%);<br>  background-color: azure;<br>  text-align: center;<br>&#125;<br>.mask &#123;<br>  width: 100%;<br>  height: 100%;<br>  background: rgba(0, 0, 0, .5);<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>

<h6 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h6><ul>
<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li><p>使用步骤：</p>
<p><strong>App.vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;div class=&quot;app&quot;&gt;<br>    App组件<br>    &lt;Suspense&gt;<br>      &lt;template v-slot:default&gt;<br>        &lt;Father&gt;&lt;/Father&gt;<br>      &lt;/template&gt;<br>      &lt;template v-slot:fallback&gt;<br>        &lt;h3&gt;精彩内容正在加载中 ...&lt;/h3&gt;<br>      &lt;/template&gt;<br>    &lt;/Suspense&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>// 静态加载 同步<br>// import Father from &#x27;./components/Father.vue&#x27;<br>// 异步加载<br>import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;<br>const Father = defineAsyncComponent(()=&gt;import(&#x27;./components/Father.vue&#x27;))<br>export default &#123;<br>  components: &#123;<br>    Father,<br>  &#125;,<br>  setup() &#123;<br><br>  &#125;,<br>  <br>&#125;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>.app &#123;<br>  padding: 40px;<br>  background-color: hotpink;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>

<p><strong>Father.vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;div class=&quot;father&quot;&gt;<br>    Father组件<br>    &#123;&#123; num &#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br>export default &#123;<br>  async setup(props) &#123;<br>    let num = ref(0)<br>    // return new Promise((resolve, rejects)=&gt; &#123;<br>    //   setTimeout(function()&#123;<br>    //     resolve(&#123;num&#125;)<br>    //   &#125;, 3000)<br>    // &#125;)<br>    let res = await new Promise((resolve, rejects) =&gt; &#123;<br>      setTimeout(function () &#123;<br>        resolve(&#123; num &#125;)<br>      &#125;, 3000)<br>    &#125;)<br>    return res<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>.father &#123;<br>  padding: 40px;<br>  background-color: skyblue;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><h5 id="全局API的转移"><a href="#全局API的转移" class="headerlink" title="全局API的转移"></a>全局API的转移</h5><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li>例如：注册全局组件、注册全局指令等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//注册全局组件<br>Vue.component(&#x27;MyButton&#x27;, &#123;<br>  data: () =&gt; (&#123;<br>    count: 0<br>  &#125;),<br>  template: &#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;<br>&#125;)<br><br>//注册全局指令<br>Vue.directive(&#x27;focus&#x27;, &#123;<br>  inserted: el =&gt; el.focus()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong>移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="其它改变"><a href="#其它改变" class="headerlink" title="其它改变"></a>其它改变</h5><ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.v-enter,<br>.v-leave-to &#123;<br>  opacity: 0;<br>&#125;<br>.v-leave,<br>.v-enter-to &#123;<br>  opacity: 1;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Vue3.x写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.v-enter-from,<br>.v-leave-to &#123;<br>  opacity: 0;<br>&#125;<br><br>.v-leave-from,<br>.v-enter-to &#123;<br>  opacity: 1;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li><p><strong>移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;my-component<br>  v-on:close=&quot;handleComponentEvent&quot;<br>  v-on:click=&quot;handleNativeClickEvent&quot;<br>/&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>子组件中声明自定义事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>  export default &#123;<br>    emits: [&#x27;close&#x27;]<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li><p>…</p>
</li>
</ul>
<h5 id="h函数"><a href="#h函数" class="headerlink" title="h函数"></a>h函数</h5><p>Vue推荐在绝大数情况下<strong>使用模板</strong>来创建你的HTML，然而一些特殊的场景，你真的需要<strong>Javascript的完全编程的能力</strong>，这个时候你可以使用<strong>渲染函数</strong> ，它<strong>比模板更接近编译器</strong>；</p>
<p>前面我们讲解过VNode和VDOM的改变：</p>
<p>Vue在生成真实的DOM之前，会将我们的节点转换成VNode，而VNode组合在一起形成一颗树结构，就是虚拟DOM（VDOM）；</p>
<p>事实上，我们之前编写的 template 中的HTML 最终也是使用<strong>渲染函数</strong>生成对应的VNode；</p>
<p>那么，如果你想充分的利用JavaScript的编程能力，我们可以自己来编写 createVNode 函数，生成对应的 VNode；</p>
<p>那么我们应该怎么来做呢？<strong>使用h()函数</strong></p>
<p>h() 函数是一个用于创建 vnode 的一个函数；</p>
<p>其实更准确的命名是 createVNode() 函数，但是为了简便在Vue将之简化为 h() 函数；</p>
<h6 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h6><p><img  
                     lazyload
                     alt="image"
                     data-src="/../vue3/image-20220817212549041.png"
                      alt="image-20220817212549041"
                ></p>
<p><strong>注意事项：</strong></p>
<p>如果没有props，那么通常可以将children作为第二个参数传入；</p>
<p>如果会产生歧义，可以将null作为第二个参数传入，将children作为第三个参数传入；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>import &#123; h &#125; from &#x27;vue&#x27;<br>export default&#123;<br>  render()&#123;<br>    return h(&#x27;h4&#x27;, &#123;class: &#x27;title&#x27;&#125;, &quot;hello h函数&quot;)<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h6 id="实现计数器"><a href="#实现计数器" class="headerlink" title="实现计数器"></a>实现计数器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>import &#123; h, ref &#125; from &#x27;vue&#x27;<br>export default &#123;<br>  // data()&#123;<br>  //   return &#123;<br>  //     count: 0<br>  //   &#125;<br>  // &#125;,<br><br>  setup() &#123;<br>    let count = ref(0)<br>    // return &#123; count &#125;<br><br>    return () =&gt; &#123;<br>      return h(&#x27;div&#x27;, &#123; class: &#x27;counter&#x27; &#125;, [<br>        h(&#x27;h4&#x27;, null, `当前计数为:$&#123;count.value&#125;`),<br>        h(&#x27;button&#x27;, &#123;<br>          onClick: () =&gt; count.value++<br>        &#125;, &#x27;++&#x27;),<br>        h(&#x27;button&#x27;, &#123;<br>          onClick: () =&gt; count.value--<br>        &#125;, &#x27;--&#x27;)<br>      ])<br>    &#125;<br>  &#125;,<br>  // render()&#123;<br>  //   return h(&#x27;div&#x27;, &#123;class: &#x27;counter&#x27;&#125;, [<br>  //     h(&#x27;h4&#x27;, null, `当前计数为:$&#123;this.count&#125;`),<br>  //     h(&#x27;button&#x27;, &#123;<br>  //       onClick: () =&gt; this.count ++<br>  //     &#125;, &#x27;++&#x27;),<br>  //     h(&#x27;button&#x27;, &#123;<br>  //       onClick: () =&gt; this.count --<br>  //     &#125;, &#x27;--&#x27;)<br>  //   ])<br>  // &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h6 id="渲染插槽"><a href="#渲染插槽" class="headerlink" title="渲染插槽"></a>渲染插槽</h6><blockquote>
<p>先了解下插槽的用法，可参照<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43931876/article/details/120058286" >setup顶层编写方式内的博客网址<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>App.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>import &#123; h &#125; from &#x27;vue&#x27;<br>import Hi from &#x27;./05-Hi&#x27;<br>export default &#123;<br>  setup() &#123;<br>    return () =&gt; &#123;<br>      return h(Hi, null, &#123;<br>        default: props =&gt; h(&#x27;h4&#x27;, null, `05-render函数渲染插槽$&#123;props.title&#125;`)<br>      &#125;)<br>    &#125;<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>Hi.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>import &#123; h &#125; from &#x27;vue&#x27;<br>  export default &#123;<br>    render() &#123;<br>      return h(&#x27;h4&#x27;, &#123;class: &#x27;title&#x27;&#125;, [<br>        h(&#x27;h2&#x27;,null, &quot;hi ~~&quot;),<br>        this.$slots.default ? <br>        this.$slots.default(&#123;title: &quot;--本手俗手妙手无从下手&quot;&#125;) : h(&#x27;span&#x27;, null, &#x27;Hi组件默认插槽内容&#x27;)<br>      ])<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h5 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h5><p>如果我们希望<strong>在项目中使用jsx，那么我们需要添加对jsx的支持</strong>：</p>
<p>jsx我们通常会通过Babel来进行转换（React编写的jsx就是通过babel转换的）；</p>
<p>对于Vue来说，我们只需要在Babel中配置对应的插件即可；</p>
<p>安装<strong>Babel支持Vue的jsx插件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install @vue/babel-plugin-jsx -D<br></code></pre></td></tr></table></figure>

<p>在<strong>babel.config.js</strong>配置文件中配置插件（现在好像不需要配置了）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">module.exports = &#123;<br>  presets: [<br>    &#x27;@vue/cli-plugin-babel/preset&#x27;<br>  ],<br>  plugins: [<br>    &quot;@vue/babel-plugin-jsx&quot;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="实现计数器-1"><a href="#实现计数器-1" class="headerlink" title="实现计数器"></a>实现计数器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      count: 0<br>    &#125;<br>  &#125;,<br>  render() &#123;<br>    const increment = () =&gt; this.count++<br>    const decrement = () =&gt; this.count--<br>    return (<br>      &lt;div&gt;<br>        &lt;h4&gt;当前计数: &#123;this.count&#125;&lt;/h4&gt;<br>        &lt;button onClick=&#123;increment&#125;&gt;++&lt;/button&gt;<br>        &lt;button onClick=&#123;decrement&#125;&gt;--&lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h6 id="组件使用"><a href="#组件使用" class="headerlink" title="组件使用"></a>组件使用</h6><p>Hi.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>export default &#123;<br>  render(h) &#123;<br>    return (<br>      &lt;div&gt;<br>        &lt;h3&gt;Hi组件&lt;/h3&gt;<br>        &#123;this.$slots.default ? this.$slots.default() : &lt;span&gt;哇咔咔&lt;/span&gt;&#125;<br>      &lt;/div&gt;<br>    )<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br><br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>

<p>App.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br>import Hi from &#x27;./06-Hi.vue&#x27;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      count: 0<br>    &#125;<br>  &#125;,<br>  render() &#123;<br>    const increment = () =&gt; this.count++<br>    const decrement = () =&gt; this.count--<br>    return (<br>      &lt;div&gt;<br>        &lt;h4&gt;当前计数: &#123;this.count&#125;&lt;/h4&gt;<br>        &lt;button onClick=&#123;increment&#125;&gt;++&lt;/button&gt;<br>        &lt;button onClick=&#123;decrement&#125;&gt;--&lt;/button&gt;<br>        &lt;Hi&gt;<br>          &#123;&#123;default: props =&gt; &lt;button&gt;我是按钮&lt;/button&gt;&#125;&#125;<br>        &lt;/Hi&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>setup写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br>import Hi from &#x27;./06-Hi.vue&#x27;<br>export default &#123;<br>  setup() &#123;<br>    let count = ref(0)<br>    const increment = () =&gt; count.value++<br>    const decrement = () =&gt; count.value--<br>    const getVal = (num) =&gt; &#123;<br>      console.log(num)<br>      // vue3需要使用高阶函数来获取到e<br>      return (e)=&gt; &#123;  <br>        console.log(e.target.checked)<br>      &#125;<br>    &#125;<br>    return ()=&gt; &#123;<br>      return (<br>        &lt;div&gt;<br>          &lt;input type=&quot;checkbox&quot; checked onChange=&#123; getVal(1) &#125;/&gt;<br>          &lt;h4&gt;当前计数: &#123;count.value&#125;&lt;/h4&gt;<br>          &lt;button onClick=&#123;increment&#125;&gt;++&lt;/button&gt;<br>          &lt;button onClick=&#123;decrement&#125;&gt;--&lt;/button&gt;<br>        &lt;/div&gt;<br>      )<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h5 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h5><p>在Vue的模板语法中我们学习过各种各样的指令：v-show、v-for、v-model等等，除了使用这些指令之外，<strong>Vue也允许我们来自定义自己的指令</strong></p>
<p>注意：在Vue中，代码的复用和抽象主要还是通过组件；</p>
<p>通常在某些情况下，你需要对DOM元素进行底层操作，这个时候就会用到自定义指令；</p>
<p><strong>自定义指令分为两种：</strong></p>
<p>自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用；</p>
<p>自定义全局指令：app的 directive 方法，可以在任意组件中被使用；</p>
<p><strong>比如我们来做一个非常简单的案例：当某个元素挂载完成后可以自定获取焦点</strong></p>
<p>实现方式一：如果我们使用默认的实现方式；</p>
<p>实现方式二：自定义一个 v-focus 的局部指令；</p>
<p>实现方式三：自定义一个 v-focus 的全局指令；</p>
<h6 id="聚焦实现"><a href="#聚焦实现" class="headerlink" title="聚焦实现"></a>聚焦实现</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;input type=&quot;text&quot; ref=&quot;iptRef&quot; v-focus&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; ref, nextTick, onMounted, directives &#125; from &#x27;vue&#x27;<br>export default &#123;<br>  // directives选项<br>  // directives: &#123;<br>  //   focus: &#123;<br>  //     // 指令的生命周期 不是 vue3的生命周期<br>  //     mounted(el) &#123;<br>  //       el.focus()<br>  //     &#125;,<br>  //   &#125;<br>  // &#125;,<br>  setup() &#123;<br>    const iptRef = ref(null)<br><br>    // nextTick(()=&gt;&#123;<br>    //   iptRef.value.focus()<br>    // &#125;)<br><br>    // onMounted(()=&gt; &#123;<br>    //   iptRef.value.focus()<br>    // &#125;)<br><br>    return &#123;<br>      iptRef<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h6 id="局部自定义指令"><a href="#局部自定义指令" class="headerlink" title="局部自定义指令"></a>局部自定义指令</h6><p>自定义一个 v-focus 的局部指令</p>
<p>这个自定义指令实现非常简单，我们只需要在组件选项中使用 directives 即可；</p>
<p>它是一个对象，在对象中编写我们自定义指令的名称（注意：这里不需要加v-）；</p>
<p>自定义指令有一个生命周期，是在组件挂载后调用的 mounted，我们可以在其中完成操作；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;input type=&quot;text&quot; ref=&quot;iptRef&quot; v-focus&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; ref, directives &#125; from &#x27;vue&#x27;<br>export default &#123;<br>  // directives选项<br>  directives: &#123;<br>    focus: &#123;<br>      // 指令的生命周期 不是 vue3的生命周期<br>      mounted(el) &#123;<br>        el.focus()<br>      &#125;,<br>    &#125;<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h6 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 全局自定义指令 =&gt; 放在mount之前<br>app.directive(&quot;focus&quot;, &#123;<br>  mounted(el) &#123;<br>    el.focus()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h6 id="指令的生命周期"><a href="#指令的生命周期" class="headerlink" title="指令的生命周期"></a>指令的生命周期</h6><p><strong>一个指令定义的对象，Vue提供了如下的几个钩子函数：</strong></p>
<p>created：在绑定元素的 attribute 或事件监听器被应用之前调用；</p>
<p>beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用；</p>
<p>mounted：在绑定元素的父组件被挂载后调用；</p>
<p>beforeUpdate：在更新包含组件的 VNode 之前调用；</p>
<p>updated：在包含组件的 VNode <strong>及其子组件的</strong> <strong>VNode</strong> 更新后调用；</p>
<p>beforeUnmount：在卸载绑定元素的父组件之前调用；</p>
<p>unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次；</p>
<h6 id="指令的参数和修饰符"><a href="#指令的参数和修饰符" class="headerlink" title="指令的参数和修饰符"></a>指令的参数和修饰符</h6><p>如果我们指令需要<strong>接受一些参数或者修饰符</strong>应该如何操作呢？</p>
<p>info是参数的名称；</p>
<p>aaa-bbb是修饰符的名称；</p>
<p>后面是传入的具体的值；</p>
<p>在我们的生命周期中，我们可以<strong>通过</strong> <strong>bindings</strong> <strong>获取到对应的内容</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;input type=&quot;text&quot; v-myDir.aaa.bbb=&quot;&#123;name:&#x27;zs&#x27;&#125;&quot; v-if=&quot;count &lt; 5&quot;&gt;<br>  &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;++&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; ref, directives &#125; from &#x27;vue&#x27;<br>export default &#123;<br>  directives: &#123;<br>    myDir: &#123;<br>      created() &#123;<br>        console.log(&#x27;created&#x27;)<br>      &#125;,<br>      beforeMount() &#123;<br>        console.log(&#x27;beforeMount&#x27;)<br>      &#125;,<br>      mounted(el, binding) &#123;<br>        console.log(binding)<br>      &#125;,<br>      beforeUpdate() &#123;<br>        console.log(&#x27;beforeUpdate&#x27;)<br>      &#125;,<br>      updated() &#123;<br>        console.log(&#x27;updated&#x27;)<br>      &#125;,<br>      beforeUnmount() &#123;<br>        console.log(&#x27;beforeUnmount&#x27;)<br>      &#125;,<br>      unmounted() &#123;<br>        console.log(&#x27;unmounted&#x27;)<br>      &#125;,<br>    &#125;<br>  &#125;,<br>  setup() &#123;<br>    let count = ref(0)<br>    const increment = ()=&gt; &#123;<br>      count.value ++<br>    &#125;<br>    return &#123;<br>      count,<br>      increment<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h6 id="自定义指令练习"><a href="#自定义指令练习" class="headerlink" title="自定义指令练习"></a>自定义指令练习</h6><p><strong>自定义指令案例：时间戳的显示需求：</strong></p>
<p>在开发中，大多数情况下从服务器获取到的都是时间戳；</p>
<p>我们需要将时间戳转换成具体格式化的时间来展示；</p>
<p>在Vue2中我们可以通过过滤器来完成；</p>
<p>在Vue3中我们可以通过 计算属性（computed） 或者 自定义一个方法（methods） 来完成；</p>
<p>其实我们还可以通过一个自定义的指令来完成；</p>
<p>我们来实现一个可以自动对<strong>时间格式化的指令v-format-time</strong>：</p>
<p>这里我封装了一个函数，在首页中我们只需要调用这个函数并且传入app即可；</p>
<p><strong>format-time.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import dayjs from &#x27;dayjs&#x27;<br>export default (app) =&gt; &#123;<br>  // 挂载全局自定义指令<br>  app.directive(&#x27;format-time&#x27;, &#123;<br>    mounted(el, binding) &#123;<br>      // 获取到用户指定的格式<br>      let formatStr = binding.value<br>      // 如果用户没有传格式<br>      if(!binding.value)&#123;<br>        // 给个默认的格式<br>        formatStr = &#x27;YYYY-MM-DD hh:mm:ss&#x27;<br>      &#125;<br>      // 拿到组件标签上的时间戳<br>      let timeStamp = el.textContent<br>      if(timeStamp.length == 10)&#123;<br>        // 秒 =&gt; 毫秒<br>        timeStamp = timeStamp * 1000<br>      &#125;<br>      el.textContent = dayjs(parseInt(timeStamp)).format(formatStr)<br>    &#125;,<br>  &#125;)<br>&#125;<br><br>// main.js 引入自定义指令 <br>import &#123; formatTime &#125; from &#x27;./directives&#x27;<br>formatTime(app)<br></code></pre></td></tr></table></figure>

<p><strong>Time.vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;h3 v-format-time=&quot;&#x27;YYYY/MM/DD&#x27;&quot; &gt; 1654766827786 &lt;/h3&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br>export default &#123;<br>  setup() &#123;<br>    let count = ref(0)<br>    const increment = ()=&gt; &#123;<br>      count.value ++<br>    &#125;<br>    return &#123;<br>      count,<br>      increment<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h5 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h5><p>通常我们向Vue全局添加一些功能时，会采用<strong>插件的模式，它有两种编写方式</strong>：</p>
<p>对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行；</p>
<p>函数类型：一个function，这个函数会在安装插件时自动执行；</p>
<p>插件可以<strong>完成的功能没有限制</strong>，比如下面的几种都是可以的：</p>
<p>添加全局方法或者 property，通过把它们添加到 config.globalProperties 上实现；</p>
<p>添加全局资源：指令&#x2F;过滤器&#x2F;过渡等；</p>
<p>通过全局 mixin 来添加一些组件选项；</p>
<p>一个库，提供自己的 API，同时提供上面提到的一个或多个功能；</p>
<p>App.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>  &lt;h3&gt;哥们 你这睡眠质量不行呀 我一般都8小时后才发现&lt;/h3&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;<br>export default &#123;<br>  // mounted()&#123;<br>  //   console.log(this.$msg)<br>  // &#125;<br><br>  setup()&#123;<br>    // console.log(this.$msg)<br>    // setup中没有this指向 所以不能像vue2获取原型上的数据<br>    // 需要按照下面的方式<br>    let instance = getCurrentInstance()<br>    console.log(instance.appContext.config.globalProperties.$msg)<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>// main.js引入插件<br>import msgPluginObject from &#x27;./plugins/msgPlugin-object&#x27;<br>import msgPluginFunction from &#x27;./plugins/msgPlugin-function&#x27;<br>// 使用插件<br>// app.use(msgPluginObject)<br>// use相当于 msgPlugin.install(app)<br>app.use(msgPluginFunction)<br></code></pre></td></tr></table></figure>

<h6 id="函数写法"><a href="#函数写法" class="headerlink" title="函数写法"></a>函数写法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">export default (app) =&gt; &#123;<br>  app.config.globalProperties.$msg = &quot;听说高考数学卷很难 刚刚试了下 两小时后才发现试卷拿反了&quot;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">export default &#123;<br>  install(app)&#123;<br>    // 往app原型上添加属性<br>    app.config.globalProperties.$msg = &quot;听说高考数学卷很难 刚刚试了下 两小时后才发现试卷拿反了&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>待更新 ~</p>
<h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>待更新 ~</p>
<h4 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h4><p>Vuex 作为一个老牌 Vue 状态管理库，大家都很熟悉了</p>
<p>Pinia 是 Vue.js 团队成员专门为 Vue 开发的一个全新的状态管理库，并且已经被纳入官方 <strong><a class="link"   href="https://link.zhihu.com/?target=https://github.com/vuejs/pinia" >github<i class="fas fa-external-link-alt"></i></a></strong></p>
<p><strong>为什么有 Vuex 了还要再开发一个 Pinia ？</strong></p>
<p>先来一张图，看下当时对于**<a class="link"   href="https://link.zhihu.com/?target=https://github.com/vuejs/rfcs/pull/271" > Vuex5 的提案<i class="fas fa-external-link-alt"></i></a>**，就是下一代 Vuex5 应该是什么样子的</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/../vue3/image-20220820223415718.png"
                      alt="image-20220820223415718"
                ></p>
<p>Pinia 就是完整的符合了他当时 Vuex5 提案所提到的功能点，所以可以说 Pinia 就是 Vuex5 也不为过，因为它的作者就是官方的开发人员，并且已经被官方接管了，只是目前 Vuex 和 Pinia 还是两个独立的仓库，以后可能会合并，也可能独立发展，只是官方肯定推荐的是 Pinia</p>
<p>因为在 Vue3 中使用 Vuex 的话需要使用 Vuex4，并且还只能作为一个过渡的选择，存在很大缺陷，所以在 Componsition API 诞生之后，也就设计了全新的状态管理 Pinia</p>
<h5 id="Pinia-特性"><a href="#Pinia-特性" class="headerlink" title="Pinia 特性"></a><strong>Pinia 特性</strong></h5><ul>
<li>Pinia 没有 <code>Mutations</code></li>
<li><code>Actions</code> 支持同步和异步</li>
<li>没有模块的嵌套结构</li>
<li><ul>
<li>Pinia 通过设计提供扁平结构，就是说每个 store 都是互相独立的，谁也不属于谁，也就是扁平化了，更好的代码分割且没有命名空间。当然你也可以通过在一个模块中导入另一个模块来隐式嵌套 store，甚至可以拥有 store 的循环依赖关系</li>
</ul>
</li>
<li>更好的 <code>TypeScript</code> 支持</li>
<li><ul>
<li>不需要再创建自定义的复杂包装器来支持 TypeScript 所有内容都类型化，并且 API 的设计方式也尽可能的使用 TS 类型推断</li>
</ul>
</li>
<li>不需要注入、导入函数、调用它们，享受自动补全，让我们开发更加方便</li>
<li>无需手动添加 store，它的模块默认情况下创建就自动注册的</li>
<li>Vue2 和 Vue3 都支持</li>
<li><ul>
<li>除了初始化安装和SSR配置之外，两者使用上的API都是相同的</li>
</ul>
</li>
<li>支持 <code>Vue DevTools</code></li>
<li><ul>
<li>跟踪 actions, mutations 的时间线</li>
<li>在使用了模块的组件中就可以观察到模块本身</li>
<li>支持 time-travel 更容易调试</li>
<li>在 Vue2 中 Pinia 会使用 Vuex 的所有接口，所以它俩不能一起使用</li>
<li>但是针对 Vue3 的调试工具支持还不够完美，比如还没有 time-travel 功能</li>
</ul>
</li>
<li>模块热更新</li>
<li><ul>
<li>无需重新加载页面就可以修改模块</li>
<li>热更新的时候会保持任何现有状态</li>
</ul>
</li>
<li>支持使用插件扩展 Pinia 功能</li>
<li>支持服务端渲染</li>
</ul>
<h5 id="Pinia-和-Vuex"><a href="#Pinia-和-Vuex" class="headerlink" title="Pinia 和 Vuex"></a>Pinia 和 Vuex</h5><p>上面的也算 ~</p>
<p><strong>核心区别</strong></p>
<p><strong>Vuex</strong>： <code>State</code>、<code>Gettes</code>、<code>Mutations</code>(同步)、<code>Actions</code>(异步)</p>
<p><strong>Pinia</strong>： <code>State</code>、<code>Gettes</code>、<code>Actions</code>(同步异步都支持)</p>
<p><strong>版本支持</strong></p>
<p>Vuex 当前最新版是 <code>4.x</code></p>
<ul>
<li>Vuex4 用于 Vue3</li>
<li>Vuex3 用于 Vue2</li>
</ul>
<p>Pinia 当前最新版是 <code>2.x</code></p>
<ul>
<li>即支持 Vue2 也支持 Vue3</li>
</ul>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>个人感觉：，由于Pinea是轻量级的，体积很小，它适合于中小型应用。它也适用于低复杂度的Vue.js项目，因为一些调试功能，如时间旅行和编辑仍然不被支持。<br>将 Vuex 用于中小型 Vue.js 项目是过度的，因为它重量级的，对性能降低有很大影响。因此，Vuex 适用于大规模、高复杂度的 Vue.js 项目</p>
<h5 id="pinia使用"><a href="#pinia使用" class="headerlink" title="pinia使用"></a>pinia使用</h5><h6 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h6><p>想要学习<code>pinia</code>，最好有<code>Vue3</code>的基础，明白组合式<code>API</code>是什么。如果你还不会<code>Vue3</code>，建议先去学习<code>Vue3</code>。</p>
<p>本篇全部基于<code>Vue3</code>来讲解pinia，至于<code>Vue2</code>中如何使用<code>pinia</code>，大家可以自行去<code>pinia</code>官网学习，毕竟<code>Vue2</code>中使用<code>pinia</code>的还是少数。</p>
<h6 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h6><p>我们这里搭建一个最新的<code>Vue3 + TS + Vite</code>项目。</p>
<p>执行命令：<code>vue create vue-pinia</code> 选择babel、vue3、ts，创建完毕，清空项目，启动项目 ~</p>
<h6 id="安装pinia"><a href="#安装pinia" class="headerlink" title="安装pinia"></a>安装pinia</h6><p>执行命令：<code>npm install pinia</code></p>
<h6 id="使用pinia"><a href="#使用pinia" class="headerlink" title="使用pinia"></a>使用pinia</h6><p>安装完成后我们需要将<code>pinia</code>挂载到<code>Vue</code>应用中，也就是我们需要创建一个根存储传递给应用程序，简单来说就是创建一个存储数据的数据桶，放到应用程序中去。</p>
<p>修改<code>main.js</code>，引入<code>pinia</code>提供的<code>createPinia</code>方法，创建根存储。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// main.ts<br><br>import &#123; createApp &#125; from &quot;vue&quot;;<br>import App from &quot;./App.vue&quot;;<br>import &#123; createPinia &#125; from &quot;pinia&quot;;<br>const pinia = createPinia();<br><br>const app = createApp(App);<br>app.use(pinia);<br>app.mount(&quot;#app&quot;);<br></code></pre></td></tr></table></figure>

<p>在 store 目录下创建一个 <code>user.ts</code> 为例，我们先定义并导出一个名为 <code>user</code> 的模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import &#123; defineStore &#125; from &#x27;pinia&#x27;<br>export const userStore = defineStore(&#x27;user&#x27;, &#123;<br>    state: () =&gt; &#123;<br>        return &#123; <br>            count: 1,<br>            arr: []<br>        &#125;<br>    &#125;,<br>    getters: &#123; ... &#125;,<br>    actions: &#123; ... &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><code>defineStore</code> 接收两个参数</p>
<p>第一个参数就是模块的名称，必须是唯一的，多个模块不能重名，Pinia 会把所有的模块都挂载到根容器上<br>第二个参数是一个对象，里面的选项和 Vuex 差不多</p>
<ul>
<li>其中 <code>state</code> 用来存储全局状态，它必须是箭头函数，为了在服务端渲染的时候避免交叉请求导致的数据状态污染所以只能是函数，而必须用箭头函数则为了更好的 TS 类型推导</li>
<li><code>getters</code> 就是用来封装计算属性，它有缓存的功能</li>
<li><code>actions</code> 就是用来封装业务逻辑，修改 state</li>
</ul>
<h6 id="访问-state"><a href="#访问-state" class="headerlink" title="访问 state"></a>访问 state</h6><p>比如我们要在页面中访问 state 里的属性 count</p>
<p>由于 <code>defineStore</code> 会返回一个函数，所以要先调用拿到数据对象，然后就可以在模板中直接使用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>    &lt;div&gt;&#123;&#123; user_store.count &#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script lang=&quot;ts&quot; setup&gt;<br>import &#123; userStore &#125; from &#x27;../store&#x27;<br>const user_store = userStore()<br>// 解构<br>// const &#123; count &#125; = userStore()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>比如像注释中的解构出来使用，是完全没有问题的，只是注意了，这样拿到的数据不是<code>响应式</code>的，如果要解构还保持响应式就要用到一个方法 <code>storeToRefs()</code>，示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>    &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script lang=&quot;ts&quot; setup&gt;<br>import &#123; storeToRefs &#125; from &#x27;pinia&#x27;<br>import &#123; userStore &#125; from &#x27;../store&#x27;<br>const &#123; count &#125; = storeToRefs(userStore)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>原因就是 Pinia 其实是把 state 数据都做了 <code>reactive</code> 处理，和 Vue3 的 reactive 同理，解构出来的也不是响应式，所以需要再做 <code>ref</code> 响应式代理</p>
<h6 id="getters"><a href="#getters" class="headerlink" title="getters"></a><strong>getters</strong></h6><p>这个和 Vuex 的 getters 一样，也有缓存功能。如下在页面中多次使用，第一次会调用 getters，数据没有改变的情况下之后会读取缓存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>    &lt;div&gt;&#123;&#123; myCount &#125;&#125;&lt;/div&gt;<br>    &lt;div&gt;&#123;&#123; myCount &#125;&#125;&lt;/div&gt;<br>    &lt;div&gt;&#123;&#123; myCount &#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>注意两种方法的区别，写在注释里了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">getters: &#123;<br>    // 方法一，接收一个可选参数 state<br>    myCount(state)&#123;<br>        console.log(&#x27;调用了&#x27;) // 页面中使用了三次，这里只会执行一次，然后缓存起来了<br>        return state.count + 1<br>    &#125;,<br>    // 方法二，不传参数，使用 this<br>    // 但是必须指定函数返回值的类型，否则类型推导不出来<br>    myCount(): number&#123;<br>        return this.count + 1<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="actions"><a href="#actions" class="headerlink" title="actions"></a><strong>actions</strong></h6><p>更新 state 里的数据有四种方法，我们先看三种简单的更新，说明都写在注释里了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>    &lt;div&gt;&#123;&#123; user_store.count &#125;&#125;&lt;/div&gt;<br>    &lt;button @click=&quot;handleClick&quot;&gt;按钮&lt;/button&gt;<br>&lt;/template&gt;<br>&lt;script lang=&quot;ts&quot; setup&gt;<br>import &#123; userStore &#125; from &#x27;../store&#x27;<br>const user_store = userStore()<br>const handleClick = () =&gt; &#123;<br>    // 方法一<br>    user_store.count++<br>    <br>    // 方法二，需要修改多个数据，建议用 $patch 批量更新，传入一个对象<br>    user_store.$patch(&#123;<br>        count: user_store.count1++,<br>        // arr: user_store.arr.push(1) // 错误<br>        arr: [ ...user_store.arr, 1 ] // 可以，但是还得把整个数组都拿出来解构，就没必要<br>    &#125;)<br>    <br>    // 使用 $patch 性能更优，因为多个数据更新只会更新一次视图<br>    <br>    // 方法三，还是$patch，传入函数，第一个参数就是 state<br>    user_store.$patch( state =&gt; &#123;<br>        state.count++<br>        state.arr.push(1)<br>    &#125;)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>第四种方法就是当逻辑比较多或者请求的时候，我们就可以封装到示例中 store&#x2F;user.ts 里的 actions 里</p>
<p>可以传参数，也可以通过 this.xx 可以直接获取到 state 里的数据，需要注意的是不能用箭头函数定义 actions，不然就会绑定外部的 this 了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">actions: &#123;<br>    changeState(num: number)&#123; // 不能用箭头函数<br>        this.count += num<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">const handleClick = () =&gt; &#123;<br>    user_store.changeState(1)<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="支持-VueDevtools"><a href="#支持-VueDevtools" class="headerlink" title="支持 VueDevtools"></a><strong>支持 VueDevtools</strong></h6><p>打开开发者工具的 <code>Vue Devtools</code> 就会发现 Pinia，而且可以手动修改数据调试，非常方便</p>
<h6 id="模拟调用接口"><a href="#模拟调用接口" class="headerlink" title="模拟调用接口"></a><strong>模拟调用接口</strong></h6><p>示例：</p>
<p>我们先定义示例接口 api&#x2F;user.ts</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 接口数据类型<br>export interface userListType&#123;<br>    id: number<br>    name: string<br>    age: number<br>&#125;<br>// 模拟请求接口返回的数据<br>const userList = [<br>    &#123; id: 1, name: &#x27;张三&#x27;, age: 18 &#125;,<br>    &#123; id: 2, name: &#x27;李四&#x27;, age: 19 &#125;,<br>]<br>// 封装模拟异步效果的定时器<br>async function wait(delay: number)&#123;<br>    return new Promise((resolve) =&gt; setTimeout(resolve, delay))<br>&#125;<br>// 接口<br>export const getUserList = async () =&gt; &#123;<br>    await wait(100) // 延迟100毫秒返回<br>    return userList<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后在 store&#x2F;user.ts 里的 actions 封装调用接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import &#123; defineStore &#125; from &#x27;pinia&#x27;<br>import &#123; getUserList, userListType &#125; from &#x27;../api/user&#x27;<br>export const userStore = defineStore(&#x27;user&#x27;, &#123;<br>    state: () =&gt; &#123;<br>        return &#123;<br>            // 用户列表<br>            list: [] as userListType // 类型转换成 userListType<br>        &#125;<br>    &#125;,<br>    actions: &#123; <br>        async loadUserList()&#123;<br>            const list = await getUserList()<br>            this.list = list<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>页面中调用 actions 发起请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;template&gt;<br>    &lt;ul&gt;<br>        &lt;li v-for=&quot;item in user_store.list&quot;&gt; ... &lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/template&gt;<br>&lt;script lang=&quot;ts&quot; setup&gt;<br>import &#123; userStore &#125; from &#x27;../store&#x27;<br>const user_store = userStore()<br>user_store.loadUserList() // 加载所有数据<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h6 id="跨模块修改数据"><a href="#跨模块修改数据" class="headerlink" title="跨模块修改数据"></a><strong>跨模块修改数据</strong></h6><p>在一个模块的 actions 里需要修改另一个模块的 state 数据</p>
<p>示例：比如在 chat 模块里修改 user 模块里某个用户的名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// chat.ts<br>import &#123; defineStore &#125; from &#x27;pinia&#x27;<br>import &#123; userStore &#125; from &#x27;./user&#x27;<br>export const chatStore = defineStore(&#x27;chat&#x27;, &#123;<br>    actions: &#123; <br>        someMethod(userItem)&#123;<br>            userItem.name = &#x27;新的名字&#x27;<br>            const user_store = userStore()<br>            user_store.updateUserName(userItem)<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>user 模块里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// user.ts<br>import &#123; defineStore &#125; from &#x27;pinia&#x27;<br>export const userStore = defineStore(&#x27;user&#x27;, &#123;<br>    state: () =&gt; &#123;<br>        return &#123;<br>            list: []<br>        &#125;<br>    &#125;,<br>    actions: &#123; <br>        updateUserName(userItem)&#123;<br>            const user = this.list.find(item =&gt; item.id === userItem.id)<br>            if(user)&#123;<br>                user.name = userItem.name<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>————————————— The End —————————————</p>

            </div>

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2022/10/29/package/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item text-ellipsis">package文件解析</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2022/07/11/Eslint/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item text-ellipsis">Eslint</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
                






            
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#vue3%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">vue3简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue3%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">2.</span> <span class="nav-text">Vue3带来了什么</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%90%E5%8D%87"><span class="nav-number">2.1.</span> <span class="nav-text">1.性能的提升</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%BA%90%E7%A0%81%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="nav-number">2.2.</span> <span class="nav-text">2.源码的升级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8B%A5%E6%8A%B1TypeScript"><span class="nav-number">2.3.</span> <span class="nav-text">3.拥抱TypeScript</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%96%B0%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">2.4.</span> <span class="nav-text">4.新的特性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAvue3%E9%A1%B9%E7%9B%AE"><span class="nav-number">3.</span> <span class="nav-text">创建vue3项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Options-API%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="nav-number">4.</span> <span class="nav-text">Options API的弊端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86Composition-API"><span class="nav-number">5.</span> <span class="nav-text">认识Composition API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#setup%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">setup函数的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setup%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">5.2.</span> <span class="nav-text">setup函数的返回值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reactive%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">reactive函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ref%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">ref函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#toRefs"><span class="nav-number">7.1.</span> <span class="nav-text">toRefs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#toRef"><span class="nav-number">7.2.</span> <span class="nav-text">toRef</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ref%E7%9A%84%E5%85%B6%E5%AE%83API"><span class="nav-number">7.3.</span> <span class="nav-text">ref的其它API</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#unref"><span class="nav-number">7.3.1.</span> <span class="nav-text">unref</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#isRef"><span class="nav-number">7.3.2.</span> <span class="nav-text">isRef</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#shallowRef"><span class="nav-number">7.3.3.</span> <span class="nav-text">shallowRef</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#triggerRef"><span class="nav-number">7.3.4.</span> <span class="nav-text">triggerRef</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#shallowRef-1"><span class="nav-number">7.3.5.</span> <span class="nav-text">shallowRef</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#customRef"><span class="nav-number">7.3.6.</span> <span class="nav-text">customRef</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">响应式原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#vue2"><span class="nav-number">8.1.</span> <span class="nav-text">vue2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#vue3"><span class="nav-number">8.2.</span> <span class="nav-text">vue3</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ref-amp-reactive"><span class="nav-number">9.</span> <span class="nav-text">ref &amp; reactive</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readonly"><span class="nav-number">10.</span> <span class="nav-text">readonly</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reactive-%E5%88%A4%E6%96%AD%E7%9A%84API"><span class="nav-number">11.</span> <span class="nav-text">reactive 判断的API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#isProxy"><span class="nav-number">11.1.</span> <span class="nav-text">isProxy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isReactive"><span class="nav-number">11.2.</span> <span class="nav-text">isReactive</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isReadonly"><span class="nav-number">11.3.</span> <span class="nav-text">isReadonly</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#toRaw"><span class="nav-number">11.4.</span> <span class="nav-text">toRaw</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#shallowReactive"><span class="nav-number">11.5.</span> <span class="nav-text">shallowReactive</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#shallowReadonly"><span class="nav-number">11.6.</span> <span class="nav-text">shallowReadonly</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83-Composition-API"><span class="nav-number">12.</span> <span class="nav-text">其它 Composition API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#toRaw-amp-markRaw"><span class="nav-number">12.1.</span> <span class="nav-text">toRaw &amp; markRaw</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#provide-%E4%B8%8E-inject"><span class="nav-number">12.2.</span> <span class="nav-text">provide 与 inject</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E8%A7%86"><span class="nav-number">13.</span> <span class="nav-text">计算属性与监视</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#computed"><span class="nav-number">13.1.</span> <span class="nav-text">computed</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watch"><span class="nav-number">13.2.</span> <span class="nav-text">watch</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watchEffect"><span class="nav-number">13.3.</span> <span class="nav-text">watchEffect</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watchEffect-%E5%81%9C%E6%AD%A2%E4%BE%A6%E5%90%AC"><span class="nav-number">13.4.</span> <span class="nav-text">watchEffect 停止侦听</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watchEffect-%E6%B8%85%E9%99%A4%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-number">13.5.</span> <span class="nav-text">watchEffect 清除副作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setup%E4%B8%AD%E4%BD%BF%E7%94%A8ref"><span class="nav-number">13.6.</span> <span class="nav-text">setup中使用ref</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watchEffect%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="nav-number">13.7.</span> <span class="nav-text">watchEffect的执行时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E6%95%B4watchEffect%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="nav-number">13.8.</span> <span class="nav-text">调整watchEffect的执行时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watch%E5%87%BD%E6%95%B0"><span class="nav-number">13.9.</span> <span class="nav-text">watch函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="nav-number">14.</span> <span class="nav-text">生命周期函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%87%BD%E6%95%B0"><span class="nav-number">15.</span> <span class="nav-text">自定义hook函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup%E7%9A%84%E9%A1%B6%E5%B1%82%E7%BC%96%E5%86%99%E6%96%B9%E5%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">setup的顶层编写方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-number">17.</span> <span class="nav-text">新的组件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Fragment"><span class="nav-number">17.0.1.</span> <span class="nav-text">Fragment</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Teleport"><span class="nav-number">17.0.2.</span> <span class="nav-text">Teleport</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Suspense"><span class="nav-number">17.0.3.</span> <span class="nav-text">Suspense</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">17.1.</span> <span class="nav-text">其它</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E5%B1%80API%E7%9A%84%E8%BD%AC%E7%A7%BB"><span class="nav-number">17.2.</span> <span class="nav-text">全局API的转移</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E6%94%B9%E5%8F%98"><span class="nav-number">17.3.</span> <span class="nav-text">其它改变</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#h%E5%87%BD%E6%95%B0"><span class="nav-number">17.4.</span> <span class="nav-text">h函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">17.4.1.</span> <span class="nav-text">如何使用？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">17.4.2.</span> <span class="nav-text">实现计数器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E6%8F%92%E6%A7%BD"><span class="nav-number">17.4.3.</span> <span class="nav-text">渲染插槽</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jsx"><span class="nav-number">17.5.</span> <span class="nav-text">jsx</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%AE%A1%E6%95%B0%E5%99%A8-1"><span class="nav-number">17.5.1.</span> <span class="nav-text">实现计数器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="nav-number">17.5.2.</span> <span class="nav-text">组件使用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">17.6.</span> <span class="nav-text">自定义指令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%81%9A%E7%84%A6%E5%AE%9E%E7%8E%B0"><span class="nav-number">17.6.1.</span> <span class="nav-text">聚焦实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">17.6.2.</span> <span class="nav-text">局部自定义指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">17.6.3.</span> <span class="nav-text">全局自定义指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">17.6.4.</span> <span class="nav-text">指令的生命周期</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">17.6.5.</span> <span class="nav-text">指令的参数和修饰符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%BB%83%E4%B9%A0"><span class="nav-number">17.6.6.</span> <span class="nav-text">自定义指令练习</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#plugins"><span class="nav-number">17.7.</span> <span class="nav-text">plugins</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%86%99%E6%B3%95"><span class="nav-number">17.7.1.</span> <span class="nav-text">函数写法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95"><span class="nav-number">17.7.2.</span> <span class="nav-text">对象写法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1"><span class="nav-number">18.</span> <span class="nav-text">路由</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vuex"><span class="nav-number">19.</span> <span class="nav-text">Vuex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pinia"><span class="nav-number">20.</span> <span class="nav-text">Pinia</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Pinia-%E7%89%B9%E6%80%A7"><span class="nav-number">20.1.</span> <span class="nav-text">Pinia 特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pinia-%E5%92%8C-Vuex"><span class="nav-number">20.2.</span> <span class="nav-text">Pinia 和 Vuex</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">20.3.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pinia%E4%BD%BF%E7%94%A8"><span class="nav-number">20.4.</span> <span class="nav-text">pinia使用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">20.4.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA"><span class="nav-number">20.4.2.</span> <span class="nav-text">项目搭建</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%89%E8%A3%85pinia"><span class="nav-number">20.4.3.</span> <span class="nav-text">安装pinia</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8pinia"><span class="nav-number">20.4.4.</span> <span class="nav-text">使用pinia</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE-state"><span class="nav-number">20.4.5.</span> <span class="nav-text">访问 state</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#getters"><span class="nav-number">20.4.6.</span> <span class="nav-text">getters</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#actions"><span class="nav-number">20.4.7.</span> <span class="nav-text">actions</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%AF%E6%8C%81-VueDevtools"><span class="nav-number">20.4.8.</span> <span class="nav-text">支持 VueDevtools</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">20.4.9.</span> <span class="nav-text">模拟调用接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B7%A8%E6%A8%A1%E5%9D%97%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="nav-number">20.4.10.</span> <span class="nav-text">跨模块修改数据</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;2025
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">刘小烨</a>
                
            </div>

            <div class="theme-info info-item default">
                Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.7.3</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            

            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#vue3%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">vue3简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue3%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">2.</span> <span class="nav-text">Vue3带来了什么</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%90%E5%8D%87"><span class="nav-number">2.1.</span> <span class="nav-text">1.性能的提升</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%BA%90%E7%A0%81%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="nav-number">2.2.</span> <span class="nav-text">2.源码的升级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8B%A5%E6%8A%B1TypeScript"><span class="nav-number">2.3.</span> <span class="nav-text">3.拥抱TypeScript</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%96%B0%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">2.4.</span> <span class="nav-text">4.新的特性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAvue3%E9%A1%B9%E7%9B%AE"><span class="nav-number">3.</span> <span class="nav-text">创建vue3项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Options-API%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="nav-number">4.</span> <span class="nav-text">Options API的弊端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86Composition-API"><span class="nav-number">5.</span> <span class="nav-text">认识Composition API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#setup%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">setup函数的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setup%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">5.2.</span> <span class="nav-text">setup函数的返回值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reactive%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">reactive函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ref%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">ref函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#toRefs"><span class="nav-number">7.1.</span> <span class="nav-text">toRefs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#toRef"><span class="nav-number">7.2.</span> <span class="nav-text">toRef</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ref%E7%9A%84%E5%85%B6%E5%AE%83API"><span class="nav-number">7.3.</span> <span class="nav-text">ref的其它API</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#unref"><span class="nav-number">7.3.1.</span> <span class="nav-text">unref</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#isRef"><span class="nav-number">7.3.2.</span> <span class="nav-text">isRef</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#shallowRef"><span class="nav-number">7.3.3.</span> <span class="nav-text">shallowRef</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#triggerRef"><span class="nav-number">7.3.4.</span> <span class="nav-text">triggerRef</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#shallowRef-1"><span class="nav-number">7.3.5.</span> <span class="nav-text">shallowRef</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#customRef"><span class="nav-number">7.3.6.</span> <span class="nav-text">customRef</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">响应式原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#vue2"><span class="nav-number">8.1.</span> <span class="nav-text">vue2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#vue3"><span class="nav-number">8.2.</span> <span class="nav-text">vue3</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ref-amp-reactive"><span class="nav-number">9.</span> <span class="nav-text">ref &amp; reactive</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readonly"><span class="nav-number">10.</span> <span class="nav-text">readonly</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reactive-%E5%88%A4%E6%96%AD%E7%9A%84API"><span class="nav-number">11.</span> <span class="nav-text">reactive 判断的API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#isProxy"><span class="nav-number">11.1.</span> <span class="nav-text">isProxy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isReactive"><span class="nav-number">11.2.</span> <span class="nav-text">isReactive</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isReadonly"><span class="nav-number">11.3.</span> <span class="nav-text">isReadonly</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#toRaw"><span class="nav-number">11.4.</span> <span class="nav-text">toRaw</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#shallowReactive"><span class="nav-number">11.5.</span> <span class="nav-text">shallowReactive</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#shallowReadonly"><span class="nav-number">11.6.</span> <span class="nav-text">shallowReadonly</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83-Composition-API"><span class="nav-number">12.</span> <span class="nav-text">其它 Composition API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#toRaw-amp-markRaw"><span class="nav-number">12.1.</span> <span class="nav-text">toRaw &amp; markRaw</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#provide-%E4%B8%8E-inject"><span class="nav-number">12.2.</span> <span class="nav-text">provide 与 inject</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E8%A7%86"><span class="nav-number">13.</span> <span class="nav-text">计算属性与监视</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#computed"><span class="nav-number">13.1.</span> <span class="nav-text">computed</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watch"><span class="nav-number">13.2.</span> <span class="nav-text">watch</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watchEffect"><span class="nav-number">13.3.</span> <span class="nav-text">watchEffect</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watchEffect-%E5%81%9C%E6%AD%A2%E4%BE%A6%E5%90%AC"><span class="nav-number">13.4.</span> <span class="nav-text">watchEffect 停止侦听</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watchEffect-%E6%B8%85%E9%99%A4%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-number">13.5.</span> <span class="nav-text">watchEffect 清除副作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setup%E4%B8%AD%E4%BD%BF%E7%94%A8ref"><span class="nav-number">13.6.</span> <span class="nav-text">setup中使用ref</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watchEffect%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="nav-number">13.7.</span> <span class="nav-text">watchEffect的执行时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E6%95%B4watchEffect%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="nav-number">13.8.</span> <span class="nav-text">调整watchEffect的执行时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watch%E5%87%BD%E6%95%B0"><span class="nav-number">13.9.</span> <span class="nav-text">watch函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="nav-number">14.</span> <span class="nav-text">生命周期函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%87%BD%E6%95%B0"><span class="nav-number">15.</span> <span class="nav-text">自定义hook函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup%E7%9A%84%E9%A1%B6%E5%B1%82%E7%BC%96%E5%86%99%E6%96%B9%E5%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">setup的顶层编写方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-number">17.</span> <span class="nav-text">新的组件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Fragment"><span class="nav-number">17.0.1.</span> <span class="nav-text">Fragment</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Teleport"><span class="nav-number">17.0.2.</span> <span class="nav-text">Teleport</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Suspense"><span class="nav-number">17.0.3.</span> <span class="nav-text">Suspense</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">17.1.</span> <span class="nav-text">其它</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E5%B1%80API%E7%9A%84%E8%BD%AC%E7%A7%BB"><span class="nav-number">17.2.</span> <span class="nav-text">全局API的转移</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E6%94%B9%E5%8F%98"><span class="nav-number">17.3.</span> <span class="nav-text">其它改变</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#h%E5%87%BD%E6%95%B0"><span class="nav-number">17.4.</span> <span class="nav-text">h函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">17.4.1.</span> <span class="nav-text">如何使用？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">17.4.2.</span> <span class="nav-text">实现计数器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E6%8F%92%E6%A7%BD"><span class="nav-number">17.4.3.</span> <span class="nav-text">渲染插槽</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jsx"><span class="nav-number">17.5.</span> <span class="nav-text">jsx</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%AE%A1%E6%95%B0%E5%99%A8-1"><span class="nav-number">17.5.1.</span> <span class="nav-text">实现计数器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="nav-number">17.5.2.</span> <span class="nav-text">组件使用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">17.6.</span> <span class="nav-text">自定义指令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%81%9A%E7%84%A6%E5%AE%9E%E7%8E%B0"><span class="nav-number">17.6.1.</span> <span class="nav-text">聚焦实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">17.6.2.</span> <span class="nav-text">局部自定义指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">17.6.3.</span> <span class="nav-text">全局自定义指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">17.6.4.</span> <span class="nav-text">指令的生命周期</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">17.6.5.</span> <span class="nav-text">指令的参数和修饰符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%BB%83%E4%B9%A0"><span class="nav-number">17.6.6.</span> <span class="nav-text">自定义指令练习</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#plugins"><span class="nav-number">17.7.</span> <span class="nav-text">plugins</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%86%99%E6%B3%95"><span class="nav-number">17.7.1.</span> <span class="nav-text">函数写法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95"><span class="nav-number">17.7.2.</span> <span class="nav-text">对象写法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1"><span class="nav-number">18.</span> <span class="nav-text">路由</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vuex"><span class="nav-number">19.</span> <span class="nav-text">Vuex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pinia"><span class="nav-number">20.</span> <span class="nav-text">Pinia</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Pinia-%E7%89%B9%E6%80%A7"><span class="nav-number">20.1.</span> <span class="nav-text">Pinia 特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pinia-%E5%92%8C-Vuex"><span class="nav-number">20.2.</span> <span class="nav-text">Pinia 和 Vuex</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">20.3.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pinia%E4%BD%BF%E7%94%A8"><span class="nav-number">20.4.</span> <span class="nav-text">pinia使用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">20.4.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA"><span class="nav-number">20.4.2.</span> <span class="nav-text">项目搭建</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%89%E8%A3%85pinia"><span class="nav-number">20.4.3.</span> <span class="nav-text">安装pinia</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8pinia"><span class="nav-number">20.4.4.</span> <span class="nav-text">使用pinia</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE-state"><span class="nav-number">20.4.5.</span> <span class="nav-text">访问 state</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#getters"><span class="nav-number">20.4.6.</span> <span class="nav-text">getters</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#actions"><span class="nav-number">20.4.7.</span> <span class="nav-text">actions</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%AF%E6%8C%81-VueDevtools"><span class="nav-number">20.4.8.</span> <span class="nav-text">支持 VueDevtools</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">20.4.9.</span> <span class="nav-text">模拟调用接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B7%A8%E6%A8%A1%E5%9D%97%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="nav-number">20.4.10.</span> <span class="nav-text">跨模块修改数据</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/local-search.js"></script>





    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/toc.js"></script>
        
    
    
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>




</body>
</html>
